"""Battery monitoring utilities for INA219-backed LiPo packs."""

from __future__ import annotations

from dataclasses import dataclass
from typing import Callable, Iterable, Sequence

SensorFactory = Callable[[], object]


@dataclass(slots=True)
class BatteryReading:
    """Structured battery information exposed through the API."""

    available: bool
    percentage: float | None
    voltage: float | None
    current_ma: float | None
    charging: bool | None
    capacity_mah: int
    error: str | None = None

    def to_dict(self) -> dict[str, object | None]:
        """Serialise the reading into a JSON-friendly dictionary."""
        return {
            "available": self.available,
            "percentage": self.percentage,
            "voltage": self.voltage,
            "current_ma": self.current_ma,
            "charging": self.charging,
            "capacity_mah": self.capacity_mah,
            "error": self.error,
        }


class BatteryMonitor:
    """Provide high-level battery readings using an INA219 sensor.

    The monitor lazily instantiates the INA219 driver to keep unit tests free
    from hardware dependencies.  When the driver or hardware is unavailable the
    :meth:`read` method returns an unavailable reading that includes the last
    error message so the caller can surface it to the UI.
    """

    _LIPO_VOLTAGE_CURVE: Sequence[tuple[float, float]] = (
        (3.0, 0.0),
        (3.2, 5.0),
        (3.3, 10.0),
        (3.4, 15.0),
        (3.5, 25.0),
        (3.6, 35.0),
        (3.7, 50.0),
        (3.8, 70.0),
        (3.9, 85.0),
        (4.0, 92.0),
        (4.1, 97.0),
        (4.2, 100.0),
    )

    def __init__(self, capacity_mah: int = 1000, sensor_factory: SensorFactory | None = None) -> None:
        self.capacity_mah = capacity_mah
        self._sensor_factory = sensor_factory
        self._sensor: object | None = None
        self._last_error: str | None = None

    @property
    def last_error(self) -> str | None:
        """Return the most recent error generated by the monitor."""

        return self._last_error

    def _create_default_sensor(self) -> object:
        """Attempt to instantiate the INA219 driver."""

        try:  # Import lazily so unit tests do not require the dependencies.
            import board  # type: ignore
            from adafruit_ina219 import INA219  # type: ignore
        except Exception as exc:  # pragma: no cover - import varies by environment
            raise RuntimeError("INA219 driver unavailable") from exc

        try:
            i2c = board.I2C()  # type: ignore[attr-defined]
        except Exception as exc:  # pragma: no cover - hardware specific
            raise RuntimeError("Unable to access I2C bus") from exc

        try:
            return INA219(i2c)  # type: ignore[call-arg]
        except Exception as exc:  # pragma: no cover - hardware specific
            raise RuntimeError(f"Failed to initialise INA219: {exc}") from exc

    def _obtain_sensor(self) -> object | None:
        if self._sensor is not None:
            return self._sensor

        factory = self._sensor_factory
        if factory is None:
            try:
                sensor = self._create_default_sensor()
            except RuntimeError as exc:
                self._last_error = str(exc)
                return None
        else:
            try:
                sensor = factory()
            except Exception as exc:
                self._last_error = str(exc)
                return None

        self._sensor = sensor
        self._last_error = None
        return sensor

    def _estimate_percentage(self, voltage: float) -> float:
        curve: Sequence[tuple[float, float]] = self._LIPO_VOLTAGE_CURVE
        if not curve:
            return 0.0

        if voltage <= curve[0][0]:
            return max(0.0, curve[0][1])
        if voltage >= curve[-1][0]:
            return min(100.0, curve[-1][1])

        for lower, upper in _pairwise(curve):
            lower_v, lower_p = lower
            upper_v, upper_p = upper
            if voltage <= upper_v:
                span = upper_v - lower_v
                if span <= 0:
                    return max(0.0, min(100.0, upper_p))
                ratio = (voltage - lower_v) / span
                percentage = lower_p + ratio * (upper_p - lower_p)
                return max(0.0, min(100.0, percentage))

        return max(0.0, min(100.0, curve[-1][1]))

    def read(self) -> BatteryReading:
        """Return the latest battery reading, handling hardware failures."""

        sensor = self._obtain_sensor()
        if sensor is None:
            return BatteryReading(
                available=False,
                percentage=None,
                voltage=None,
                current_ma=None,
                charging=None,
                capacity_mah=self.capacity_mah,
                error=self._last_error,
            )

        try:
            bus_voltage = float(getattr(sensor, "bus_voltage"))
        except Exception as exc:
            self._sensor = None
            self._last_error = f"Failed to read battery voltage: {exc}"
            return BatteryReading(
                available=False,
                percentage=None,
                voltage=None,
                current_ma=None,
                charging=None,
                capacity_mah=self.capacity_mah,
                error=self._last_error,
            )

        try:
            shunt_voltage = float(getattr(sensor, "shunt_voltage", 0.0))
        except Exception:
            shunt_voltage = 0.0

        voltage = bus_voltage + shunt_voltage
        percentage = round(self._estimate_percentage(voltage), 1)

        current_ma: float | None
        charging: bool | None
        try:
            current_value = getattr(sensor, "current", None)
            if current_value is None:
                current_ma = None
                charging = None
            else:
                current_ma = float(current_value)
                charging = current_ma < 0
        except Exception:
            current_ma = None
            charging = None

        reading = BatteryReading(
            available=True,
            percentage=percentage,
            voltage=round(voltage, 3),
            current_ma=round(current_ma, 2) if current_ma is not None else None,
            charging=charging,
            capacity_mah=self.capacity_mah,
            error=None,
        )
        self._last_error = None
        return reading


def _pairwise(values: Sequence[tuple[float, float]]) -> Iterable[tuple[tuple[float, float], tuple[float, float]]]:
    """Yield successive pairs from *values*."""

    for index in range(1, len(values)):
        yield values[index - 1], values[index]


__all__ = ["BatteryMonitor", "BatteryReading"]
