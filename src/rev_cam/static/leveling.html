<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>RevCam Trailer Leveling</title>
    <link rel="icon" type="image/svg+xml" href="images/favicon.svg" />
    <style>
      :root {
        color-scheme: dark;
        --font-family: "Inter", "Manrope", "Segoe UI", system-ui, -apple-system,
          BlinkMacSystemFont, sans-serif;
        --line-height: 1.65;
        --transition: 200ms ease;
        --surface-0: rgba(14, 16, 22, 0.82);
        --surface-1: rgba(26, 28, 36, 0.78);
        --surface-muted: rgba(255, 255, 255, 0.08);
        --surface-soft: rgba(255, 255, 255, 0.04);
        --surface-panel: rgba(30, 33, 44, 0.82);
        --surface-primary: rgba(38, 42, 55, 0.85);
        --surface-secondary: rgba(24, 27, 38, 0.88);
        --border-subtle: rgba(255, 255, 255, 0.08);
        --border-muted: rgba(255, 255, 255, 0.12);
        --text-primary: #f5f7fb;
        --text-muted: rgba(245, 247, 250, 0.72);
        --text-on-accent: #ffffff;
        --accent: #0a84ff;
        --accent-hover: #2f95ff;
        --accent-active: #55adff;
        --accent-soft: rgba(10, 132, 255, 0.16);
        --accent-soft-hover: rgba(10, 132, 255, 0.24);
        --accent-ring: rgba(10, 132, 255, 0.45);
        --success: #4ade80;
        --success-soft: rgba(74, 222, 128, 0.16);
        --warning: #ff9f0a;
        --danger: #ff453a;
        --danger-soft: rgba(255, 69, 58, 0.2);
        --radius-sm: 0.5rem;
        --radius-md: 0.75rem;
        --radius-lg: 1rem;
        --radius-xl: 1.5rem;
        --radius-pill: 999px;
        --shell-padding-y: clamp(2rem, 7vh, 3.5rem);
        --shell-padding-x: clamp(1.25rem, 5vw, 3.5rem);
        --rhythm: 1.5rem;
        --space-xs: 0.25rem;
        --space-sm: 0.5rem;
        --space-md: 0.75rem;
        --space-lg: 1.25rem;
        --space-xl: 1.75rem;
        --space-2xl: 2.5rem;
        --control-padding-y: 0.6rem;
        --control-padding-x: 1.25rem;
        --card-padding: calc(var(--rhythm) + 0.25rem);
        --stack-gap: calc(var(--rhythm) / 2);
        --stack-gap-lg: var(--rhythm);
        --shadow-sm: 0 18px 44px rgba(0, 0, 0, 0.45);
        --shadow-md: 0 26px 60px rgba(0, 0, 0, 0.5);
        --shadow-lg: 0 40px 120px rgba(0, 0, 0, 0.55);
        --page-gradient: radial-gradient(120% 140% at top, #1b1e26 0%, #10131a 60%, #050609 100%);
        --panel-max-width: 1100px;
      }

      * {
        box-sizing: border-box;
      }

      .hidden {
        display: none !important;
      }

      body {
        margin: 0;
        font-family: var(--font-family);
        line-height: var(--line-height);
        background: var(--page-gradient);
        color: var(--text-primary);
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        padding: var(--shell-padding-y) var(--shell-padding-x);
      }

      .shell {
        width: 100%;
        max-width: var(--panel-max-width);
        display: flex;
        flex-direction: column;
        gap: var(--rhythm);
      }

      header,
      footer {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: var(--space-md);
        flex-wrap: wrap;
        background: var(--surface-panel);
        border-radius: var(--radius-lg);
        padding: 1rem calc(var(--space-lg) + 0.25rem);
        box-shadow: var(--shadow-sm);
        border: 1px solid var(--border-muted);
      }

      header {
        backdrop-filter: blur(18px) saturate(125%);
        -webkit-backdrop-filter: blur(18px) saturate(125%);
      }

      footer {
        font-size: 0.95rem;
        justify-content: space-between;
      }

      strong.brand {
        font-size: 1.35rem;
        letter-spacing: 0.04em;
        color: var(--success);
      }

      nav {
        display: inline-flex;
        gap: var(--space-sm);
        flex-wrap: wrap;
      }

      nav a {
        color: var(--text-muted);
        text-decoration: none;
        font-weight: 600;
        padding: 0.45rem 1.15rem;
        border-radius: var(--radius-pill);
        border: 1px solid transparent;
        background: transparent;
        transition: color var(--transition), border-color var(--transition),
          background var(--transition), transform var(--transition);
      }

      nav a:hover,
      nav a:focus-visible {
        color: var(--accent-active);
        border-color: var(--accent-active);
        background: var(--accent-soft-hover);
        outline: none;
        transform: translateY(-1px);
      }

      nav a[aria-current="page"] {
        color: var(--text-primary);
        border-color: var(--accent-active);
        background: var(--accent-soft);
        box-shadow: 0 16px 40px rgba(10, 132, 255, 0.25);
      }

      main {
        display: grid;
        gap: var(--stack-gap-lg);
      }

      .card {
        background: var(--surface-panel);
        border-radius: var(--radius-xl);
        border: 1px solid var(--border-muted);
        box-shadow: var(--shadow-md);
        padding: var(--card-padding);
        display: flex;
        flex-direction: column;
        gap: var(--stack-gap);
      }

      .card h2,
      .card h3 {
        margin: 0;
        font-weight: 600;
      }

      .card p {
        margin: 0;
        color: var(--text-muted);
      }

      .analysis-card {
        gap: var(--stack-gap-lg);
      }

      .analysis-header {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
        gap: var(--space-lg);
      }

      .analysis-header h2 {
        margin-bottom: var(--space-xs);
      }

      .analysis-header p {
        margin: 0;
        color: var(--text-muted);
      }

      .analysis-layout {
        display: grid;
        gap: var(--stack-gap-lg);
      }

      @media (min-width: 900px) {
        .analysis-layout {
          grid-template-columns: minmax(0, 1fr) minmax(260px, 360px);
          align-items: start;
        }
      }

      .analysis-details {
        display: grid;
        gap: var(--stack-gap-lg);
      }

      .visualiser-panel {
        display: flex;
        flex-direction: column;
        gap: var(--space-md);
      }

      .visualiser-panel p {
        color: var(--text-muted);
      }

      .mode-toggle {
        display: inline-flex;
        gap: var(--space-md);
        align-items: center;
        flex-wrap: wrap;
      }

      .mode-toggle label {
        font-weight: 500;
        cursor: pointer;
      }

      .mode-toggle input {
        margin-right: var(--space-xs);
      }

      .orientation-readout {
        display: flex;
        gap: var(--space-xl);
        flex-wrap: wrap;
      }

      .orientation-readout div {
        min-width: 120px;
      }

      .orientation-readout strong {
        display: block;
        font-size: 2rem;
      }

      .analysis-section {
        display: grid;
        gap: var(--space-md);
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      }

      .analysis-section section {
        background: var(--surface-secondary);
        border-radius: var(--radius-lg);
        border: 1px solid var(--border-subtle);
        padding: var(--space-lg);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04);
      }

      .analysis-section h3 {
        margin-top: 0;
        margin-bottom: var(--space-sm);
      }

      dl.stats {
        margin: 0;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: var(--space-sm) var(--space-lg);
      }

      dl.stats dt {
        font-weight: 600;
        color: var(--text-muted);
      }

      dl.stats dd {
        margin: 0;
        font-size: 1.05rem;
      }

      #viewer {
        position: relative;
        width: 100%;
        aspect-ratio: 4 / 3;
        min-height: clamp(260px, 32vh, 480px);
        background: radial-gradient(circle at top, rgba(70, 80, 110, 0.32), rgba(9, 11, 18, 0.9));
        border-radius: var(--radius-xl);
        border: 1px solid var(--border-muted);
        overflow: hidden;
        box-shadow: var(--shadow-lg);
      }

      #viewer canvas {
        position: absolute;
        inset: 0;
      }

      .status {
        position: relative;
        font-size: 0.9rem;
        color: var(--text-muted);
        padding-right: 1.5rem;
        min-height: calc(2 * 1em);
        display: block;
      }

      .status.error {
        color: var(--danger);
      }

      .status.success {
        color: var(--success);
      }

      .status.live {
        color: var(--info, #38bdf8);
      }

      .status.loading::after {
        content: "";
        position: absolute;
        top: 50%;
        right: 0.1rem;
        width: 0.75rem;
        height: 0.75rem;
        border-radius: 50%;
        border: 2px solid rgba(255, 255, 255, 0.28);
        border-top-color: var(--accent);
        transform: translateY(-50%);
        animation: spin 900ms linear infinite;
      }

      @keyframes spin {
        from {
          transform: translateY(-50%) rotate(0deg);
        }

        to {
          transform: translateY(-50%) rotate(360deg);
        }
      }

      @media (max-width: 720px) {
        body {
          padding: var(--space-xl);
        }
        header,
        footer {
          padding-inline: var(--space-lg);
        }
      }
    </style>
  </head>
  <body>
    <div class="shell">
      <header>
        <strong class="brand">RevCam</strong>
        <nav>
          <a href="/">Live View</a>
          <a href="/settings">Settings</a>
          <a href="/leveling" aria-current="page">Trailer Leveling</a>
        </nav>
      </header>
      <main>
        <article class="card analysis-card">
          <div class="analysis-header">
            <div>
              <h2>Leveling Analysis</h2>
              <p>Monitor real-time leveling guidance from the GY-85 sensor.</p>
            </div>
            <div class="mode-toggle" role="radiogroup" aria-label="Operating mode">
              <label><input type="radio" name="mode" value="hitched" checked /> Hitched</label>
              <label><input type="radio" name="mode" value="unhitched" /> Unhitched</label>
            </div>
          </div>
          <div class="analysis-layout">
            <div class="analysis-details">
              <div>
                <p class="status" id="sensor-status" aria-live="polite">Detecting GY-85 sensor…</p>
                <p class="status" id="analysis-status">Awaiting sensor data…</p>
              </div>
              <div class="orientation-readout">
                <div>
                  <span>Roll</span>
                  <strong id="roll-display">0°</strong>
                </div>
                <div>
                  <span>Pitch</span>
                  <strong id="pitch-display">0°</strong>
                </div>
              </div>
              <div class="analysis-section">
                <section>
                  <h3>Leveling guidance</h3>
                  <p id="leveling-message">—</p>
                  <dl class="stats">
                    <dt>Side to raise</dt>
                    <dd id="leveling-side">—</dd>
                    <dt>Raise amount</dt>
                    <dd id="leveling-raise">—</dd>
                    <dt>Ramp travel</dt>
                    <dd id="leveling-ramp">—</dd>
                    <dt>Hitch adjustment</dt>
                    <dd id="leveling-hitch">—</dd>
                  </dl>
                </section>
              </div>
            </div>
            <aside class="visualiser-panel">
              <h3>3D Trailer Visualiser</h3>
              <p>Orientation estimates drive this rendering in real time from the onboard sensor.</p>
              <div id="viewer" aria-label="3D rendering of trailer"></div>
            </aside>
          </div>
        </article>
      </main>
    <footer>
      <span>&copy; RevCam – Trailer leveling preview</span>
      <span id="sample-rate" class="status"></span>
    </footer>
  </div>
  <script type="module">
      import * as THREE from "https://unpkg.com/three@0.158.0/build/three.module.js?module";
      import { OrbitControls } from "https://unpkg.com/three@0.158.0/examples/jsm/controls/OrbitControls.js?module";
      import { STLLoader } from "https://unpkg.com/three@0.158.0/examples/jsm/loaders/STLLoader.js?module";

      const SAMPLE_INTERVAL = 300;
      const sampleRateDisplay = document.getElementById("sample-rate");
      const analysisStatus = document.getElementById("analysis-status");
      const sensorStatus = document.getElementById("sensor-status");
      const rollDisplay = document.getElementById("roll-display");
      const pitchDisplay = document.getElementById("pitch-display");
      const levelingMessage = document.getElementById("leveling-message");
      const levelingSide = document.getElementById("leveling-side");
      const levelingRaise = document.getElementById("leveling-raise");
      const levelingRamp = document.getElementById("leveling-ramp");
      const levelingHitch = document.getElementById("leveling-hitch");
      let currentMode = "hitched";
      let lastSampleTime = performance.now();
      let inFlight = false;
      let pendingSample = false;
      let hardwareAvailable = false;
      let latestOrientation = { roll: 0, pitch: 0 };
      let scene, renderer, camera, controls, trailer;

      function buildTrailerPlaceholder() {
        const group = new THREE.Group();

        const bodyMaterial = new THREE.MeshStandardMaterial({
          color: 0xbcc9d6,
          metalness: 0.55,
          roughness: 0.45,
        });

        const body = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.95, 0.86), bodyMaterial);
        body.position.y = 0.475;
        group.add(body);

        const roof = new THREE.Mesh(new THREE.BoxGeometry(1.82, 0.2, 0.88), bodyMaterial.clone());
        roof.position.set(0, 0.95, 0);
        group.add(roof);

        const hitchMaterial = new THREE.MeshStandardMaterial({
          color: 0x9aa7b5,
          metalness: 0.7,
          roughness: 0.3,
        });
        const hitch = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.9, 16), hitchMaterial);
        hitch.rotation.z = Math.PI / 2;
        hitch.position.set(1.1, 0.25, 0);
        group.add(hitch);

        const wheelMaterial = new THREE.MeshStandardMaterial({
          color: 0x14161d,
          metalness: 0.2,
          roughness: 0.8,
        });

        const wheelOffsets = [new THREE.Vector3(-0.75, 0.25, 0.4), new THREE.Vector3(-0.75, 0.25, -0.4)];
        for (const offset of wheelOffsets) {
          const wheel = new THREE.Mesh(new THREE.CylinderGeometry(0.28, 0.28, 0.18, 24), wheelMaterial);
          wheel.rotation.z = Math.PI / 2;
          wheel.position.copy(offset);
          group.add(wheel);
        }

        group.position.y = 0.1;
        return group;
      }

      async function loadTrailerModel() {
        const loader = new STLLoader();
        try {
          const geometry = await loader.loadAsync("/models/CARVAN_KEYRING.stl");
          geometry.computeVertexNormals();
          geometry.center();
          geometry.computeBoundingBox();

          const material = new THREE.MeshStandardMaterial({
            color: 0xbcc9d6,
            metalness: 0.4,
            roughness: 0.35,
          });

          const trailerMesh = new THREE.Mesh(geometry, material);
          trailerMesh.castShadow = true;
          trailerMesh.receiveShadow = true;

          const boundingBox = geometry.boundingBox?.clone();
          if (boundingBox) {
            const size = new THREE.Vector3();
            boundingBox.getSize(size);
            const maxDimension = Math.max(size.x, size.y, size.z) || 1;
            const targetLength = 2.4;
            const scale = targetLength / maxDimension;
            trailerMesh.scale.setScalar(scale);

            const baseOffset = -(boundingBox.min.y * scale);
            trailerMesh.position.y = baseOffset;
          }

          const group = new THREE.Group();
          group.add(trailerMesh);
          return group;
        } catch (error) {
          console.error("Unable to load STL model", error);
          throw error;
        }
      }

      async function refreshSensorStatus() {
        if (!sensorStatus) {
          hardwareAvailable = false;
          return;
        }
        try {
          const response = await fetch("/api/leveling/status");
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          const data = await response.json();
          const available = Boolean(data?.sensor?.available);
          const errorMessage = data?.sensor?.error ?? "";
          hardwareAvailable = available;
          sensorStatus.classList.remove("error", "success", "live");
          if (available) {
            sensorStatus.textContent = "GY-85 hardware sensor connected";
            sensorStatus.classList.add("success");
            sampleRateDisplay.textContent = "Awaiting sensor data…";
          } else {
            const fallbackMessage = errorMessage
              ? `GY-85 sensor unavailable – ${errorMessage}`
              : "GY-85 sensor not detected";
            sensorStatus.textContent = fallbackMessage;
            sensorStatus.classList.add("error");
          }
        } catch (error) {
          console.error(error);
          hardwareAvailable = false;
          sensorStatus.textContent = "Unable to determine sensor status";
          sensorStatus.classList.remove("success", "live");
          sensorStatus.classList.add("error");
        }
        analysisStatus.classList.remove("live", "error", "loading");
        analysisStatus.removeAttribute("aria-busy");
        analysisStatus.textContent = hardwareAvailable
          ? "Awaiting sensor data…"
          : "Waiting for GY-85 sensor connection…";
        if (!hardwareAvailable) {
          sampleRateDisplay.textContent = "Sensor unavailable";
        }
      }

      function formatDistance(value) {
        if (!Number.isFinite(value)) return "—";
        const absValue = Math.abs(value);
        if (absValue >= 1) {
          return `${value.toFixed(2)} m`;
        }
        return `${(value * 100).toFixed(0)} cm`;
      }

      function formatAngle(value) {
        if (!Number.isFinite(value)) return "—";
        const rounded = Math.abs(value) < 0.5 ? 0 : value;
        return `${rounded.toFixed(0)}°`;
      }

      function formatSide(value) {
        if (!value) return "—";
        if (value === "level") return "Level";
        return value.charAt(0).toUpperCase() + value.slice(1);
      }

     function updateDisplays(evaluation, meta) {
        if (!evaluation) {
          return;
        }
        const { orientation, hitched, unhitched } = evaluation;
        latestOrientation = {
          roll: Number(orientation?.roll) || 0,
          pitch: Number(orientation?.pitch) || 0,
        };
        rollDisplay.textContent = formatAngle(latestOrientation.roll);
        pitchDisplay.textContent = formatAngle(latestOrientation.pitch);

        levelingMessage.textContent = unhitched.message || hitched.message;
        levelingSide.textContent = formatSide(hitched.side_to_raise);
        levelingRaise.textContent = formatDistance(hitched.required_raise_m);
        if (hitched.ramp) {
          const travel = hitched.ramp.travel_m ?? 0;
          const percent = hitched.ramp.travel_percent ?? 0;
          const limited = hitched.ramp.limited;
          const travelText = `${formatDistance(travel)} (${percent.toFixed(1)}%)`;
          levelingRamp.textContent = limited
            ? `${travelText} – limited`
            : travelText;
        } else {
          levelingRamp.textContent = "—";
        }

        const hitchDir = unhitched.hitch_direction;
        const hitchAmount = formatDistance(unhitched.hitch_adjustment_m);
        if (hitchDir === "level") {
          levelingHitch.textContent = "Level";
        } else {
          const direction = formatSide(hitchDir);
          levelingHitch.textContent = `${direction} ${hitchAmount}`;
        }

        if (meta) {
          const { modeLabel, analysisMessage } = meta;
          const message = analysisMessage ? `${modeLabel} • ${analysisMessage}` : modeLabel;
          analysisStatus.textContent = message;
          analysisStatus.classList.remove("error");
          analysisStatus.classList.add("live");
        }

        analysisStatus.classList.remove("loading");
        analysisStatus.removeAttribute("aria-busy");

        if (trailer) {
          const rollRad = THREE.MathUtils.degToRad(latestOrientation.roll);
          const pitchRad = THREE.MathUtils.degToRad(latestOrientation.pitch);
          trailer.rotation.x = rollRad;
          trailer.rotation.y = 0;
          trailer.rotation.z = pitchRad;
        }
      }

      function requestSample() {
        if (inFlight) {
          pendingSample = true;
          return;
        }
        pendingSample = false;
        if (!hardwareAvailable) {
          analysisStatus.classList.remove("live", "error", "loading");
          analysisStatus.removeAttribute("aria-busy");
          analysisStatus.textContent = "Waiting for GY-85 sensor connection…";
          sampleRateDisplay.textContent = "Sensor unavailable";
          return;
        }
        void fetchHardwareSample();
      }

      async function fetchHardwareSample() {
        inFlight = true;
        analysisStatus.classList.add("loading");
        analysisStatus.setAttribute("aria-busy", "true");
        analysisStatus.classList.remove("error");
        try {
          const response = await fetch(`/api/leveling/live?mode=${encodeURIComponent(currentMode)}`);
          if (response.status === 503) {
            hardwareAvailable = false;
            pendingSample = true;
            await refreshSensorStatus();
            throw new Error("GY-85 sensor unavailable");
          }
          if (!response.ok) {
            let detail = `HTTP ${response.status}`;
            try {
              const errorPayload = await response.clone().json();
              const extractedDetail =
                errorPayload?.detail || errorPayload?.message || errorPayload?.error;
              if (typeof extractedDetail === "string" && extractedDetail.trim()) {
                detail = extractedDetail.trim();
              }
            } catch (jsonError) {
              try {
                const text = (await response.text()).trim();
                if (text) {
                  detail = text;
                }
              } catch (textError) {
                console.error("Failed to parse leveling error response", textError);
              }
            }
            throw new Error(detail);
          }
          const data = await response.json();
          const modeLabel = data.mode === "hitched" ? "Hitched mode" : "Unhitched mode";
          const analysisMessage = data.analysis?.message ?? "";
          updateDisplays(
            {
              orientation: data.orientation,
              hitched: data.hitched,
              unhitched: data.unhitched,
            },
            { modeLabel, analysisMessage }
          );
          const now = performance.now();
          const intervalMs =
            typeof data.interval_s === "number" && Number.isFinite(data.interval_s)
              ? data.interval_s * 1000
              : now - lastSampleTime;
          lastSampleTime = now;
          const timestamp = new Date();
          sampleRateDisplay.textContent = `Last update ${timestamp.toLocaleTimeString()} • Δ ${Math.round(intervalMs)} ms`;
        } catch (error) {
          console.error("Failed to fetch leveling data", error);
          if (hardwareAvailable) {
            const message =
              error instanceof Error && error.message ? error.message : "Unable to reach leveling API";
            analysisStatus.textContent = message;
            analysisStatus.classList.remove("live");
            analysisStatus.classList.add("error");
            sampleRateDisplay.textContent = "Waiting for leveling API…";
          }
        } finally {
          analysisStatus.classList.remove("loading");
          analysisStatus.removeAttribute("aria-busy");
          inFlight = false;
          if (pendingSample) {
            pendingSample = false;
            requestSample();
          }
        }
      }

      function initModeToggle() {
        for (const radio of document.querySelectorAll('input[name="mode"]')) {
          radio.addEventListener("change", (event) => {
            if (event.target instanceof HTMLInputElement && event.target.checked) {
              currentMode = event.target.value;
              requestSample();
            }
          });
        }
      }

      async function initThree() {
        const container = document.getElementById("viewer");
        const width = container.clientWidth;
        const height = container.clientHeight;
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0b0d13);

        camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 100);
        camera.position.set(2.8, 1.8, 2.8);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(width, height);
        container.appendChild(renderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.08;
        controls.target.set(0, 0.4, 0);

        const ambient = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambient);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        const planeGeometry = new THREE.PlaneGeometry(6, 6);
        const planeMaterial = new THREE.MeshStandardMaterial({
          color: 0x1a1d24,
          roughness: 0.9,
          metalness: 0.1,
        });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2;
        scene.add(plane);

        trailer = buildTrailerPlaceholder();
        scene.add(trailer);
        analysisStatus.classList.remove("error");
        analysisStatus.textContent = "Loading detailed trailer model…";

        try {
          const detailedModel = await loadTrailerModel();
          scene.remove(trailer);
          trailer = detailedModel;
          scene.add(trailer);
          analysisStatus.textContent = "Trailer model ready";
        } catch (error) {
          analysisStatus.classList.add("error");
          analysisStatus.textContent = "Failed to load trailer model";
        }

        window.addEventListener("resize", () => {
          const w = container.clientWidth;
          const h = container.clientHeight;
          camera.aspect = w / h;
          camera.updateProjectionMatrix();
          renderer.setSize(w, h);
        });

        function animate() {
          requestAnimationFrame(animate);
          controls.update();
          renderer.render(scene, camera);
        }
        animate();
      }

      async function initialise() {
        initModeToggle();
        await initThree();
        await refreshSensorStatus();
        setInterval(requestSample, SAMPLE_INTERVAL);
        setInterval(refreshSensorStatus, 10000);
        requestSample();
      }

      void initialise();
    </script>
  </body>
</html>
