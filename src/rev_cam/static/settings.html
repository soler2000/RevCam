<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>RevCam Settings</title>
    <style>
      body {
        margin: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background-color: #111;
        color: #f5f5f5;
        padding: 2rem 1.5rem 3rem;
      }
      h1 {
        margin: 0;
        font-size: 2rem;
      }
      h2 {
        margin: 0 0 0.75rem;
        font-size: 1.35rem;
      }
      h3 {
        margin: 1rem 0 0.5rem;
        font-size: 1.1rem;
      }
      p {
        margin: 0 0 1rem;
      }
      a {
        color: #0a84ff;
      }
      label {
        display: block;
        margin-bottom: 1rem;
      }
      select,
      input[type="text"],
      input[type="password"],
      input[type="number"] {
        margin-top: 0.5rem;
        font-size: 1rem;
        padding: 0.55rem 0.65rem;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(0, 0, 0, 0.35);
        color: inherit;
        width: 100%;
        box-sizing: border-box;
      }
      input[type="checkbox"] {
        margin-top: 0.5rem;
        transform: scale(1.2);
      }
      button {
        background: #0a84ff;
        color: #fff;
        border: none;
        padding: 0.6rem 1.2rem;
        border-radius: 999px;
        font-size: 1rem;
        cursor: pointer;
        font-weight: 600;
      }
      .button-link,
      button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.35rem;
        text-decoration: none;
      }
      .button-link {
        background: #0a84ff;
        color: #fff;
        border-radius: 999px;
        padding: 0.6rem 1.2rem;
        font-size: 1rem;
        font-weight: 600;
      }
      .button-link.disabled {
        opacity: 0.5;
        pointer-events: none;
      }
      button.secondary-button {
        background: transparent;
        border: 1px solid #0a84ff;
        color: #0a84ff;
      }
      button.secondary-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      button:disabled {
        cursor: not-allowed;
      }
      .muted {
        opacity: 0.75;
      }
      .page-content {
        max-width: 960px;
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }
      .page-header {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      .back-link {
        width: fit-content;
        font-weight: 600;
        text-decoration: none;
      }
      .back-link:hover,
      .back-link:focus-visible {
        text-decoration: underline;
      }
      .tab-container {
        display: flex;
        flex-direction: column;
        gap: 1.25rem;
      }
      .tab-list {
        display: inline-flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        padding: 0.35rem;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.06);
      }
      .tab-button {
        border: none;
        background: transparent;
        color: rgba(245, 245, 245, 0.7);
        border-radius: 999px;
        padding: 0.45rem 1rem;
        font-size: 0.95rem;
        font-weight: 600;
        transition: background 0.2s ease, color 0.2s ease;
      }
      .tab-button[aria-selected="true"] {
        background: #0a84ff;
        color: #fff;
        box-shadow: 0 0 0 1px rgba(10, 132, 255, 0.3);
      }
      .tab-button:hover,
      .tab-button:focus-visible {
        color: #fff;
      }
      .tab-button:focus-visible {
        outline: 2px solid rgba(255, 255, 255, 0.7);
        outline-offset: 2px;
      }
      .tab-panel {
        display: none;
        flex-direction: column;
        gap: 1.5rem;
      }
      .tab-panel:not([hidden]) {
        display: flex;
      }
      .card {
        padding: 1.5rem;
        border-radius: 16px;
        background: rgba(255, 255, 255, 0.04);
      }
      #stream-section h2 {
        margin-top: 0;
      }
      #stream-summary {
        margin: 0;
        opacity: 0.85;
      }
      #stream-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-top: 0.75rem;
      }
      #stream-url {
        display: block;
        margin-top: 0.75rem;
        padding: 0.6rem 0.75rem;
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.35);
        font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        word-break: break-all;
      }
      .stream-settings {
        margin-top: 1.25rem;
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      .stream-settings-grid {
        display: grid;
        gap: 1rem;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      }
      .stream-settings label {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        margin-bottom: 0;
        font-size: 0.95rem;
      }
      .stream-settings input[type="range"] {
        width: 100%;
      }
      .stream-quality-control {
        display: flex;
        align-items: center;
        gap: 0.75rem;
      }
      .stream-quality-display {
        min-width: 2.5rem;
        text-align: right;
        font-weight: 600;
        font-variant-numeric: tabular-nums;
      }
      #orientation-form {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      #orientation-form h2,
      #orientation-form h3 {
        margin-top: 0;
      }
      .form-actions {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        flex-wrap: wrap;
      }
      #reversing-aids-form {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      #reversing-aids-status {
        min-height: 1.2rem;
      }
      .reversing-grid {
        display: grid;
        gap: 1rem;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      }
      fieldset.reversing-side {
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 12px;
        padding: 1rem;
        background: rgba(255, 255, 255, 0.03);
      }
      fieldset.reversing-side legend {
        padding: 0 0.35rem;
        font-weight: 600;
      }
      fieldset.reversing-side p {
        margin: 0.25rem 0 0.85rem;
        font-size: 0.9rem;
        opacity: 0.8;
      }
      fieldset.reversing-side:disabled {
        opacity: 0.6;
      }
      .reversing-point-button {
        margin-left: auto;
        border: 1px solid rgba(10, 132, 255, 0.35);
        border-radius: 999px;
        background: rgba(10, 132, 255, 0.08);
        color: #0a84ff;
        font-size: 0.8rem;
        font-weight: 600;
        padding: 0.2rem 0.9rem;
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        cursor: pointer;
        transition: background 0.15s ease, color 0.15s ease, border-color 0.15s ease;
      }
      .reversing-point-button:hover,
      .reversing-point-button:focus {
        background: rgba(10, 132, 255, 0.15);
        color: #0a84ff;
        border-color: rgba(10, 132, 255, 0.5);
      }
      .reversing-point-button[aria-pressed="true"] {
        background: #0a84ff;
        color: #fff;
        border-color: #0a84ff;
      }
      .reversing-point-button:disabled {
        opacity: 0.55;
        cursor: not-allowed;
      }
      .reversing-point-hint {
        margin: -0.25rem 0 0.75rem;
        font-size: 0.85rem;
        opacity: 0.75;
      }
      .reversing-line-point {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        margin-bottom: 1.25rem;
      }
      .reversing-line-point:last-of-type {
        margin-bottom: 0;
      }
      .reversing-line-header {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-weight: 600;
        flex-wrap: wrap;
      }
      .reversing-colour {
        width: 0.9rem;
        height: 0.9rem;
        border-radius: 50%;
        display: inline-block;
      }
      .reversing-line-fields {
        display: grid;
        gap: 0.75rem;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      }
      .reversing-line-fields label {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        font-size: 0.9rem;
        margin: 0;
      }
      .reversing-preview {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        margin: 0.5rem 0 1.25rem;
      }
      .reversing-preview h3 {
        margin: 0;
      }
      .reversing-preview-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        align-items: stretch;
      }
      .reversing-preview-controls button {
        min-height: 2.5rem;
        white-space: nowrap;
      }
      .reversing-preview-file-input {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        clip-path: inset(50%);
        border: 0;
      }
      .reversing-preview-status {
        min-height: 1.2rem;
        display: block;
      }
      .reversing-preview-stage {
        position: relative;
        width: 100%;
        border-radius: 12px;
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(255, 255, 255, 0.05);
        aspect-ratio: 16 / 9;
      }
      .reversing-preview-stage img,
      .reversing-preview-stage canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        object-fit: contain;
        display: block;
      }
      .reversing-preview-stage canvas {
        pointer-events: none;
      }
      .reversing-preview-stage.is-picking,
      .reversing-preview-stage.is-picking img,
      .reversing-preview-stage.is-picking .reversing-preview-placeholder {
        cursor: crosshair;
      }
      .reversing-preview-placeholder {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        padding: 1rem;
        color: rgba(255, 255, 255, 0.65);
        font-size: 0.95rem;
        letter-spacing: 0.01em;
      }
      #status {
        font-size: 0.95rem;
        opacity: 0.85;
      }
      #wifi-section h2,
      #wifi-section h3 {
        margin-top: 0;
      }
      #wifi-summary {
        margin: 0 0 0.75rem;
        opacity: 0.85;
      }
      #wifi-controls {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 0.75rem;
        margin-bottom: 0.75rem;
      }
      #wifi-controls label {
        margin: 0;
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.95rem;
      }
      #wifi-feedback {
        min-height: 1.2rem;
        font-size: 0.9rem;
        opacity: 0.85;
      }
      #wifi-feedback.error {
        color: #ff6b6b;
        opacity: 1;
      }
      #wifi-network-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      .wifi-network {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
        padding: 0.85rem 1rem;
        border-radius: 12px;
        background: rgba(0, 0, 0, 0.35);
      }
      .wifi-network strong {
        display: block;
        font-size: 1rem;
      }
      .wifi-network span {
        font-size: 0.9rem;
        opacity: 0.8;
      }
      .wifi-network .actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }
      #wifi-connect-form {
        margin-top: 1rem;
        padding: 1rem;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.05);
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }
      #wifi-connect-form[hidden] {
        display: none;
      }
      #wifi-hotspot-section {
        margin-top: 1.5rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }
      #wifi-hotspot-section .button-group {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }
      .battery-card {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 1.5rem;
      }
      #battery-indicator {
        display: inline-flex;
        align-items: center;
        gap: 1rem;
        padding: 0.5rem 0.75rem;
        border-radius: 12px;
        background: rgba(0, 0, 0, 0.35);
        min-width: 200px;
      }
      .battery-icon {
        position: relative;
        display: inline-flex;
        align-items: center;
        justify-content: flex-start;
        width: 52px;
        height: 24px;
        padding: 2px;
        border-radius: 6px;
        border: 2px solid currentColor;
        color: #0a84ff;
      }
      .battery-icon::after {
        content: "";
        position: absolute;
        right: -6px;
        top: 50%;
        transform: translateY(-50%);
        width: 4px;
        height: 12px;
        border-radius: 4px;
        background: currentColor;
      }
      .battery-level {
        display: block;
        height: 100%;
        border-radius: 4px;
        background: currentColor;
        width: 0%;
        transition: width 0.3s ease;
      }
      .battery-icon.low {
        color: #ff9f0a;
      }
      .battery-icon.charging {
        color: #30d158;
      }
      .battery-icon.unavailable {
        color: rgba(245, 245, 245, 0.4);
      }
      #battery-status {
        display: flex;
        flex-direction: column;
        gap: 0.2rem;
      }
      #battery-text {
        font-size: 1.2rem;
        font-weight: 600;
      }
      #battery-details {
        font-size: 0.95rem;
        opacity: 0.8;
      }
      .battery-metrics {
        display: grid;
        gap: 1rem;
        flex: 1 1 260px;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      }
      .battery-metrics div {
        background: rgba(255, 255, 255, 0.03);
        padding: 0.75rem;
        border-radius: 12px;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }
      .battery-metrics dt {
        font-size: 0.85rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        opacity: 0.7;
      }
      .battery-metrics dd {
        margin: 0;
        font-size: 1rem;
        font-weight: 600;
      }
      .battery-actions {
        display: flex;
        gap: 0.5rem;
        margin-top: 1.25rem;
      }
      .battery-note {
        font-size: 0.9rem;
        opacity: 0.75;
        margin-top: 0.75rem;
      }
      .distance-readout {
        display: flex;
        flex-wrap: wrap;
        align-items: baseline;
        gap: 0.75rem;
        margin: 0.5rem 0 0;
      }
      .distance-value {
        font-size: 2.4rem;
        font-weight: 700;
        letter-spacing: -0.02em;
      }
      .distance-zone {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border-radius: 999px;
        padding: 0.25rem 0.85rem;
        font-size: 0.75rem;
        font-weight: 700;
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }
      .zone-badge.clear {
        color: #30d158;
        background: rgba(48, 209, 88, 0.18);
      }
      .zone-badge.caution {
        color: #ffd60a;
        background: rgba(255, 214, 10, 0.18);
      }
      .zone-badge.warning {
        color: #ff9f0a;
        background: rgba(255, 159, 10, 0.18);
      }
      .zone-badge.danger {
        color: #ff453a;
        background: rgba(255, 69, 58, 0.2);
      }
      .zone-badge.unavailable {
        color: rgba(245, 245, 245, 0.7);
        background: rgba(245, 245, 245, 0.12);
      }
      .distance-actions {
        margin-top: 1rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }
      .distance-error {
        margin: 0.75rem 0 0;
        min-height: 1rem;
      }
      .distance-calibration-grid {
        margin-top: 1rem;
        display: grid;
        gap: 1rem;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      }
      .distance-calibration-grid label {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        margin-bottom: 0;
      }
      .distance-calibration-note {
        font-size: 0.9rem;
        margin-top: 0.75rem;
      }
      #distance-calibration-status {
        font-size: 0.9rem;
      }
      .diagnostics-actions {
        margin: 0.75rem 0 1rem;
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 0.75rem;
      }
      .diagnostics-status {
        font-size: 0.9rem;
        opacity: 0.85;
      }
      .diagnostics-error {
        margin: 0.75rem 0 0;
        font-size: 0.95rem;
        color: #ff6b6b;
      }
      .diagnostics-results h3 {
        margin: 1rem 0 0.5rem;
        font-size: 1rem;
      }
      .diagnostics-results h4 {
        margin: 0.75rem 0 0.35rem;
        font-size: 0.95rem;
      }
      .diagnostics-list {
        margin: 0.35rem 0 0.75rem 1.25rem;
        padding: 0;
      }
      .diagnostics-list li {
        margin: 0.3rem 0;
      }
      .diagnostics-empty {
        margin: 0.35rem 0 0.75rem;
        font-size: 0.95rem;
        opacity: 0.8;
      }
      .diagnostics-picamera-status.ok {
        color: #30d158;
      }
      .diagnostics-picamera-status.error {
        color: #ff9f0a;
      }
      #distance-zones-status {
        font-size: 0.9rem;
      }
      #battery-limits-status {
        font-size: 0.9rem;
      }
      @media (max-width: 640px) {
        body {
          padding: 1.5rem 1rem 2.5rem;
        }
        .card {
          padding: 1.25rem;
        }
        #battery-indicator {
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <div class="page-content">
      <header class="page-header">
        <a class="back-link" href="/">← Back to live view</a>
        <h1>Settings</h1>
        <p id="app-version" class="muted">
          Version <span id="version-value">Loading…</span>
        </p>
      </header>

      <div class="tab-container">
        <div class="tab-list" role="tablist" aria-label="Settings sections">
          <button
            type="button"
            class="tab-button"
            role="tab"
            id="tab-camera"
            aria-controls="panel-camera"
            aria-selected="true"
            data-tab="camera"
            tabindex="0"
          >
            Camera
          </button>
          <button
            type="button"
            class="tab-button"
            role="tab"
            id="tab-distance"
            aria-controls="panel-distance"
            aria-selected="false"
            data-tab="distance"
            tabindex="-1"
          >
            Distance
          </button>
          <button
            type="button"
            class="tab-button"
            role="tab"
            id="tab-reversing"
            aria-controls="panel-reversing"
            aria-selected="false"
            data-tab="reversing"
            tabindex="-1"
          >
            Reversing aids
          </button>
          <button
            type="button"
            class="tab-button"
            role="tab"
            id="tab-network"
            aria-controls="panel-network"
            aria-selected="false"
            data-tab="network"
            tabindex="-1"
          >
            Network
          </button>
          <button
            type="button"
            class="tab-button"
            role="tab"
            id="tab-battery"
            aria-controls="panel-battery"
            aria-selected="false"
            data-tab="battery"
            tabindex="-1"
          >
            Battery
          </button>
        </div>

        <section
          id="panel-camera"
          class="tab-panel"
          role="tabpanel"
          aria-labelledby="tab-camera"
          data-tab="camera"
        >
          <section id="stream-section" class="card">
            <h2>Streaming</h2>
            <p id="stream-summary">Loading…</p>
            <div id="stream-actions">
              <a
                id="open-stream"
                class="button-link disabled"
                href="/stream/mjpeg"
                target="_blank"
                rel="noopener"
                aria-disabled="true"
                >Open MJPEG stream</a
              >
              <button type="button" id="copy-stream-url" class="secondary-button" disabled>
                Copy stream URL
              </button>
            </div>
            <code id="stream-url">—</code>
            <form id="stream-settings-form" class="stream-settings">
              <div class="stream-settings-grid">
                <label>
                  Frames per second
                  <input
                    type="number"
                    name="fps"
                    id="stream-fps"
                    min="1"
                    max="60"
                    step="1"
                    inputmode="numeric"
                    value="20"
                  />
                </label>
                <label>
                  JPEG quality
                  <div class="stream-quality-control">
                    <input
                      type="range"
                      name="jpeg_quality"
                      id="stream-quality"
                      min="1"
                      max="100"
                      step="1"
                      value="85"
                    />
                    <span class="stream-quality-display" id="stream-quality-display">85</span>
                  </div>
                </label>
              </div>
              <div class="form-actions">
                <button type="submit">Save streaming settings</button>
                <span id="stream-settings-status" class="muted"></span>
              </div>
            </form>
          </section>

          <form id="orientation-form" class="card">
            <h2>Camera configuration</h2>
            <label>
              Camera source
              <select name="camera"></select>
            </label>
            <label>
              Resolution
              <select name="resolution"></select>
            </label>
            <h3>Orientation</h3>
            <label>
              Rotation
              <select name="rotation">
                <option value="0">0°</option>
                <option value="90">90°</option>
                <option value="180">180°</option>
                <option value="270">270°</option>
              </select>
            </label>
            <label>
              <input type="checkbox" name="flip_horizontal" /> Flip horizontally
            </label>
            <label>
              <input type="checkbox" name="flip_vertical" /> Flip vertically
            </label>
            <div class="form-actions">
              <button type="submit">Save settings</button>
              <div id="status">Loading…</div>
            </div>
          </form>

          <section id="diagnostics-card" class="card">
            <h2>Diagnostics</h2>
            <p class="muted">
              Check for conflicting camera services and validate the Picamera2 Python stack.
            </p>
            <div class="diagnostics-actions">
              <button type="button" id="diagnostics-refresh" class="secondary-button">
                Run diagnostics
              </button>
              <span
                id="diagnostics-status"
                class="diagnostics-status"
                role="status"
                aria-live="polite"
              ></span>
            </div>
            <div id="diagnostics-results" class="diagnostics-results" hidden>
              <p id="diagnostics-summary" class="muted"></p>
              <div>
                <h3>Camera conflicts</h3>
                <p id="diagnostics-no-conflicts" class="diagnostics-empty">
                  No conflicting services detected.
                </p>
                <ul id="diagnostics-conflicts" class="diagnostics-list" hidden></ul>
              </div>
              <div>
                <h3>Picamera2 stack</h3>
                <p id="diagnostics-picamera-status" class="diagnostics-picamera-status"></p>
                <ul id="diagnostics-picamera-details" class="diagnostics-list" hidden></ul>
                <div id="diagnostics-picamera-hints-block" hidden>
                  <h4>Hints</h4>
                  <ul id="diagnostics-picamera-hints" class="diagnostics-list"></ul>
                </div>
              </div>
            </div>
            <p
              id="diagnostics-error"
              class="diagnostics-error"
              role="alert"
              aria-live="assertive"
            ></p>
          </section>
        </section>

        <section
          id="panel-distance"
          class="tab-panel"
          role="tabpanel"
          aria-labelledby="tab-distance"
          data-tab="distance"
          hidden
        >
          <section class="card">
            <h2>Distance sensor</h2>
            <p id="distance-summary" class="muted">Distance readings are unavailable.</p>
            <div class="distance-readout" id="distance-readout">
              <span class="distance-value" id="distance-value">—</span>
              <span class="distance-zone zone-badge unavailable" id="distance-zone">N/A</span>
            </div>
            <p id="distance-error" class="distance-error muted"></p>
            <div class="distance-actions">
              <button type="button" id="distance-refresh" class="secondary-button">
                Refresh reading
              </button>
            </div>
          </section>

          <form id="distance-calibration-form" class="card">
            <h2>Calibration</h2>
            <p class="muted">
              Adjust the offset and scale applied to the sensor to match real-world distances.
            </p>
            <div class="distance-calibration-grid">
              <label>
                Offset adjustment (m)
                <input
                  type="number"
                  name="offset_m"
                  min="-5"
                  max="5"
                  step="0.01"
                  inputmode="decimal"
                />
              </label>
              <label>
                Scale factor
                <input
                  type="number"
                  name="scale"
                  min="0.5"
                  max="2"
                  step="0.01"
                  inputmode="decimal"
                />
              </label>
            </div>
            <div class="form-actions">
              <button type="submit">Save calibration</button>
              <button type="button" id="distance-zero" class="secondary-button">Zero sensor</button>
              <span id="distance-calibration-status" class="muted"></span>
            </div>
            <p class="distance-calibration-note muted">
              Place the target at the zero point, refresh the reading, then choose “Zero sensor” to
              automatically adjust the offset.
            </p>
          </form>

          <form id="distance-zones-form" class="card">
            <h2>Warning zones</h2>
            <p class="muted">
              Set the thresholds for each warning zone. Distances are measured in metres.
            </p>
            <label>
              Caution threshold (m)
              <input
                type="number"
                name="caution"
                min="0.1"
                max="10"
                step="0.1"
                inputmode="decimal"
              />
            </label>
            <label>
              Warning threshold (m)
              <input
                type="number"
                name="warning"
                min="0.1"
                max="10"
                step="0.1"
                inputmode="decimal"
              />
            </label>
            <label>
              Danger threshold (m)
              <input
                type="number"
                name="danger"
                min="0.1"
                max="10"
                step="0.1"
                inputmode="decimal"
              />
            </label>
            <div class="form-actions">
              <button type="submit">Save warning zones</button>
              <span id="distance-zones-status" class="muted"></span>
            </div>
          </form>
        </section>

        <section
          id="panel-reversing"
          class="tab-panel"
          role="tabpanel"
          aria-labelledby="tab-reversing"
          data-tab="reversing"
          hidden
        >
          <form id="reversing-aids-form" class="card">
            <h2>Reversing aids</h2>
            <p class="muted">
              Configure the on-screen guides to match your vehicle width and camera position.
            </p>
            <label style="display: inline-flex; align-items: center; gap: 0.5rem;">
              <input type="checkbox" id="reversing-aids-enabled" />
              Show reversing aids on the live view
            </label>
            <p class="muted" style="margin: 0;">
              Coordinates are expressed as percentages of the frame. Click the preview or edit the
              values below to fine-tune each side.
            </p>
            <div class="reversing-preview">
              <h3>Alignment preview</h3>
              <p class="muted" style="margin: 0;">
                Capture the current camera view or upload a reference image to preview how the guides
                will line up as you make adjustments.
              </p>
              <div class="reversing-preview-controls">
                <button type="button" id="reversing-preview-capture">Capture snapshot</button>
                <button type="button" id="reversing-preview-upload-button">Upload image</button>
                <input
                  type="file"
                  id="reversing-preview-upload"
                  accept="image/*"
                  class="reversing-preview-file-input"
                />
                <button
                  type="button"
                  id="reversing-preview-clear"
                  class="secondary-button"
                >
                  Clear image
                </button>
              </div>
              <span id="reversing-preview-status" class="muted reversing-preview-status"></span>
              <div class="reversing-preview-stage" id="reversing-preview-stage">
                <img
                  id="reversing-preview-image"
                  alt="Reference image for aligning reversing aids"
                  hidden
                />
                <canvas id="reversing-preview-canvas" aria-hidden="true"></canvas>
                <div class="reversing-preview-placeholder" id="reversing-preview-placeholder">
                  Capture a snapshot or upload an image to preview the reversing aids.
                </div>
            </div>
          </div>
          <p class="muted reversing-point-hint">
            Select a point below, then click the preview to position it. Active points stay
            highlighted so you can fine-tune the guides visually.
          </p>
          <div class="reversing-grid">
            <fieldset class="reversing-side" data-side="left">
                <legend>Left guide</legend>
                <p>Adjust the driver’s-side guide segments. Click the preview or edit the values.</p>
                <div class="reversing-line-point" data-side="left" data-point="near">
                  <div class="reversing-line-header">
                    <span class="reversing-colour" style="background: #ef5350;"></span>
                    <span>Near point</span>
                    <button
                      type="button"
                      class="reversing-point-button"
                      data-side="left"
                      data-reversing-pick="near"
                      aria-pressed="false"
                    >
                      Select on Preview
                    </button>
                  </div>
                  <div class="reversing-line-fields">
                    <label>
                      Horizontal (%)
                      <input
                        type="number"
                        min="0"
                        max="100"
                        step="0.1"
                        inputmode="decimal"
                        data-reversing-field="near-x"
                        data-side="left"
                        data-axis="x"
                      />
                    </label>
                    <label>
                      Vertical (%)
                      <input
                        type="number"
                        min="0"
                        max="100"
                        step="0.1"
                        inputmode="decimal"
                        data-reversing-field="near-y"
                        data-side="left"
                        data-axis="y"
                      />
                    </label>
                  </div>
                </div>
                <div class="reversing-line-point" data-side="left" data-point="far">
                  <div class="reversing-line-header">
                    <span class="reversing-colour" style="background: #66bb6a;"></span>
                    <span>Far point</span>
                    <button
                      type="button"
                      class="reversing-point-button"
                      data-side="left"
                      data-reversing-pick="far"
                      aria-pressed="false"
                    >
                      Select on preview
                    </button>
                  </div>
                  <div class="reversing-line-fields">
                    <label>
                      Horizontal (%)
                      <input
                        type="number"
                        min="0"
                        max="100"
                        step="0.1"
                        inputmode="decimal"
                        data-reversing-field="far-x"
                        data-side="left"
                        data-axis="x"
                      />
                    </label>
                    <label>
                      Vertical (%)
                      <input
                        type="number"
                        min="0"
                        max="100"
                        step="0.1"
                        inputmode="decimal"
                        data-reversing-field="far-y"
                        data-side="left"
                        data-axis="y"
                      />
                    </label>
                  </div>
                </div>
              </fieldset>
              <fieldset class="reversing-side" data-side="right">
                <legend>Right guide</legend>
                <p>Adjust the passenger-side guide segments from the preview or the inputs.</p>
                <div class="reversing-line-point" data-side="right" data-point="near">
                  <div class="reversing-line-header">
                    <span class="reversing-colour" style="background: #ef5350;"></span>
                    <span>Near point</span>
                    <button
                      type="button"
                      class="reversing-point-button"
                      data-side="right"
                      data-reversing-pick="near"
                      aria-pressed="false"
                    >
                      Select on Preview
                    </button>
                  </div>
                  <div class="reversing-line-fields">
                    <label>
                      Horizontal (%)
                      <input
                        type="number"
                        min="0"
                        max="100"
                        step="0.1"
                        inputmode="decimal"
                        data-reversing-field="near-x"
                        data-side="right"
                        data-axis="x"
                      />
                    </label>
                    <label>
                      Vertical (%)
                      <input
                        type="number"
                        min="0"
                        max="100"
                        step="0.1"
                        inputmode="decimal"
                        data-reversing-field="near-y"
                        data-side="right"
                        data-axis="y"
                      />
                    </label>
                  </div>
                </div>
                <div class="reversing-line-point" data-side="right" data-point="far">
                  <div class="reversing-line-header">
                    <span class="reversing-colour" style="background: #66bb6a;"></span>
                    <span>Far point</span>
                    <button
                      type="button"
                      class="reversing-point-button"
                      data-side="right"
                      data-reversing-pick="far"
                      aria-pressed="false"
                    >
                      Select on preview
                    </button>
                  </div>
                  <div class="reversing-line-fields">
                    <label>
                      Horizontal (%)
                      <input
                        type="number"
                        min="0"
                        max="100"
                        step="0.1"
                        inputmode="decimal"
                        data-reversing-field="far-x"
                        data-side="right"
                        data-axis="x"
                      />
                    </label>
                    <label>
                      Vertical (%)
                      <input
                        type="number"
                        min="0"
                        max="100"
                        step="0.1"
                        inputmode="decimal"
                        data-reversing-field="far-y"
                        data-side="right"
                        data-axis="y"
                      />
                    </label>
                  </div>
                </div>
              </fieldset>
            </div>
            <div class="form-actions">
              <button type="submit">Save reversing aids</button>
              <span id="reversing-aids-status" class="muted"></span>
            </div>
          </form>
        </section>

        <section
          id="panel-network"
          class="tab-panel"
          role="tabpanel"
          aria-labelledby="tab-network"
          data-tab="network"
          hidden
        >
          <section id="wifi-section" class="card">
            <h2>Wi-Fi</h2>
            <p id="wifi-summary">Loading…</p>
            <div id="wifi-controls">
              <button type="button" id="wifi-refresh" class="secondary-button">Refresh status</button>
              <button type="button" id="wifi-scan">Scan networks</button>
              <label>
                <input type="checkbox" id="wifi-dev-mode" /> Development mode (auto-rollback)
              </label>
            </div>
            <div id="wifi-feedback" role="status" aria-live="polite"></div>
            <ul id="wifi-network-list"></ul>
            <form id="wifi-connect-form" hidden>
              <h3 style="margin: 0;">Connect to network</h3>
              <p id="wifi-connect-selected" style="margin: 0; opacity: 0.85;"></p>
              <input type="hidden" name="ssid" />
              <label>
                Password
                <input type="password" name="password" autocomplete="current-password" />
              </label>
              <label>
                Rollback timeout (seconds)
                <input type="number" name="rollback" min="5" max="180" step="5" value="30" />
              </label>
              <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                <button type="submit">Connect</button>
                <button type="button" id="wifi-cancel-connect" class="secondary-button">Cancel</button>
              </div>
            </form>
            <section id="wifi-hotspot-section">
              <h3>Hotspot</h3>
              <p class="muted" style="margin: 0 0 0.5rem;">
                Development mode auto-rollback applies when enabling the hotspot.
              </p>
              <p id="wifi-hotspot-status" style="margin: 0; opacity: 0.85;">Hotspot disabled.</p>
              <label>
                Hotspot name
                <input type="text" id="wifi-hotspot-ssid" placeholder="RevCam Hotspot" autocomplete="ssid" />
              </label>
              <label>
                Hotspot password
                <input
                  type="password"
                  id="wifi-hotspot-password"
                  placeholder="Optional (min 8 characters)"
                  autocomplete="new-password"
                />
              </label>
              <div class="button-group">
                <button type="button" id="wifi-enable-hotspot">Enable hotspot</button>
                <button type="button" id="wifi-disable-hotspot" class="secondary-button">Disable hotspot</button>
              </div>
            </section>
          </section>
        </section>

        <section
          id="panel-battery"
          class="tab-panel"
          role="tabpanel"
          aria-labelledby="tab-battery"
          data-tab="battery"
          hidden
        >
          <section class="card">
            <h2>Battery status</h2>
            <p id="battery-summary" class="muted">Battery readings are unavailable until refreshed.</p>
            <div class="battery-card">
              <div id="battery-indicator" aria-live="polite" aria-label="Battery unavailable">
                <span class="battery-icon unavailable" id="battery-icon" aria-hidden="true">
                  <span class="battery-level" id="battery-level"></span>
                </span>
                <div id="battery-status">
                  <span id="battery-text">—%</span>
                  <span id="battery-details">Battery unavailable</span>
                </div>
              </div>
              <dl class="battery-metrics">
                <div>
                  <dt>Status</dt>
                  <dd id="battery-state">Unavailable</dd>
                </div>
                <div>
                  <dt>Voltage</dt>
                  <dd id="battery-voltage">—</dd>
                </div>
                <div>
                  <dt>Current</dt>
                  <dd id="battery-current">—</dd>
                </div>
                <div>
                  <dt>Capacity</dt>
                  <dd id="battery-capacity">—</dd>
                </div>
              </dl>
            </div>
            <div class="battery-actions">
              <button type="button" id="battery-refresh" class="secondary-button">Refresh battery status</button>
            </div>
            <p class="battery-note">
              Battery data is shown when an INA219 sensor is connected.
              The system will shut down automatically when the battery falls below the
              configured shutdown threshold.
            </p>
          </section>
          <form id="battery-limits-form" class="card">
            <h2>Battery settings</h2>
            <p class="muted">
              Configure the warning and shutdown thresholds used for on-screen alerts and automatic
              shutdown, and the capacity of the connected battery pack.
            </p>
            <label>
              Battery capacity (mAh)
              <input
                type="number"
                name="capacity_mah"
                min="50"
                max="200000"
                step="50"
                inputmode="numeric"
              />
            </label>
            <label>
              Warning threshold (%)
              <input
                type="number"
                name="warning_percent"
                min="0"
                max="100"
                step="0.5"
                inputmode="decimal"
              />
            </label>
            <label>
              Shutdown threshold (%)
              <input
                type="number"
                name="shutdown_percent"
                min="0"
                max="100"
                step="0.5"
                inputmode="decimal"
              />
            </label>
            <div class="form-actions">
              <button type="submit">Save battery settings</button>
              <span id="battery-limits-status" class="muted"></span>
            </div>
          </form>
        </section>
      </div>
    </div>
    <script>
      const tabButtons = Array.from(document.querySelectorAll('.tab-button[role="tab"]'));
      const tabPanels = Array.from(document.querySelectorAll('.tab-panel[role="tabpanel"]'));
      const availableTabs = tabButtons
        .map((button) => button.dataset.tab)
        .filter((value) => typeof value === "string" && value.length > 0);
      const DISTANCE_ZONE_LABELS = {
        danger: "Danger",
        warning: "Warning",
        caution: "Caution",
        clear: "Clear",
        unavailable: "Unavailable",
      };
      const CALIBRATION_OFFSET_LIMIT = 5.0;
      const CALIBRATION_SCALE_MIN = 0.5;
      const CALIBRATION_SCALE_MAX = 2.0;
      const distanceSummary = document.getElementById("distance-summary");
      const distanceValue = document.getElementById("distance-value");
      const distanceZone = document.getElementById("distance-zone");
      const distanceError = document.getElementById("distance-error");
      const distanceRefreshButton = document.getElementById("distance-refresh");
      const distanceZonesForm = document.getElementById("distance-zones-form");
      const distanceZonesStatus = document.getElementById("distance-zones-status");
      const distanceInputs = distanceZonesForm
        ? {
            caution: distanceZonesForm.querySelector('input[name="caution"]'),
            warning: distanceZonesForm.querySelector('input[name="warning"]'),
            danger: distanceZonesForm.querySelector('input[name="danger"]'),
          }
        : null;
      const distanceCalibrationForm = document.getElementById("distance-calibration-form");
      const distanceCalibrationStatus = document.getElementById("distance-calibration-status");
      const distanceZeroButton = document.getElementById("distance-zero");
      const distanceCalibrationInputs = distanceCalibrationForm
        ? {
            offset: distanceCalibrationForm.querySelector('input[name="offset_m"]'),
            scale: distanceCalibrationForm.querySelector('input[name="scale"]'),
          }
        : null;
      let distanceLoading = false;
      let distanceCalibrationStatusTimer = null;
      if (distanceInputs) {
        for (const input of Object.values(distanceInputs)) {
          if (input instanceof HTMLInputElement) {
            input.addEventListener("input", () => {
              input.dataset.userEdited = "true";
              if (distanceZonesStatus) {
                distanceZonesStatus.textContent = "";
              }
            });
          }
        }
      }
      if (distanceCalibrationInputs) {
        for (const input of Object.values(distanceCalibrationInputs)) {
          if (input instanceof HTMLInputElement) {
            input.addEventListener("input", () => {
              input.dataset.userEdited = "true";
              if (distanceCalibrationStatus) {
                distanceCalibrationStatus.textContent = "";
              }
            });
          }
        }
      }
      const reversingAidsForm = document.getElementById("reversing-aids-form");
      const reversingAidsStatus = document.getElementById("reversing-aids-status");
      const reversingAidsEnabledInput = document.getElementById("reversing-aids-enabled");
      const reversingSideFieldsets = reversingAidsForm
        ? Array.from(reversingAidsForm.querySelectorAll("fieldset.reversing-side")).filter(
            (element) => element instanceof HTMLFieldSetElement,
          )
        : [];
      const reversingInputs = reversingAidsForm
        ? Array.from(
            reversingAidsForm.querySelectorAll('input[data-reversing-field]'),
          ).filter((element) => element instanceof HTMLInputElement)
        : [];
      const reversingInputMap = new Map();
      if (reversingInputs.length) {
        for (const input of reversingInputs) {
          if (!input.dataset.side || !input.dataset.reversingField) {
            continue;
          }
          const key = `${input.dataset.side}|${input.dataset.reversingField}`;
          reversingInputMap.set(key, input);
          input.addEventListener("input", () => {
            input.dataset.userEdited = "true";
            if (reversingAidsStatus) {
              reversingAidsStatus.textContent = "";
            }
            handleReversingInputEdit(input);
            drawReversingPreviewOverlay();
          });
        }
      }
      const reversingPointButtons = reversingAidsForm
        ? Array.from(
            reversingAidsForm.querySelectorAll('button[data-reversing-pick]'),
          ).filter((element) => element instanceof HTMLButtonElement)
        : [];
      const reversingPreviewStage = document.getElementById("reversing-preview-stage");
      const reversingPreviewImage = document.getElementById("reversing-preview-image");
      const reversingPreviewCanvas = document.getElementById("reversing-preview-canvas");
      const reversingPreviewPlaceholder = document.getElementById("reversing-preview-placeholder");
      const reversingPreviewStatus = document.getElementById("reversing-preview-status");
      const reversingPreviewCaptureButton = document.getElementById("reversing-preview-capture");
      const reversingPreviewUploadButton = document.getElementById(
        "reversing-preview-upload-button",
      );
      const reversingPreviewUploadInput = document.getElementById("reversing-preview-upload");
      const reversingPreviewClearButton = document.getElementById("reversing-preview-clear");
      const reversingPreviewCaptureDefaultText =
        reversingPreviewCaptureButton && typeof reversingPreviewCaptureButton.textContent === "string"
          ? reversingPreviewCaptureButton.textContent
          : "Capture snapshot";
      let reversingPreviewObjectUrl = null;
      let reversingPreviewStatusTimer = null;
      let reversingPreviewLoading = false;
      let reversingPreviewActivePoint = null;
      let reversingPreviewSource = null;
      const REVERSING_SEGMENT_RATIOS = [
        { start: 0.0, end: 0.25 },
        { start: 0.375, end: 0.625 },
        { start: 0.75, end: 1.0 },
      ];
      const REVERSING_SEGMENTS_PER_SIDE = REVERSING_SEGMENT_RATIOS.length;
      const REVERSING_SEGMENT_COLOURS = ["#66bb6a", "#ffc107", "#ef5350"];
      const REVERSING_PREVIEW_DEFAULT_RATIO = "16 / 9";
      const diagnosticsButton = document.getElementById("diagnostics-refresh");
      const diagnosticsStatus = document.getElementById("diagnostics-status");
      const diagnosticsResults = document.getElementById("diagnostics-results");
      const diagnosticsSummary = document.getElementById("diagnostics-summary");
      const diagnosticsConflicts = document.getElementById("diagnostics-conflicts");
      const diagnosticsNoConflicts = document.getElementById("diagnostics-no-conflicts");
      const diagnosticsPicameraStatus = document.getElementById("diagnostics-picamera-status");
      const diagnosticsPicameraDetails = document.getElementById("diagnostics-picamera-details");
      const diagnosticsPicameraHintsBlock = document.getElementById(
        "diagnostics-picamera-hints-block",
      );
      const diagnosticsPicameraHints = document.getElementById("diagnostics-picamera-hints");
      const diagnosticsError = document.getElementById("diagnostics-error");
      let diagnosticsLoading = false;
      let diagnosticsStatusTimer = null;
      const batterySummary = document.getElementById("battery-summary");
      const batteryRefreshButton = document.getElementById("battery-refresh");
      const batteryIndicator = document.getElementById("battery-indicator");
      const batteryIcon = document.getElementById("battery-icon");
      const batteryLevel = document.getElementById("battery-level");
      const batteryText = document.getElementById("battery-text");
      const batteryDetails = document.getElementById("battery-details");
      const batteryState = document.getElementById("battery-state");
      const batteryVoltage = document.getElementById("battery-voltage");
      const batteryCurrent = document.getElementById("battery-current");
      const batteryCapacity = document.getElementById("battery-capacity");
      const batteryLimitsForm = document.getElementById("battery-limits-form");
      const batteryLimitsStatus = document.getElementById("battery-limits-status");
      const batteryLimitsInputs = batteryLimitsForm
        ? {
            capacity: batteryLimitsForm.querySelector('input[name="capacity_mah"]'),
            warning: batteryLimitsForm.querySelector('input[name="warning_percent"]'),
            shutdown: batteryLimitsForm.querySelector('input[name="shutdown_percent"]'),
          }
        : null;
      const batteryLimitsSubmit = batteryLimitsForm
        ? batteryLimitsForm.querySelector('button[type="submit"]')
        : null;
      let batteryLoading = false;
      let batteryLimitsLoaded = false;
      let batteryLimitsLoading = false;
      let batteryLimitsStatusTimer = null;
      if (batteryLimitsInputs) {
        for (const input of Object.values(batteryLimitsInputs)) {
          if (input instanceof HTMLInputElement) {
            input.addEventListener("input", () => {
              input.dataset.userEdited = "true";
              if (batteryLimitsStatus) {
                batteryLimitsStatus.textContent = "";
              }
              if (batteryLimitsStatusTimer) {
                clearTimeout(batteryLimitsStatusTimer);
                batteryLimitsStatusTimer = null;
              }
            });
          }
        }
      }
      const form = document.getElementById("orientation-form");
      const statusLabel = document.getElementById("status");
      const versionValue = document.getElementById("version-value");
      const cameraLabels = new Map();
      const resolutionLabels = new Map();
      const streamSection = document.getElementById("stream-section");
      const streamSummary = document.getElementById("stream-summary");
      const streamUrlElement = document.getElementById("stream-url");
      const openStreamLink = document.getElementById("open-stream");
      const copyStreamButton = document.getElementById("copy-stream-url");
      const copyButtonDefault = copyStreamButton ? copyStreamButton.textContent : "";
      let copyResetTimer = null;
      const streamSettingsForm = document.getElementById("stream-settings-form");
      const streamFpsInput = streamSettingsForm
        ? streamSettingsForm.querySelector('input[name="fps"]')
        : null;
      const streamQualityInput = streamSettingsForm
        ? streamSettingsForm.querySelector('input[name="jpeg_quality"]')
        : null;
      const streamQualityDisplay = document.getElementById("stream-quality-display");
      const streamSettingsStatus = document.getElementById("stream-settings-status");
      let streamSettingsStatusTimer = null;
      const wifiSummary = document.getElementById("wifi-summary");
      const wifiRefreshButton = document.getElementById("wifi-refresh");
      const wifiScanButton = document.getElementById("wifi-scan");
      const wifiFeedback = document.getElementById("wifi-feedback");
      const wifiNetworkList = document.getElementById("wifi-network-list");
      const wifiConnectForm = document.getElementById("wifi-connect-form");
      const wifiConnectSelected = document.getElementById("wifi-connect-selected");
      const wifiDevToggle = document.getElementById("wifi-dev-mode");
      const wifiCancelConnect = document.getElementById("wifi-cancel-connect");
      const wifiHotspotStatus = document.getElementById("wifi-hotspot-status");
      const wifiHotspotSsid = document.getElementById("wifi-hotspot-ssid");
      const wifiHotspotPassword = document.getElementById("wifi-hotspot-password");
      const wifiEnableHotspot = document.getElementById("wifi-enable-hotspot");
      const wifiDisableHotspot = document.getElementById("wifi-disable-hotspot");
      const wifiConnectSsidInput = wifiConnectForm
        ? wifiConnectForm.querySelector('input[name="ssid"]')
        : null;
      const wifiConnectPasswordInput = wifiConnectForm
        ? wifiConnectForm.querySelector('input[name="password"]')
        : null;
      const wifiRollbackInput = wifiConnectForm
        ? wifiConnectForm.querySelector('input[name="rollback"]')
        : null;
      const HOTSPOT_HOSTNAME = "motion.local";
      const HOTSPOT_DEV_ROLLBACK_DEFAULT = 120;

      function clearStreamSettingsStatus() {
        if (streamSettingsStatus) {
          streamSettingsStatus.textContent = "";
        }
        if (streamSettingsStatusTimer) {
          clearTimeout(streamSettingsStatusTimer);
          streamSettingsStatusTimer = null;
        }
      }

      function setStreamQualityDisplay(value) {
        if (!streamQualityDisplay) {
          return;
        }
        if (typeof value === "number" && Number.isFinite(value)) {
          streamQualityDisplay.textContent = String(Math.round(value));
        } else if (
          streamQualityInput &&
          typeof streamQualityInput.value === "string" &&
          streamQualityInput.value
        ) {
          streamQualityDisplay.textContent = streamQualityInput.value;
        } else {
          streamQualityDisplay.textContent = "—";
        }
      }

      function updateStreamInputs(settings, options = {}) {
        if (!streamSettingsForm) {
          return;
        }
        const forceUpdate = options.force === true;
        const fpsValue = settings && typeof settings.fps === "number" ? settings.fps : null;
        const qualityValue =
          settings && typeof settings.jpeg_quality === "number"
            ? settings.jpeg_quality
            : null;
        if (streamFpsInput) {
          if (!forceUpdate && streamFpsInput.dataset.userEdited === "true") {
            // Keep user-entered value.
          } else if (fpsValue !== null && Number.isFinite(fpsValue)) {
            streamFpsInput.value = String(Math.round(fpsValue));
            delete streamFpsInput.dataset.userEdited;
          } else {
            streamFpsInput.value = "";
            delete streamFpsInput.dataset.userEdited;
          }
        }
        if (streamQualityInput) {
          if (!forceUpdate && streamQualityInput.dataset.userEdited === "true") {
            setStreamQualityDisplay(null);
          } else if (qualityValue !== null && Number.isFinite(qualityValue)) {
            const rounded = Math.min(100, Math.max(1, Math.round(qualityValue)));
            streamQualityInput.value = String(rounded);
            delete streamQualityInput.dataset.userEdited;
            setStreamQualityDisplay(rounded);
          } else {
            delete streamQualityInput.dataset.userEdited;
            setStreamQualityDisplay(null);
          }
        }
      }

      setStreamQualityDisplay(null);

      function formatPercentageValue(value) {
        if (typeof value !== "number" || !Number.isFinite(value)) {
          return "";
        }
        const rounded = Math.round(value * 10) / 10;
        let text = rounded.toFixed(1);
        if (text.endsWith(".0")) {
          text = text.slice(0, -2);
        }
        return text;
      }

      function normalisedToPercent(value) {
        if (typeof value !== "number" || !Number.isFinite(value)) {
          return null;
        }
        const clamped = Math.min(1, Math.max(0, value));
        return Math.round(clamped * 1000) / 10;
      }

      function setReversingInputsDisabled(disabled) {
        if (!reversingSideFieldsets.length) {
          return;
        }
        if (disabled) {
          setReversingPreviewActivePoint(null);
        }
        for (const fieldset of reversingSideFieldsets) {
          fieldset.disabled = Boolean(disabled);
        }
      }

      function updateReversingInputValue(input, normalised, options = {}) {
        if (!(input instanceof HTMLInputElement)) {
          return;
        }
        const percent = normalisedToPercent(normalised);
        if (percent === null) {
          input.value = "";
        } else {
          input.value = formatPercentageValue(percent);
        }
        if (options.markEdited === true) {
          input.dataset.userEdited = "true";
        } else if (options.clearEdited !== false) {
          delete input.dataset.userEdited;
        }
      }

      function setReversingPreviewStatus(message, options = {}) {
        if (!reversingPreviewStatus) {
          return;
        }
        if (reversingPreviewStatusTimer) {
          window.clearTimeout(reversingPreviewStatusTimer);
          reversingPreviewStatusTimer = null;
        }
        reversingPreviewStatus.textContent = message || "";
        if (message && options.persistent !== true) {
          reversingPreviewStatusTimer = window.setTimeout(() => {
            if (reversingPreviewStatus && reversingPreviewStatus.textContent === message) {
              reversingPreviewStatus.textContent = "";
            }
            reversingPreviewStatusTimer = null;
          }, 4000);
        }
      }

      function hasReversingPreviewImage() {
        return (
          reversingPreviewImage instanceof HTMLImageElement &&
          !reversingPreviewImage.hidden &&
          reversingPreviewImage.naturalWidth > 0 &&
          reversingPreviewImage.naturalHeight > 0
        );
      }

      function updateReversingPreviewControlsState() {
        if (reversingPreviewClearButton) {
          reversingPreviewClearButton.disabled = !hasReversingPreviewImage();
        }
      }

      function setReversingPreviewPlaceholderVisible(visible) {
        if (reversingPreviewPlaceholder) {
          reversingPreviewPlaceholder.hidden = !visible;
        }
      }

      function setReversingPreviewAspect(width, height) {
        if (!reversingPreviewStage) {
          return;
        }
        if (
          typeof width === "number" &&
          width > 0 &&
          typeof height === "number" &&
          height > 0
        ) {
          reversingPreviewStage.style.aspectRatio = `${width} / ${height}`;
        } else {
          reversingPreviewStage.style.aspectRatio = REVERSING_PREVIEW_DEFAULT_RATIO;
        }
      }

      function revokeReversingPreviewObjectUrl() {
        if (reversingPreviewObjectUrl) {
          URL.revokeObjectURL(reversingPreviewObjectUrl);
          reversingPreviewObjectUrl = null;
        }
      }

      function clearReversingPreviewImage() {
        revokeReversingPreviewObjectUrl();
        if (reversingPreviewImage instanceof HTMLImageElement) {
          reversingPreviewImage.src = "";
          reversingPreviewImage.hidden = true;
        }
        reversingPreviewSource = null;
        setReversingPreviewAspect();
        setReversingPreviewPlaceholderVisible(true);
        updateReversingPreviewControlsState();
        drawReversingPreviewOverlay();
      }

      async function loadReversingPreviewFromBlob(blob) {
        if (!(blob instanceof Blob)) {
          throw new Error("Invalid image data");
        }
        const objectUrl = URL.createObjectURL(blob);
        revokeReversingPreviewObjectUrl();
        reversingPreviewObjectUrl = objectUrl;
        if (reversingPreviewImage instanceof HTMLImageElement) {
          reversingPreviewImage.hidden = true;
          reversingPreviewImage.onload = null;
          reversingPreviewImage.onerror = null;
        }
        const loaded = await new Promise((resolve) => {
          if (!(reversingPreviewImage instanceof HTMLImageElement)) {
            resolve(false);
            return;
          }
          reversingPreviewImage.onload = () => {
            reversingPreviewImage.onload = null;
            reversingPreviewImage.onerror = null;
            reversingPreviewImage.hidden = false;
            setReversingPreviewAspect(
              reversingPreviewImage.naturalWidth,
              reversingPreviewImage.naturalHeight,
            );
            setReversingPreviewPlaceholderVisible(false);
            updateReversingPreviewControlsState();
            drawReversingPreviewOverlay();
            resolve(true);
          };
          reversingPreviewImage.onerror = () => {
            reversingPreviewImage.onload = null;
            reversingPreviewImage.onerror = null;
            resolve(false);
          };
          reversingPreviewImage.src = objectUrl;
        });
        if (!loaded) {
          if (reversingPreviewObjectUrl === objectUrl) {
            revokeReversingPreviewObjectUrl();
          } else {
            URL.revokeObjectURL(objectUrl);
          }
          setReversingPreviewAspect();
          setReversingPreviewPlaceholderVisible(true);
          updateReversingPreviewControlsState();
          throw new Error("Unable to load reference image");
        }
        return true;
      }

      async function captureReversingPreviewSnapshot(options = {}) {
        if (reversingPreviewLoading) {
          return false;
        }
        const silent = options.silent === true;
        reversingPreviewLoading = true;
        if (!silent && reversingPreviewCaptureButton instanceof HTMLButtonElement) {
          reversingPreviewCaptureButton.disabled = true;
          reversingPreviewCaptureButton.textContent = "Capturing…";
        }
        setReversingPreviewStatus(silent ? "Refreshing snapshot…" : "Capturing snapshot…", {
          persistent: true,
        });
        try {
          const response = await fetch("/api/camera/snapshot", { cache: "no-store" });
          if (!response.ok) {
            throw new Error(`Snapshot request failed: ${response.status}`);
          }
          const blob = await response.blob();
          await loadReversingPreviewFromBlob(blob);
          reversingPreviewSource = "snapshot";
          setReversingPreviewStatus(silent ? "Snapshot refreshed." : "Snapshot captured.");
          return true;
        } catch (err) {
          console.error("Reversing preview capture error", err);
          setReversingPreviewStatus(
            silent ? "Unable to refresh snapshot." : "Unable to capture snapshot.",
            { persistent: true },
          );
          return false;
        } finally {
          reversingPreviewLoading = false;
          if (!silent && reversingPreviewCaptureButton instanceof HTMLButtonElement) {
            reversingPreviewCaptureButton.disabled = false;
            reversingPreviewCaptureButton.textContent = reversingPreviewCaptureDefaultText;
          }
        }
      }

      function parseReversingPreviewValue(input) {
        if (!(input instanceof HTMLInputElement)) {
          return null;
        }
        const raw = parseFloat(input.value);
        if (!Number.isFinite(raw)) {
          return null;
        }
        const normalised = raw / 100;
        if (Number.isNaN(normalised)) {
          return null;
        }
        return Math.min(1, Math.max(0, normalised));
      }

      function getReversingPreviewSegments() {
        const geometry = {
          left: Array.from({ length: REVERSING_SEGMENTS_PER_SIDE }, () => null),
          right: Array.from({ length: REVERSING_SEGMENTS_PER_SIDE }, () => null),
        };
        for (const side of ["left", "right"]) {
          const line = readReversingLine(side);
          if (!line) {
            continue;
          }
          const segments = buildSegmentsFromLine(line);
          for (let index = 0; index < REVERSING_SEGMENTS_PER_SIDE; index += 1) {
            geometry[side][index] = segments[index] || null;
          }
        }
        return geometry;
      }

      function drawReversingPreviewOverlay() {
        if (!(reversingPreviewStage instanceof HTMLElement)) {
          return;
        }
        if (!(reversingPreviewCanvas instanceof HTMLCanvasElement)) {
          return;
        }
        const width = Math.round(reversingPreviewStage.clientWidth);
        const height = Math.round(reversingPreviewStage.clientHeight);
        if (!(width > 0 && height > 0)) {
          return;
        }
        const context = reversingPreviewCanvas.getContext("2d");
        if (!context) {
          return;
        }
        if (reversingPreviewCanvas.width !== width || reversingPreviewCanvas.height !== height) {
          reversingPreviewCanvas.width = width;
          reversingPreviewCanvas.height = height;
        }
        context.clearRect(0, 0, width, height);
        const geometry = getReversingPreviewSegments();
        const widthScale = Math.max(1, width - 1);
        const heightScale = Math.max(1, height - 1);
        const thickness = Math.max(2, Math.round(Math.min(width, height) * 0.01));
        const enabled = reversingAidsEnabledInput ? reversingAidsEnabledInput.checked : true;
        context.save();
        context.lineCap = "round";
        context.lineJoin = "round";
        context.globalAlpha = enabled ? 1 : 0.5;
        for (const side of ["left", "right"]) {
          const segments = geometry[side];
          for (let index = 0; index < segments.length; index += 1) {
            const segment = segments[index];
            if (!segment) {
              continue;
            }
            const colour =
              REVERSING_SEGMENT_COLOURS[
                Math.min(index, REVERSING_SEGMENT_COLOURS.length - 1)
              ];
            const startX = segment.start.x * widthScale;
            const startY = segment.start.y * heightScale;
            const endX = segment.end.x * widthScale;
            const endY = segment.end.y * heightScale;
            context.strokeStyle = colour;
            context.lineWidth = thickness;
            context.beginPath();
            context.moveTo(startX, startY);
            context.lineTo(endX, endY);
            context.stroke();
            const pointRadius = Math.max(3, Math.round(thickness * 0.6));
            context.fillStyle = colour;
            context.beginPath();
            context.arc(startX, startY, pointRadius, 0, Math.PI * 2);
            context.fill();
            context.beginPath();
            context.arc(endX, endY, pointRadius, 0, Math.PI * 2);
            context.fill();
          }
        }
        if (reversingPreviewActivePoint) {
          const line = readReversingLine(reversingPreviewActivePoint.side);
          const activePoint =
            reversingPreviewActivePoint.point === "near"
              ? line?.near ?? null
              : line?.far ?? null;
          if (activePoint) {
            const highlightX = activePoint.x * widthScale;
            const highlightY = activePoint.y * heightScale;
            const ringRadius = Math.max(thickness * 1.5, 6);
            context.strokeStyle = "rgba(255, 255, 255, 0.85)";
            context.lineWidth = Math.max(2, Math.round(thickness * 0.6));
            context.beginPath();
            context.arc(highlightX, highlightY, ringRadius, 0, Math.PI * 2);
            context.stroke();
          }
        }
        context.restore();
      }

      function updateReversingAidsStatus(config) {
        if (!reversingAidsStatus) {
          return;
        }
        if (!config) {
          reversingAidsStatus.textContent = "Unable to load reversing aids.";
          return;
        }
        reversingAidsStatus.textContent = config.enabled
          ? "Reversing aids are enabled."
          : "Reversing aids are disabled.";
      }

      function updateReversingAidsInputs(config, forceUpdate = false) {
        if (!reversingInputMap.size) {
          return;
        }
        for (const side of ["left", "right"]) {
          const segments = Array.isArray(config?.[side]) ? config[side] : [];
          const line = extractLineFromSegments(segments);
          const mappings = {
            "far-x": line?.far?.x ?? null,
            "far-y": line?.far?.y ?? null,
            "near-x": line?.near?.x ?? null,
            "near-y": line?.near?.y ?? null,
          };
          for (const [field, value] of Object.entries(mappings)) {
            const key = `${side}|${field}`;
            const input = reversingInputMap.get(key);
            if (!(input instanceof HTMLInputElement)) {
              continue;
            }
            if (!forceUpdate && input.dataset.userEdited === "true") {
              continue;
            }
            updateReversingInputValue(input, value);
          }
        }
      }

      function applyReversingAids(config, options = {}) {
        if (!reversingAidsEnabledInput) {
          return;
        }
        const forceUpdate = options.forceUpdate === true || options.updateInputs === true;
        const enabled = config && typeof config.enabled === "boolean" ? config.enabled : false;
        reversingAidsEnabledInput.checked = enabled;
        setReversingInputsDisabled(!enabled);
        updateReversingAidsStatus(config);
        updateReversingAidsInputs(config, forceUpdate);
        drawReversingPreviewOverlay();
      }

      function collectReversingAidsPayload() {
        if (!reversingAidsEnabledInput) {
          throw new Error("Reversing aids form unavailable.");
        }
        const payload = {
          enabled: reversingAidsEnabledInput.checked,
          left: [],
          right: [],
        };
        for (const side of ["left", "right"]) {
          const line = readReversingLine(side);
          if (!line) {
            throw new Error("Reversing aids inputs are missing.");
          }
          const segments = buildSegmentsFromLine(line);
          if (segments.length !== REVERSING_SEGMENTS_PER_SIDE) {
            throw new Error("Reversing aids inputs are incomplete.");
          }
          payload[side] = segments.map((segment) => ({
            start: { x: segment.start.x, y: segment.start.y },
            end: { x: segment.end.x, y: segment.end.y },
          }));
        }
        return payload;
      }

      function clamp01(value) {
        if (typeof value !== "number" || Number.isNaN(value)) {
          return 0;
        }
        if (value <= 0) {
          return 0;
        }
        if (value >= 1) {
          return 1;
        }
        return value;
      }

      function getReversingLineInputs(side) {
        if (!side) {
          return null;
        }
        return {
          farX: reversingInputMap.get(`${side}|far-x`) || null,
          farY: reversingInputMap.get(`${side}|far-y`) || null,
          nearX: reversingInputMap.get(`${side}|near-x`) || null,
          nearY: reversingInputMap.get(`${side}|near-y`) || null,
        };
      }

      function readReversingLine(side) {
        const inputs = getReversingLineInputs(side);
        if (!inputs) {
          return null;
        }
        const farX = parseReversingPreviewValue(inputs.farX);
        const farY = parseReversingPreviewValue(inputs.farY);
        const nearX = parseReversingPreviewValue(inputs.nearX);
        const nearY = parseReversingPreviewValue(inputs.nearY);
        if (
          farX === null ||
          farY === null ||
          nearX === null ||
          nearY === null
        ) {
          return null;
        }
        return {
          near: { x: nearX, y: nearY },
          far: { x: farX, y: farY },
        };
      }

      function writeReversingLine(side, line, options = {}) {
        const inputs = getReversingLineInputs(side);
        if (!inputs) {
          return;
        }
        const entries = [
          { input: inputs.farX, value: line?.far?.x ?? null },
          { input: inputs.farY, value: line?.far?.y ?? null },
          { input: inputs.nearX, value: line?.near?.x ?? null },
          { input: inputs.nearY, value: line?.near?.y ?? null },
        ];
        for (const entry of entries) {
          const element = entry.input;
          if (!(element instanceof HTMLInputElement)) {
            continue;
          }
          if (options.force !== true && element.dataset.userEdited === "true") {
            continue;
          }
          updateReversingInputValue(element, entry.value, {
            clearEdited: options.clearEdited !== false,
            markEdited: options.markEdited === true,
          });
        }
      }

      function extractLineFromSegments(segments) {
        if (!Array.isArray(segments)) {
          return null;
        }
        let near = null;
        let far = null;
        for (const segment of segments) {
          if (!segment || typeof segment !== "object") {
            continue;
          }
          const { start, end } = segment;
          if (
            !near &&
            start &&
            typeof start.x === "number" &&
            typeof start.y === "number"
          ) {
            near = { x: clamp01(start.x), y: clamp01(start.y) };
          }
          if (
            end &&
            typeof end.x === "number" &&
            typeof end.y === "number"
          ) {
            far = { x: clamp01(end.x), y: clamp01(end.y) };
          }
        }
        if (!near || !far) {
          return null;
        }
        return { near, far };
      }

      function buildSegmentsFromLine(line) {
        if (!line || !line.near || !line.far) {
          return [];
        }
        const dx = line.far.x - line.near.x;
        const dy = line.far.y - line.near.y;
        return REVERSING_SEGMENT_RATIOS.map(({ start, end }) => ({
          start: {
            x: clamp01(line.near.x + dx * start),
            y: clamp01(line.near.y + dy * start),
          },
          end: {
            x: clamp01(line.near.x + dx * end),
            y: clamp01(line.near.y + dy * end),
          },
        }));
      }

      function getReversingPointLabel(side, point) {
        const sideLabel = side === "left" ? "left" : "right";
        const pointLabel = point === "near" ? "near" : "far";
        return `${sideLabel} ${pointLabel}`;
      }

      function setReversingPreviewActivePoint(target) {
        if (target && (typeof target.side !== "string" || typeof target.point !== "string")) {
          target = null;
        }
        reversingPreviewActivePoint = target
          ? { side: target.side, point: target.point }
          : null;
        if (reversingPreviewStage instanceof HTMLElement) {
          reversingPreviewStage.classList.toggle(
            "is-picking",
            Boolean(reversingPreviewActivePoint),
          );
        }
        if (reversingPointButtons.length) {
          for (const button of reversingPointButtons) {
            if (!(button instanceof HTMLButtonElement)) {
              continue;
            }
            const side = button.dataset.side;
            const point = button.dataset.reversingPick;
            const isActive =
              !!reversingPreviewActivePoint &&
              reversingPreviewActivePoint.side === side &&
              reversingPreviewActivePoint.point === point;
            button.setAttribute("aria-pressed", isActive ? "true" : "false");
          }
        }
        if (reversingPreviewActivePoint) {
          const description = getReversingPointLabel(
            reversingPreviewActivePoint.side,
            reversingPreviewActivePoint.point,
          );
          setReversingPreviewStatus(`Click the preview to position the ${description} point.`, {
            persistent: true,
          });
        } else {
          setReversingPreviewStatus("");
        }
        drawReversingPreviewOverlay();
      }

      function setReversingPointFromPreview(side, point, x, y) {
        if (!side || !point) {
          return false;
        }
        const inputs = getReversingLineInputs(side);
        if (!inputs) {
          return false;
        }
        const clampedX = clamp01(x);
        const clampedY = clamp01(y);
        let changed = false;
        const targetX = point === "near" ? inputs.nearX : inputs.farX;
        const targetY = point === "near" ? inputs.nearY : inputs.farY;
        if (targetX instanceof HTMLInputElement) {
          updateReversingInputValue(targetX, clampedX, { markEdited: true });
          handleReversingInputEdit(targetX);
          changed = true;
        }
        if (targetY instanceof HTMLInputElement) {
          updateReversingInputValue(targetY, clampedY, { markEdited: true });
          handleReversingInputEdit(targetY);
          changed = true;
        }
        if (changed) {
          if (reversingAidsStatus) {
            reversingAidsStatus.textContent = "";
          }
          drawReversingPreviewOverlay();
        }
        return changed;
      }

      function handleReversingInputEdit(input) {
        if (!(input instanceof HTMLInputElement)) {
          return;
        }
        if (!reversingPreviewActivePoint) {
          return;
        }
        const side = input.dataset.side;
        const field = input.dataset.reversingField;
        if (!side || !field) {
          return;
        }
        if (side !== reversingPreviewActivePoint.side) {
          return;
        }
        const point = reversingPreviewActivePoint.point;
        if (
          (point === "near" && field !== "near-x" && field !== "near-y") ||
          (point === "far" && field !== "far-x" && field !== "far-y")
        ) {
          return;
        }
        const description = getReversingPointLabel(side, point);
        setReversingPreviewStatus(
          `${description} point updated. Click the preview to refine or choose another point.`,
          { persistent: true },
        );
      }

      function formatDistance(value) {
        if (typeof value !== "number" || Number.isNaN(value)) {
          return "—";
        }
        return `${Math.max(0, value).toFixed(1)} m`;
      }

      function updateDistanceBadge(zoneName) {
        if (!distanceZone) {
          return;
        }
        const valid = new Set(["danger", "warning", "caution", "clear"]);
        const zoneKey =
          typeof zoneName === "string" && valid.has(zoneName.toLowerCase())
            ? zoneName.toLowerCase()
            : "unavailable";
        distanceZone.className = `distance-zone zone-badge ${zoneKey}`;
        const label = DISTANCE_ZONE_LABELS[zoneKey] || DISTANCE_ZONE_LABELS.unavailable;
        distanceZone.textContent = label.toUpperCase();
      }

      function setDistanceCalibrationStatus(message, options = {}) {
        if (!distanceCalibrationStatus) {
          return;
        }
        if (distanceCalibrationStatusTimer) {
          window.clearTimeout(distanceCalibrationStatusTimer);
          distanceCalibrationStatusTimer = null;
        }
        distanceCalibrationStatus.textContent = message || "";
        if (message && options.persistent !== true) {
          distanceCalibrationStatusTimer = window.setTimeout(() => {
            if (
              distanceCalibrationStatus &&
              distanceCalibrationStatus.textContent === message
            ) {
              distanceCalibrationStatus.textContent = "";
            }
            distanceCalibrationStatusTimer = null;
          }, 4000);
        }
      }

      function formatCalibrationValue(value, fractionDigits) {
        if (typeof value !== "number" || !Number.isFinite(value)) {
          return "";
        }
        const text = value.toFixed(fractionDigits);
        return text.replace(/(\.\d*?)0+$/, "$1").replace(/\.$/, "");
      }

      function updateDistanceCalibrationInputs(calibration, forceUpdate = false) {
        if (!distanceCalibrationInputs || typeof calibration !== "object" || calibration === null) {
          return;
        }
        const offsetInput = distanceCalibrationInputs.offset;
        const scaleInput = distanceCalibrationInputs.scale;
        if (
          offsetInput instanceof HTMLInputElement &&
          (forceUpdate || offsetInput.dataset.userEdited !== "true")
        ) {
          offsetInput.value = formatCalibrationValue(calibration.offset_m, 2);
          delete offsetInput.dataset.userEdited;
        }
        if (
          scaleInput instanceof HTMLInputElement &&
          (forceUpdate || scaleInput.dataset.userEdited !== "true")
        ) {
          scaleInput.value = formatCalibrationValue(calibration.scale, 3);
          delete scaleInput.dataset.userEdited;
        }
      }

      function updateDistanceInputs(zones, forceUpdate = false) {
        if (!zones || !distanceInputs) {
          return;
        }
        const keys = ["caution", "warning", "danger"];
        for (const key of keys) {
          const input = distanceInputs[key];
          if (!(input instanceof HTMLInputElement)) {
            continue;
          }
          if (!forceUpdate && input.dataset.userEdited === "true") {
            continue;
          }
          const value = zones[key];
          if (typeof value === "number" && Number.isFinite(value)) {
            input.value = value.toFixed(1);
          } else {
            input.value = "";
          }
          delete input.dataset.userEdited;
        }
      }

      function updateDistanceSummary(data) {
        if (!distanceSummary) {
          return;
        }
        if (
          !data ||
          data.available !== true ||
          typeof data.distance_m !== "number" ||
          Number.isNaN(data.distance_m)
        ) {
          const fallback =
            data && typeof data.error === "string" && data.error.trim()
              ? data.error.trim()
              : "Distance sensor unavailable.";
          distanceSummary.textContent = fallback;
          return;
        }
        const zoneKey =
          typeof data.zone === "string" ? data.zone.toLowerCase() : "clear";
        const label = DISTANCE_ZONE_LABELS[zoneKey] || DISTANCE_ZONE_LABELS.clear;
        distanceSummary.textContent = `${formatDistance(data.distance_m)} • ${label}`;
      }

      function applyDistanceData(data, options = {}) {
        if (distanceValue) {
          if (
            data &&
            data.available === true &&
            typeof data.distance_m === "number" &&
            Number.isFinite(data.distance_m)
          ) {
            distanceValue.textContent = formatDistance(data.distance_m);
          } else {
            distanceValue.textContent = "—";
          }
        }
        const zoneKey = data && typeof data.zone === "string" ? data.zone.toLowerCase() : null;
        updateDistanceBadge(zoneKey);
        updateDistanceSummary(data);
        if (distanceError) {
          const message = data && typeof data.error === "string" ? data.error.trim() : "";
          distanceError.textContent = message;
          distanceError.classList.toggle("muted", !message);
        }
        if (data && data.zones) {
          updateDistanceInputs(data.zones, options.updateInputs === true);
        }
        if (data && data.calibration) {
          const forceUpdate = options.updateCalibration === true || options.updateInputs === true;
          updateDistanceCalibrationInputs(data.calibration, forceUpdate);
        }
      }

      function renderDiagnosticsList(element, items) {
        if (!element) {
          return 0;
        }
        const entries = Array.isArray(items)
          ? items
              .map((item) => (typeof item === "string" ? item.trim() : ""))
              .filter((item) => item.length > 0)
          : [];
        if (entries.length === 0) {
          element.hidden = true;
          element.replaceChildren();
          return 0;
        }
        const fragment = document.createDocumentFragment();
        for (const entry of entries) {
          const listItem = document.createElement("li");
          listItem.textContent = entry;
          fragment.appendChild(listItem);
        }
        element.replaceChildren(fragment);
        element.hidden = false;
        return entries.length;
      }

      function applyDiagnostics(data) {
        if (!diagnosticsResults) {
          return;
        }
        diagnosticsResults.hidden = false;
        if (diagnosticsError) {
          diagnosticsError.textContent = "";
        }
        if (diagnosticsSummary) {
          const version =
            data && typeof data.version === "string" ? data.version.trim() : "";
          diagnosticsSummary.textContent = version ? `Application version ${version}` : "";
          diagnosticsSummary.hidden = version.length === 0;
        }
        const conflicts = data && Array.isArray(data.camera_conflicts)
          ? data.camera_conflicts
          : [];
        const conflictCount = renderDiagnosticsList(diagnosticsConflicts, conflicts);
        if (diagnosticsNoConflicts) {
          diagnosticsNoConflicts.hidden = conflictCount > 0;
        }
        const picamera =
          data && typeof data.picamera === "object" && data.picamera !== null
            ? data.picamera
            : {};
        if (diagnosticsPicameraStatus) {
          const statusText =
            typeof picamera.status === "string" ? picamera.status.trim() : "";
          const classes = diagnosticsPicameraStatus.classList;
          classes.remove("ok", "error");
          let summary;
          if (statusText.toLowerCase() === "ok") {
            summary = "Picamera2 Python stack: OK";
            classes.add("ok");
          } else if (statusText) {
            summary = `Picamera2 Python stack status: ${statusText}`;
            classes.add("error");
          } else {
            summary = "Picamera2 Python stack status unknown.";
          }
          const numpyVersion =
            typeof picamera.numpy_version === "string"
              ? picamera.numpy_version.trim()
              : "";
          if (numpyVersion) {
            summary = `${summary} • NumPy ${numpyVersion}`;
          }
          diagnosticsPicameraStatus.textContent = summary;
        }
        const detailsCount = renderDiagnosticsList(
          diagnosticsPicameraDetails,
          picamera && Array.isArray(picamera.details) ? picamera.details : [],
        );
        if (diagnosticsPicameraDetails) {
          diagnosticsPicameraDetails.hidden = detailsCount === 0;
        }
        const hintsCount = renderDiagnosticsList(
          diagnosticsPicameraHints,
          picamera && Array.isArray(picamera.hints) ? picamera.hints : [],
        );
        if (diagnosticsPicameraHintsBlock) {
          diagnosticsPicameraHintsBlock.hidden = hintsCount === 0;
        }
      }

      async function refreshDiagnostics() {
        if (diagnosticsLoading) {
          return;
        }
        diagnosticsLoading = true;
        if (diagnosticsStatusTimer) {
          clearTimeout(diagnosticsStatusTimer);
          diagnosticsStatusTimer = null;
        }
        if (diagnosticsStatus) {
          diagnosticsStatus.textContent = "Running diagnostics…";
        }
        if (diagnosticsButton) {
          diagnosticsButton.disabled = true;
        }
        if (diagnosticsError) {
          diagnosticsError.textContent = "";
        }
        try {
          const response = await fetch("/api/diagnostics", { cache: "no-store" });
          if (!response.ok) {
            let errorDetail = `Diagnostics request failed with status ${response.status}`;
            try {
              const errorPayload = await response.json();
              if (errorPayload && typeof errorPayload.detail === "string") {
                const detail = errorPayload.detail.trim();
                if (detail) {
                  errorDetail = detail;
                }
              }
            } catch (err) {
              console.error(err);
            }
            throw new Error(errorDetail);
          }
          const payload = await response.json();
          applyDiagnostics(payload);
          if (diagnosticsStatus) {
            diagnosticsStatus.textContent = "Diagnostics updated";
            diagnosticsStatusTimer = window.setTimeout(() => {
              if (diagnosticsStatus) {
                diagnosticsStatus.textContent = "";
              }
              diagnosticsStatusTimer = null;
            }, 4000);
          }
        } catch (error) {
          console.error("Diagnostics fetch failed", error);
          const message =
            error instanceof Error && error.message
              ? error.message
              : "Unable to collect diagnostics.";
          if (diagnosticsError) {
            diagnosticsError.textContent = message;
          }
          if (diagnosticsStatus) {
            diagnosticsStatus.textContent = "Diagnostics failed";
          }
        } finally {
          diagnosticsLoading = false;
          if (diagnosticsButton) {
            diagnosticsButton.disabled = false;
          }
        }
      }

      async function refreshDistanceReading(showLoading = false) {
        if (distanceLoading) {
          return;
        }
        distanceLoading = true;
        if (showLoading && distanceSummary) {
          distanceSummary.textContent = "Refreshing distance…";
        }
        if (distanceRefreshButton) {
          distanceRefreshButton.disabled = true;
        }
        try {
          const response = await fetch("/api/distance", { cache: "no-store" });
          if (!response.ok) {
            throw new Error(`Distance request failed with status ${response.status}`);
          }
          const payload = await response.json();
          applyDistanceData(payload);
        } catch (error) {
          console.error("Distance status error", error);
          applyDistanceData({ available: false, error: "Unable to load distance reading." });
        } finally {
          distanceLoading = false;
          if (distanceRefreshButton) {
            distanceRefreshButton.disabled = false;
          }
        }
      }

      function getTabFromHash(hash) {
        if (typeof hash !== "string" || !hash) {
          return null;
        }
        const value = hash.replace(/^#/, "").trim();
        if (!value) {
          return null;
        }
        return availableTabs.includes(value) ? value : null;
      }

      function updateBatteryIndicator(data) {
        if (!batteryIcon || !batteryLevel || !batteryText || !batteryDetails) {
          return;
        }
        batteryIcon.classList.remove("low", "charging", "unavailable");
        if (
          !data ||
          data.available !== true ||
          typeof data.percentage !== "number" ||
          Number.isNaN(data.percentage)
        ) {
          batteryIcon.classList.add("unavailable");
          batteryLevel.style.width = "0%";
          batteryText.textContent = "—";
          const fallback =
            data && typeof data.error === "string" && data.error.trim()
              ? data.error.trim()
              : "Battery unavailable";
          batteryDetails.textContent = fallback;
          if (batteryIndicator) {
            batteryIndicator.setAttribute("aria-label", fallback);
          }
          return;
        }
        const percentage = Math.max(0, Math.min(100, Number(data.percentage)));
        const rounded = Math.round(percentage);
        batteryLevel.style.width = `${percentage}%`;
        batteryText.textContent = `${rounded}%`;
        if (data.charging === true) {
          batteryIcon.classList.add("charging");
        } else if (percentage <= 20) {
          batteryIcon.classList.add("low");
        }
        const detailParts = [];
        if (typeof data.voltage === "number" && Number.isFinite(data.voltage)) {
          detailParts.push(`${data.voltage.toFixed(2)} V`);
        }
        if (typeof data.current_ma === "number" && Number.isFinite(data.current_ma)) {
          const magnitude = Math.abs(data.current_ma);
          const decimals = magnitude >= 100 ? 0 : magnitude >= 10 ? 1 : 2;
          const formatted = magnitude.toFixed(decimals);
          const suffix = data.charging === true ? "charging" : "draw";
          detailParts.push(`${formatted} mA ${suffix}`);
        } else if (data.charging === true) {
          detailParts.push("Charging");
        }
        const detailText = detailParts.join(" · ") || "Battery OK";
        batteryDetails.textContent = detailText;
        if (batteryIndicator) {
          batteryIndicator.setAttribute(
            "aria-label",
            `Battery ${rounded}%, ${detailParts.join(", ") || "status"}`,
          );
        }
      }

      function updateBatteryMetrics(data) {
        if (batteryState) {
          if (!data || data.available !== true) {
            const fallback =
              data && typeof data.error === "string" && data.error.trim()
                ? data.error.trim()
                : "Unavailable";
            batteryState.textContent = fallback;
          } else if (data.charging === true) {
            batteryState.textContent = "Charging";
          } else if (data.charging === false) {
            batteryState.textContent = "On battery power";
          } else {
            batteryState.textContent = "Status unknown";
          }
        }
        if (batteryVoltage) {
          if (data && typeof data.voltage === "number" && Number.isFinite(data.voltage)) {
            batteryVoltage.textContent = `${data.voltage.toFixed(2)} V`;
          } else {
            batteryVoltage.textContent = "—";
          }
        }
        if (batteryCurrent) {
          if (data && typeof data.current_ma === "number" && Number.isFinite(data.current_ma)) {
            const magnitude = Math.abs(data.current_ma);
            const decimals = magnitude >= 100 ? 0 : magnitude >= 10 ? 1 : 2;
            const formatted = magnitude.toFixed(decimals);
            const suffix = data && data.charging === true ? "charging" : "draw";
            batteryCurrent.textContent = `${formatted} mA ${suffix}`;
          } else if (data && data.charging === true) {
            batteryCurrent.textContent = "Charging";
          } else {
            batteryCurrent.textContent = "—";
          }
        }
        if (batteryCapacity) {
          if (data && typeof data.capacity_mah === "number" && Number.isFinite(data.capacity_mah)) {
            batteryCapacity.textContent = `${Math.round(data.capacity_mah)} mAh`;
          } else {
            batteryCapacity.textContent = "—";
          }
        }
      }

      function updateBatterySummary(data) {
        if (!batterySummary) {
          return;
        }
        if (
          !data ||
          data.available !== true ||
          typeof data.percentage !== "number" ||
          Number.isNaN(data.percentage)
        ) {
          const fallback =
            data && typeof data.error === "string" && data.error.trim()
              ? data.error.trim()
              : "Battery sensor unavailable.";
          batterySummary.textContent = fallback;
          return;
        }
        const percentage = Math.max(0, Math.min(100, Number(data.percentage)));
        const rounded = Math.round(percentage);
        const pieces = [`${rounded}% charged`];
        if (typeof data.voltage === "number" && Number.isFinite(data.voltage)) {
          pieces.push(`${data.voltage.toFixed(2)} V`);
        }
        if (typeof data.current_ma === "number" && Number.isFinite(data.current_ma)) {
          const magnitude = Math.abs(data.current_ma);
          const decimals = magnitude >= 100 ? 0 : magnitude >= 10 ? 1 : 2;
          const formatted = magnitude.toFixed(decimals);
          const suffix = data.charging === true ? "charging" : "draw";
          pieces.push(`${formatted} mA ${suffix}`);
        } else if (data.charging === true) {
          pieces.push("Charging");
        }
        if (
          typeof data.capacity_mah === "number" &&
          Number.isFinite(data.capacity_mah) &&
          data.capacity_mah > 0
        ) {
          pieces.push(`${Math.round(data.capacity_mah)} mAh pack`);
        }
        batterySummary.textContent = pieces.join(" • ");
      }

      function applyBatteryReading(data) {
        updateBatteryIndicator(data);
        updateBatteryMetrics(data);
        updateBatterySummary(data);
      }

      async function refreshBatteryStatus(showLoading = false) {
        if (!batteryIndicator) {
          return;
        }
        if (batteryLoading) {
          return;
        }
        batteryLoading = true;
        if (showLoading && batterySummary) {
          batterySummary.textContent = "Refreshing battery status…";
        }
        if (batteryRefreshButton) {
          batteryRefreshButton.disabled = true;
        }
        try {
          const response = await fetch("/api/battery", { cache: "no-store" });
          if (!response.ok) {
            throw new Error(`Battery request failed with status ${response.status}`);
          }
          const payload = await response.json();
          applyBatteryReading(payload);
        } catch (error) {
          console.error("Battery status error", error);
          applyBatteryReading({ available: false, error: "Unable to load battery status." });
        } finally {
          batteryLoading = false;
          if (batteryRefreshButton) {
            batteryRefreshButton.disabled = false;
          }
        }
      }

      function updateBatteryLimitsInputs(limits, options = {}) {
        if (!batteryLimitsInputs) {
          return;
        }
        const { force = false, clearUserEdited = false } = options;
        const entries = [
          ["capacity_mah", batteryLimitsInputs.capacity],
          ["warning_percent", batteryLimitsInputs.warning],
          ["shutdown_percent", batteryLimitsInputs.shutdown],
        ];
        for (const [property, input] of entries) {
          if (!(input instanceof HTMLInputElement)) {
            continue;
          }
          if (!force && input.dataset.userEdited === "true") {
            continue;
          }
          let rawValue = undefined;
          if (limits && typeof limits === "object" && property in limits) {
            const candidate = limits[property];
            if (typeof candidate === "number") {
              rawValue = candidate;
            } else if (typeof candidate === "string") {
              const parsed = Number.parseFloat(candidate);
              rawValue = Number.isFinite(parsed) ? parsed : undefined;
            }
          }
          if (typeof rawValue === "number" && Number.isFinite(rawValue)) {
            const displayValue =
              property === "capacity_mah" ? Math.round(rawValue) : rawValue;
            input.value = displayValue.toString();
            if (property === "capacity_mah" && batteryCapacity) {
              batteryCapacity.textContent = `${Math.round(displayValue)} mAh`;
            }
          } else {
            input.value = "";
            if (property === "capacity_mah" && batteryCapacity) {
              batteryCapacity.textContent = "—";
            }
          }
          if (clearUserEdited) {
            delete input.dataset.userEdited;
          }
        }
      }

      async function loadBatteryLimits({ showLoading = false, force = false } = {}) {
        if (!batteryLimitsForm) {
          return;
        }
        if (batteryLimitsLoading) {
          return;
        }
        if (batteryLimitsLoaded && !force) {
          return;
        }
        batteryLimitsLoading = true;
        if (batteryLimitsStatusTimer) {
          clearTimeout(batteryLimitsStatusTimer);
          batteryLimitsStatusTimer = null;
        }
        if (batteryLimitsStatus && showLoading) {
          batteryLimitsStatus.textContent = "Loading battery settings…";
        }
        if (batteryLimitsSubmit) {
          batteryLimitsSubmit.disabled = true;
        }
        try {
          const response = await fetch("/api/battery/limits", { cache: "no-store" });
          if (!response.ok) {
            throw new Error(`Battery settings request failed with status ${response.status}`);
          }
          const payload = await response.json();
          updateBatteryLimitsInputs(payload, { force: true, clearUserEdited: true });
          batteryLimitsLoaded = true;
          if (batteryLimitsStatus) {
            batteryLimitsStatus.textContent = "";
          }
        } catch (error) {
          console.error("Battery limits load error", error);
          batteryLimitsLoaded = false;
          if (batteryLimitsStatus) {
            batteryLimitsStatus.textContent = "Unable to load battery settings.";
          }
        } finally {
          batteryLimitsLoading = false;
          if (batteryLimitsSubmit) {
            batteryLimitsSubmit.disabled = false;
          }
        }
      }

      function setActiveTab(tabName, { updateHash = true } = {}) {
        if (!availableTabs.length) {
          return;
        }
        const desired =
          typeof tabName === "string" && availableTabs.includes(tabName)
            ? tabName
            : availableTabs[0];
        for (const button of tabButtons) {
          const isActive = button.dataset.tab === desired;
          button.setAttribute("aria-selected", isActive ? "true" : "false");
          button.tabIndex = isActive ? 0 : -1;
        }
        for (const panel of tabPanels) {
          if (panel.dataset.tab === desired) {
            panel.removeAttribute("hidden");
          } else {
            panel.setAttribute("hidden", "");
          }
        }
        if (updateHash) {
          const desiredHash = `#${desired}`;
          try {
            if (window.location.hash !== desiredHash) {
              if (typeof window.history?.replaceState === "function") {
                window.history.replaceState(null, "", desiredHash);
              } else {
                window.location.hash = desiredHash;
              }
            }
          } catch (err) {
            console.error(err);
          }
        }
        if (desired === "battery") {
          refreshBatteryStatus().catch((err) => console.error(err));
          loadBatteryLimits({ showLoading: !batteryLimitsLoaded })
            .catch((err) => console.error(err));
        }
      }

      function focusTabByIndex(index) {
        if (!tabButtons.length) {
          return;
        }
        const total = tabButtons.length;
        const normalized = ((index % total) + total) % total;
        const button = tabButtons[normalized];
        if (!button) {
          return;
        }
        button.focus();
        const tabName = button.dataset.tab;
        if (typeof tabName === "string" && tabName) {
          setActiveTab(tabName);
        }
      }

      tabButtons.forEach((button, index) => {
        button.addEventListener("click", () => {
          const tabName = button.dataset.tab;
          if (typeof tabName === "string" && tabName) {
            setActiveTab(tabName);
          }
        });
        button.addEventListener("keydown", (event) => {
          switch (event.key) {
            case "ArrowRight":
            case "ArrowDown":
              event.preventDefault();
              focusTabByIndex(index + 1);
              break;
            case "ArrowLeft":
            case "ArrowUp":
              event.preventDefault();
              focusTabByIndex(index - 1);
              break;
            case "Home":
              event.preventDefault();
              focusTabByIndex(0);
              break;
            case "End":
              event.preventDefault();
              focusTabByIndex(tabButtons.length - 1);
              break;
            default:
              break;
          }
        });
      });

      if (diagnosticsButton) {
        diagnosticsButton.addEventListener("click", () => {
          refreshDiagnostics().catch((err) => console.error(err));
        });
      }

      if (distanceRefreshButton) {
        distanceRefreshButton.addEventListener("click", () => {
          refreshDistanceReading(true).catch((err) => console.error(err));
        });
      }

      if (distanceCalibrationForm) {
        distanceCalibrationForm.addEventListener("submit", async (event) => {
          event.preventDefault();
          if (!distanceCalibrationInputs) {
            return;
          }
          const offsetInput = distanceCalibrationInputs.offset;
          const scaleInput = distanceCalibrationInputs.scale;
          if (!(offsetInput instanceof HTMLInputElement) || !(scaleInput instanceof HTMLInputElement)) {
            return;
          }
          const offset = Number.parseFloat(offsetInput.value);
          const scale = Number.parseFloat(scaleInput.value);
          if (!Number.isFinite(offset) || !Number.isFinite(scale)) {
            setDistanceCalibrationStatus("Enter numeric values for offset and scale.");
            return;
          }
          if (Math.abs(offset) > CALIBRATION_OFFSET_LIMIT) {
            setDistanceCalibrationStatus(
              `Offset must be between -${CALIBRATION_OFFSET_LIMIT} and ${CALIBRATION_OFFSET_LIMIT}.`,
              { persistent: true },
            );
            return;
          }
          if (scale < CALIBRATION_SCALE_MIN || scale > CALIBRATION_SCALE_MAX) {
            setDistanceCalibrationStatus(
              `Scale must be between ${CALIBRATION_SCALE_MIN} and ${CALIBRATION_SCALE_MAX}.`,
              { persistent: true },
            );
            return;
          }
          setDistanceCalibrationStatus("Saving…", { persistent: true });
          try {
            const response = await fetch("/api/distance/calibration", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ offset_m: offset, scale }),
            });
            if (!response.ok) {
              let detail = "Unable to save calibration.";
              try {
                const payload = await response.json();
                if (payload && typeof payload.detail === "string") {
                  detail = payload.detail;
                }
              } catch (err) {
                console.error(err);
              }
              setDistanceCalibrationStatus(detail, { persistent: true });
              return;
            }
            const payload = await response.json();
            applyDistanceData(payload, { updateInputs: true, updateCalibration: true });
            setDistanceCalibrationStatus("Calibration saved");
          } catch (error) {
            console.error(error);
            setDistanceCalibrationStatus("Unable to save calibration.", { persistent: true });
          }
        });
      }

      if (distanceZeroButton) {
        distanceZeroButton.addEventListener("click", async () => {
          if (distanceSummary) {
            distanceSummary.textContent = "Zeroing sensor…";
          }
          setDistanceCalibrationStatus("Zeroing…", { persistent: true });
          distanceZeroButton.disabled = true;
          try {
            const response = await fetch("/api/distance/calibration/zero", { method: "POST" });
            if (!response.ok) {
              let detail = "Unable to zero sensor.";
              try {
                const payload = await response.json();
                if (payload && typeof payload.detail === "string") {
                  detail = payload.detail;
                }
              } catch (err) {
                console.error(err);
              }
              if (distanceSummary) {
                distanceSummary.textContent = detail;
              }
              setDistanceCalibrationStatus(detail, { persistent: true });
              return;
            }
            const payload = await response.json();
            applyDistanceData(payload, { updateInputs: true, updateCalibration: true });
            setDistanceCalibrationStatus("Sensor zeroed");
          } catch (error) {
            console.error(error);
            const message = "Unable to zero sensor.";
            if (distanceSummary) {
              distanceSummary.textContent = message;
            }
            setDistanceCalibrationStatus(message, { persistent: true });
          } finally {
            distanceZeroButton.disabled = false;
          }
        });
      }

      if (distanceZonesForm) {
        distanceZonesForm.addEventListener("submit", async (event) => {
          event.preventDefault();
          if (!distanceInputs) {
            return;
          }
          if (distanceZonesStatus) {
            distanceZonesStatus.textContent = "Saving…";
          }
          const cautionInput = distanceInputs.caution;
          const warningInput = distanceInputs.warning;
          const dangerInput = distanceInputs.danger;
          const caution =
            cautionInput instanceof HTMLInputElement ? Number.parseFloat(cautionInput.value) : Number.NaN;
          const warning =
            warningInput instanceof HTMLInputElement ? Number.parseFloat(warningInput.value) : Number.NaN;
          const danger =
            dangerInput instanceof HTMLInputElement ? Number.parseFloat(dangerInput.value) : Number.NaN;
          if (!Number.isFinite(caution) || !Number.isFinite(warning) || !Number.isFinite(danger)) {
            if (distanceZonesStatus) {
              distanceZonesStatus.textContent = "Enter numeric thresholds for all zones.";
            }
            return;
          }
          if (caution <= 0 || warning <= 0 || danger <= 0) {
            if (distanceZonesStatus) {
              distanceZonesStatus.textContent = "Thresholds must be positive values.";
            }
            return;
          }
          if (!(caution >= warning && warning >= danger)) {
            if (distanceZonesStatus) {
              distanceZonesStatus.textContent = "Ensure caution ≥ warning ≥ danger.";
            }
            return;
          }
          try {
            const response = await fetch("/api/distance/zones", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ caution, warning, danger }),
            });
            if (!response.ok) {
              let errorDetail = "Unable to save warning zones.";
              try {
                const payload = await response.json();
                if (payload && typeof payload.detail === "string") {
                  errorDetail = payload.detail;
                }
              } catch (err) {
                console.error(err);
              }
              if (distanceZonesStatus) {
                distanceZonesStatus.textContent = errorDetail;
              }
              return;
            }
            const payload = await response.json();
            applyDistanceData(payload, { updateInputs: true, updateCalibration: true });
            if (distanceZonesStatus) {
              distanceZonesStatus.textContent = "Warning zones saved";
              setTimeout(() => {
                if (distanceZonesStatus && distanceZonesStatus.textContent === "Warning zones saved") {
                  distanceZonesStatus.textContent = "";
                }
              }, 3000);
            }
          } catch (err) {
            console.error("Distance zone update error", err);
            if (distanceZonesStatus) {
              distanceZonesStatus.textContent = "Unable to save warning zones.";
            }
          }
        });
      }

      if (reversingAidsEnabledInput) {
        setReversingInputsDisabled(!reversingAidsEnabledInput.checked);
        reversingAidsEnabledInput.addEventListener("change", () => {
          if (!reversingAidsEnabledInput.checked) {
            setReversingPreviewActivePoint(null);
          }
          setReversingInputsDisabled(!reversingAidsEnabledInput.checked);
          drawReversingPreviewOverlay();
        });
        drawReversingPreviewOverlay();
      }

      if (reversingPointButtons.length) {
        for (const button of reversingPointButtons) {
          button.addEventListener("click", () => {
            const side = button.dataset.side;
            const point = button.dataset.reversingPick;
            if (!side || !point) {
              return;
            }
            const isActive =
              !!reversingPreviewActivePoint &&
              reversingPreviewActivePoint.side === side &&
              reversingPreviewActivePoint.point === point;
            if (isActive) {
              setReversingPreviewActivePoint(null);
            } else {
              setReversingPreviewActivePoint({ side, point });
            }
          });
        }
      }

      if (reversingPreviewStage instanceof HTMLElement) {
        reversingPreviewStage.addEventListener("click", (event) => {
          if (reversingAidsEnabledInput && !reversingAidsEnabledInput.checked) {
            return;
          }
          if (!reversingPreviewActivePoint) {
            setReversingPreviewStatus("Select a point below to adjust it on the preview.", {
              persistent: true,
            });
            return;
          }
          const rect = reversingPreviewStage.getBoundingClientRect();
          if (!(rect.width > 0 && rect.height > 0)) {
            return;
          }
          const x = clamp01((event.clientX - rect.left) / rect.width);
          const y = clamp01((event.clientY - rect.top) / rect.height);
          const { side, point } = reversingPreviewActivePoint;
          if (!setReversingPointFromPreview(side, point, x, y)) {
            return;
          }
          const description = getReversingPointLabel(side, point);
          setReversingPreviewStatus(
            `${description} point updated. Click the preview to refine or choose another point.`,
            { persistent: true },
          );
        });
      }

      updateReversingPreviewControlsState();

      if (reversingPreviewClearButton) {
        reversingPreviewClearButton.addEventListener("click", () => {
          clearReversingPreviewImage();
          setReversingPreviewStatus("Reference image cleared.");
        });
      }

      if (reversingPreviewUploadButton && reversingPreviewUploadInput) {
        reversingPreviewUploadButton.addEventListener("click", () => {
          if (reversingPreviewUploadInput.disabled) {
            return;
          }
          reversingPreviewUploadInput.click();
        });
      }

      if (reversingPreviewUploadInput) {
        reversingPreviewUploadInput.addEventListener("change", async () => {
          const files = reversingPreviewUploadInput.files;
          if (!files || files.length === 0) {
            return;
          }
          const file = files[0];
          setReversingPreviewStatus(`Loading ${file.name}…`);
          try {
            await loadReversingPreviewFromBlob(file);
            reversingPreviewSource = "upload";
            setReversingPreviewStatus(`Loaded ${file.name}`);
          } catch (err) {
            console.error("Reversing preview upload error", err);
            clearReversingPreviewImage();
            setReversingPreviewStatus("Unable to load image.", { persistent: true });
          } finally {
            reversingPreviewUploadInput.value = "";
          }
        });
      }

      if (reversingPreviewCaptureButton) {
        reversingPreviewCaptureButton.addEventListener("click", () => {
          captureReversingPreviewSnapshot().catch((err) => console.error(err));
        });
      }

      window.addEventListener("resize", () => {
        window.requestAnimationFrame(drawReversingPreviewOverlay);
      });

      if (reversingAidsForm) {
        reversingAidsForm.addEventListener("submit", async (event) => {
          event.preventDefault();
          if (!reversingAidsStatus) {
            return;
          }
          let payload;
          try {
            payload = collectReversingAidsPayload();
          } catch (err) {
            const message = err instanceof Error ? err.message : "Unable to save reversing aids.";
            reversingAidsStatus.textContent = message;
            return;
          }
          reversingAidsStatus.textContent = "Saving…";
          try {
            const response = await fetch("/api/reversing-aids", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            });
            if (!response.ok) {
              let detail = "Unable to save reversing aids.";
              try {
                const problem = await response.json();
                if (problem && typeof problem.detail === "string") {
                  detail = problem.detail;
                }
              } catch (err2) {
                console.error(err2);
              }
              reversingAidsStatus.textContent = detail;
              return;
            }
            const data = await response.json();
            applyReversingAids(data, { forceUpdate: true });
            setReversingPreviewActivePoint(null);
            if (reversingPreviewSource === "snapshot") {
              captureReversingPreviewSnapshot({ silent: true }).catch((err) =>
                console.error("Reversing preview refresh error", err),
              );
            }
            reversingAidsStatus.textContent = "Reversing aids saved.";
            setTimeout(() => {
              if (
                reversingAidsStatus &&
                reversingAidsStatus.textContent === "Reversing aids saved."
              ) {
                reversingAidsStatus.textContent = "";
              }
            }, 3000);
          } catch (err) {
            console.error("Reversing aids update error", err);
            reversingAidsStatus.textContent = "Unable to save reversing aids.";
          }
        });
      }

      if (batteryRefreshButton) {
        batteryRefreshButton.addEventListener("click", () => {
          refreshBatteryStatus(true).catch((err) => console.error(err));
        });
      }

      if (batteryLimitsForm) {
        batteryLimitsForm.addEventListener("submit", async (event) => {
          event.preventDefault();
          if (!batteryLimitsInputs) {
            return;
          }
          const capacityInput = batteryLimitsInputs.capacity;
          const warningInput = batteryLimitsInputs.warning;
          const shutdownInput = batteryLimitsInputs.shutdown;
          const capacityValue =
            capacityInput instanceof HTMLInputElement
              ? Number.parseFloat(capacityInput.value)
              : Number.NaN;
          const warningValue =
            warningInput instanceof HTMLInputElement
              ? Number.parseFloat(warningInput.value)
              : Number.NaN;
          const shutdownValue =
            shutdownInput instanceof HTMLInputElement
              ? Number.parseFloat(shutdownInput.value)
              : Number.NaN;
          if (
            !Number.isFinite(capacityValue) ||
            !Number.isFinite(warningValue) ||
            !Number.isFinite(shutdownValue)
          ) {
            if (batteryLimitsStatus) {
              batteryLimitsStatus.textContent = "Enter numeric values for all battery settings.";
            }
            return;
          }
          const roundedCapacity = Math.round(capacityValue);
          if (roundedCapacity <= 0) {
            if (batteryLimitsStatus) {
              batteryLimitsStatus.textContent = "Capacity must be a positive number.";
            }
            return;
          }
          if (roundedCapacity < 50 || roundedCapacity > 200000) {
            if (batteryLimitsStatus) {
              batteryLimitsStatus.textContent = "Capacity must be between 50 and 200000 mAh.";
            }
            return;
          }
          if (warningValue < 0 || warningValue > 100 || shutdownValue < 0 || shutdownValue > 100) {
            if (batteryLimitsStatus) {
              batteryLimitsStatus.textContent = "Thresholds must be between 0% and 100%.";
            }
            return;
          }
          if (warningValue < shutdownValue) {
            if (batteryLimitsStatus) {
              batteryLimitsStatus.textContent = "Warning must be greater than or equal to shutdown.";
            }
            return;
          }
          if (batteryLimitsStatusTimer) {
            clearTimeout(batteryLimitsStatusTimer);
            batteryLimitsStatusTimer = null;
          }
          if (batteryLimitsStatus) {
            batteryLimitsStatus.textContent = "Saving…";
          }
          if (batteryLimitsSubmit) {
            batteryLimitsSubmit.disabled = true;
          }
          try {
            let payload = null;
            const limitsResponse = await fetch("/api/battery/limits", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                warning_percent: warningValue,
                shutdown_percent: shutdownValue,
              }),
            });
            if (!limitsResponse.ok) {
              let errorDetail = "Unable to save battery settings.";
              try {
                const problem = await limitsResponse.json();
                if (problem && typeof problem.detail === "string") {
                  errorDetail = problem.detail;
                }
              } catch (err) {
                console.error(err);
              }
              if (batteryLimitsStatus) {
                batteryLimitsStatus.textContent = errorDetail;
              }
              return;
            }
            payload = await limitsResponse.json();
            const capacityResponse = await fetch("/api/battery/capacity", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                capacity_mah: roundedCapacity,
              }),
            });
            if (!capacityResponse.ok) {
              let errorDetail = "Unable to save battery settings.";
              try {
                const problem = await capacityResponse.json();
                if (problem && typeof problem.detail === "string") {
                  errorDetail = problem.detail;
                }
              } catch (err) {
                console.error(err);
              }
              if (batteryLimitsStatus) {
                batteryLimitsStatus.textContent = errorDetail;
              }
              return;
            }
            payload = await capacityResponse.json();
            updateBatteryLimitsInputs(payload, { force: true, clearUserEdited: true });
            batteryLimitsLoaded = true;
            if (batteryLimitsStatus) {
              batteryLimitsStatus.textContent = "Battery settings saved";
              batteryLimitsStatusTimer = window.setTimeout(() => {
                if (
                  batteryLimitsStatus &&
                  batteryLimitsStatus.textContent === "Battery settings saved"
                ) {
                  batteryLimitsStatus.textContent = "";
                }
                batteryLimitsStatusTimer = null;
              }, 3000);
            }
            refreshBatteryStatus().catch((err) => console.error(err));
          } catch (err) {
            console.error("Battery settings update error", err);
            if (batteryLimitsStatus) {
              batteryLimitsStatus.textContent = "Unable to save battery settings.";
            }
          } finally {
            if (batteryLimitsSubmit) {
              batteryLimitsSubmit.disabled = false;
            }
          }
        });
      }

      if (availableTabs.length) {
        const initialTab = getTabFromHash(window.location.hash) || availableTabs[0];
        setActiveTab(initialTab, { updateHash: false });
      }

      window.addEventListener("hashchange", () => {
        const target = getTabFromHash(window.location.hash);
        if (target) {
          setActiveTab(target, { updateHash: false });
        }
      });

      function describeCameraErrors(camera) {
        if (!camera || !camera.errors) {
          return [];
        }
        const descriptions = [];
        const seen = new Set();
        for (const [source, detail] of Object.entries(camera.errors)) {
          if (!detail) {
            continue;
          }
          const label = cameraLabels.get(source) || source;
          const combined = `${label}: ${detail}`;
          const dedupeKey = detail.trim().toLowerCase();
          if (dedupeKey && seen.has(dedupeKey)) {
            continue;
          }
          if (dedupeKey) {
            seen.add(dedupeKey);
          }
          descriptions.push(combined);
        }
        return descriptions;
      }

      function formatSignalValue(signal) {
        if (typeof signal !== "number" || Number.isNaN(signal)) {
          return "—";
        }
        return `${signal}%`;
      }

      function summariseWifiStatus(status) {
        if (!status) {
          return "Wi-Fi status unavailable.";
        }
        const pieces = [];
        const name = status.ssid || status.profile || "network";
        if (status.hotspot_active) {
          pieces.push(`Hotspot active (${name})`);
          if (status.ip_address) {
            pieces.push(`IP ${status.ip_address}`);
          }
          pieces.push(`Visit http://${HOTSPOT_HOSTNAME}:9000/`);
        } else if (status.connected) {
          const signalText = formatSignalValue(status.signal);
          pieces.push(`Connected to ${name}${signalText !== "—" ? ` (${signalText})` : ""}`);
          if (status.ip_address) {
            pieces.push(`IP ${status.ip_address}`);
          }
        } else {
          pieces.push("Not connected to Wi-Fi.");
        }
        if (status.detail) {
          pieces.push(status.detail);
        }
        if (status.error) {
          pieces.push(`Error: ${status.error}`);
        }
        return pieces.join(" ");
      }

      function setWifiFeedback(message, isError = false) {
        if (!wifiFeedback) {
          return;
        }
        wifiFeedback.textContent = message || "";
        if (isError) {
          wifiFeedback.classList.add("error");
        } else {
          wifiFeedback.classList.remove("error");
        }
      }

      function hideWifiConnectForm() {
        if (!wifiConnectForm) {
          return;
        }
        wifiConnectForm.hidden = true;
        if (wifiConnectSelected) {
          wifiConnectSelected.textContent = "";
        }
        if (wifiConnectPasswordInput) {
          wifiConnectPasswordInput.value = "";
        }
      }

      function renderWifiNetworks(networks) {
        if (!wifiNetworkList) {
          return;
        }
        wifiNetworkList.innerHTML = "";
        if (!Array.isArray(networks) || networks.length === 0) {
          const empty = document.createElement("li");
          empty.className = "wifi-network";
          empty.textContent = "No Wi-Fi networks detected.";
          wifiNetworkList.appendChild(empty);
          return;
        }
        for (const network of networks) {
          const item = document.createElement("li");
          item.className = "wifi-network";
          const info = document.createElement("div");
          info.style.minWidth = "12rem";
          const name = document.createElement("strong");
          const identifier = typeof network.ssid === "string" ? network.ssid.trim() : "";
          const ssid = identifier ? identifier : "(hidden network)";
          name.textContent = ssid;
          info.appendChild(name);
          const details = document.createElement("span");
          const detailParts = [];
          if (typeof network.signal === "number" && !Number.isNaN(network.signal)) {
            detailParts.push(`${network.signal}%`);
          }
          if (network.security && typeof network.security === "string") {
            detailParts.push(network.security);
          }
          if (network.frequency) {
            const freqText = `${network.frequency} MHz`;
            if (network.channel) {
              detailParts.push(`${freqText} (ch ${network.channel})`);
            } else {
              detailParts.push(freqText);
            }
          }
          if (network.known) {
            detailParts.push("saved");
          }
          if (network.active) {
            detailParts.push("active");
          }
          details.textContent = detailParts.length ? detailParts.join(" • ") : "Details unavailable";
          info.appendChild(details);
          item.appendChild(info);
          const actions = document.createElement("div");
          actions.className = "actions";
          const connectButton = document.createElement("button");
          connectButton.type = "button";
          if (network.active) {
            connectButton.textContent = "Connected";
            connectButton.disabled = true;
          } else if (network.hidden) {
            connectButton.textContent = "Hidden network";
            connectButton.disabled = true;
          } else {
            connectButton.textContent = "Connect";
            connectButton.addEventListener("click", () => {
              if (!wifiConnectForm || !wifiConnectSsidInput || !wifiConnectSelected) {
                return;
              }
              wifiConnectForm.hidden = false;
              wifiConnectSsidInput.value = ssid;
              wifiConnectSelected.textContent = `Selected network: ${ssid}`;
              if (wifiConnectPasswordInput) {
                wifiConnectPasswordInput.value = "";
                wifiConnectPasswordInput.placeholder = network.security
                  ? `Security: ${network.security}`
                  : "Password (if required)";
              }
              if (wifiRollbackInput && typeof wifiRollbackInput.value === "string" && !wifiRollbackInput.value) {
                wifiRollbackInput.value = "30";
              }
            });
          }
          actions.appendChild(connectButton);
          if (network.known) {
            const forgetButton = document.createElement("button");
            forgetButton.type = "button";
            forgetButton.className = "secondary-button";
            forgetButton.textContent = "Forget";
            if (!identifier) {
              forgetButton.disabled = true;
              forgetButton.title = "Unable to forget hidden networks.";
            } else {
              forgetButton.addEventListener("click", () => {
                forgetSavedNetwork(identifier);
              });
            }
            actions.appendChild(forgetButton);
          }
          item.appendChild(actions);
          wifiNetworkList.appendChild(item);
        }
      }

      async function refreshWifiStatus() {
        if (!wifiSummary) {
          return null;
        }
        try {
          const response = await fetch("/api/wifi/status");
          if (!response.ok) {
            throw new Error("Unable to fetch Wi-Fi status");
          }
          const status = await response.json();
          wifiSummary.textContent = summariseWifiStatus(status);
          if (wifiHotspotStatus) {
            if (status.hotspot_active) {
              const hotspotName = status.ssid || status.profile || "Hotspot";
              const pieces = [`Hotspot active (${hotspotName})`];
              if (status.ip_address) {
                pieces.push(`IP ${status.ip_address}`);
              }
              pieces.push(`Visit http://${HOTSPOT_HOSTNAME}:9000/`);
              wifiHotspotStatus.textContent = pieces.join(" • ");
            } else {
              wifiHotspotStatus.textContent = "Hotspot disabled.";
            }
          }
          if (status.detail) {
            setWifiFeedback(status.detail, false);
          } else if (!wifiFeedback || !wifiFeedback.textContent) {
            setWifiFeedback("", false);
          }
          return status;
        } catch (err) {
          console.error(err);
          if (wifiSummary) {
            const message = err instanceof Error ? err.message : "Wi-Fi status unavailable.";
            wifiSummary.textContent = message;
          }
          return null;
        }
      }

      async function scanWifiNetworks() {
        if (!wifiNetworkList) {
          return;
        }
        setWifiFeedback("Scanning for Wi-Fi networks…");
        try {
          const response = await fetch("/api/wifi/networks");
          if (!response.ok) {
            throw new Error("Unable to scan Wi-Fi networks");
          }
          const data = await response.json();
          const networks = Array.isArray(data.networks) ? data.networks : [];
          renderWifiNetworks(networks);
          if (networks.length) {
            setWifiFeedback(`Found ${networks.length} network${networks.length === 1 ? "" : "s"}.`);
          } else {
            setWifiFeedback("No Wi-Fi networks detected. Try scanning again.");
          }
        } catch (err) {
          console.error(err);
          setWifiFeedback("Unable to scan Wi-Fi networks.", true);
        }
      }

      async function connectToWifi() {
        if (!wifiConnectForm || !wifiConnectSsidInput) {
          return;
        }
        const ssid = wifiConnectSsidInput.value.trim();
        if (!ssid) {
          setWifiFeedback("Select a Wi-Fi network before connecting.", true);
          return;
        }
        const payload = {
          ssid,
          development_mode: wifiDevToggle ? !!wifiDevToggle.checked : false,
        };
        if (wifiConnectPasswordInput && wifiConnectPasswordInput.value) {
          payload.password = wifiConnectPasswordInput.value;
        }
        if (wifiRollbackInput) {
          const rollback = parseFloat(wifiRollbackInput.value);
          if (!Number.isNaN(rollback) && rollback > 0) {
            payload.rollback_seconds = rollback;
          }
        }
        setWifiFeedback(`Connecting to ${ssid}…`);
        try {
          const response = await fetch("/api/wifi/connect", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          if (!response.ok) {
            let errorDetail = "Unable to connect to Wi-Fi network.";
            try {
              const error = await response.json();
              if (error && error.detail) {
                errorDetail = error.detail;
              }
            } catch (parseErr) {
              console.error(parseErr);
            }
            setWifiFeedback(errorDetail, true);
            return;
          }
          const status = await response.json();
          const successMessage = status.detail
            ? status.detail
            : `Joined ${status.ssid || ssid}.`;
          setWifiFeedback(successMessage);
          hideWifiConnectForm();
          await refreshWifiStatus();
          await scanWifiNetworks();
        } catch (err) {
          console.error(err);
          setWifiFeedback("Connection attempt failed.", true);
        }
      }

      async function forgetSavedNetwork(identifier) {
        const target = typeof identifier === "string" ? identifier.trim() : "";
        if (!target) {
          setWifiFeedback("Unable to forget unnamed network.", true);
          return;
        }
        setWifiFeedback(`Forgetting ${target}…`);
        try {
          const response = await fetch("/api/wifi/forget", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ identifier: target }),
          });
          if (!response.ok) {
            let errorDetail = "Unable to forget saved network.";
            try {
              const error = await response.json();
              if (error && error.detail) {
                errorDetail = error.detail;
              }
            } catch (parseErr) {
              console.error(parseErr);
            }
            setWifiFeedback(errorDetail, true);
            return;
          }
          const status = await response.json();
          hideWifiConnectForm();
          await refreshWifiStatus();
          await scanWifiNetworks();
          let detailMessage = "";
          if (status && typeof status.detail === "string" && status.detail.trim()) {
            detailMessage = status.detail.trim();
          } else {
            detailMessage = `Removed saved network ${target}.`;
          }
          setWifiFeedback(detailMessage);
        } catch (err) {
          console.error(err);
          setWifiFeedback("Unable to forget saved network.", true);
        }
      }

      async function toggleHotspot(enabled) {
        let payload = { enabled };
        if (enabled) {
          const ssidValue = wifiHotspotSsid && typeof wifiHotspotSsid.value === "string"
            ? wifiHotspotSsid.value.trim()
            : "";
          const passwordValue = wifiHotspotPassword && typeof wifiHotspotPassword.value === "string"
            ? wifiHotspotPassword.value.trim()
            : "";
          if (passwordValue && passwordValue.length < 8) {
            setWifiFeedback("Hotspot password must contain at least 8 characters.", true);
            return;
          }
          const devModeEnabled = wifiDevToggle ? !!wifiDevToggle.checked : false;
          payload = {
            enabled: true,
            ssid: ssidValue || undefined,
            development_mode: devModeEnabled,
          };
          if (passwordValue) {
            payload.password = passwordValue;
          }
          let rollbackSeconds = null;
          let userProvidedRollback = NaN;
          if (wifiRollbackInput && wifiRollbackInput.dataset.userEdited === "true") {
            userProvidedRollback = parseFloat(wifiRollbackInput.value);
          }
          if (devModeEnabled) {
            if (!Number.isNaN(userProvidedRollback) && userProvidedRollback > 0) {
              rollbackSeconds = userProvidedRollback;
            } else {
              rollbackSeconds = HOTSPOT_DEV_ROLLBACK_DEFAULT;
            }
          } else if (!Number.isNaN(userProvidedRollback) && userProvidedRollback > 0) {
            rollbackSeconds = userProvidedRollback;
          }
          if (typeof rollbackSeconds === "number" && rollbackSeconds > 0) {
            payload.rollback_seconds = rollbackSeconds;
          }
          setWifiFeedback("Enabling hotspot…");
        } else {
          payload = { enabled: false };
          setWifiFeedback("Disabling hotspot…");
        }
        try {
          const response = await fetch("/api/wifi/hotspot", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          if (!response.ok) {
            let errorDetail = enabled ? "Unable to enable hotspot." : "Unable to disable hotspot.";
            try {
              const error = await response.json();
              if (error && error.detail) {
                errorDetail = error.detail;
              }
            } catch (parseErr) {
              console.error(parseErr);
            }
            setWifiFeedback(errorDetail, true);
            return;
          }
          const status = await response.json();
          const detailMessage = status.detail
            ? status.detail
            : enabled
            ? `Hotspot enabled. Connect via http://${HOTSPOT_HOSTNAME}:9000/.`
            : "Hotspot disabled.";
          setWifiFeedback(detailMessage);
          await refreshWifiStatus();
        } catch (err) {
          console.error(err);
          setWifiFeedback(enabled ? "Unable to enable hotspot." : "Unable to disable hotspot.", true);
        }
      }

      function updateVersion(camera) {
        if (!versionValue) {
          return;
        }
        const version = camera && camera.version ? String(camera.version).trim() : "";
        versionValue.textContent = version || "Unknown";
      }

      function updateStreamSection(camera) {
        if (!streamSection) {
          return;
        }
        const stream = camera && camera.stream ? camera.stream : null;
        const configuredSettings =
          stream && stream.settings && typeof stream.settings === "object"
            ? stream.settings
            : null;
        const activeSettings =
          stream && stream.active && typeof stream.active === "object"
            ? stream.active
            : null;
        updateStreamInputs(configuredSettings, { force: true });
        if (copyStreamButton) {
          copyStreamButton.textContent = copyButtonDefault;
        }
        if (!stream || stream.enabled === false) {
          if (streamSummary) {
            const detail = stream && stream.error ? String(stream.error).trim() : "";
            const configuredParts = [];
            const configuredFps =
              configuredSettings && typeof configuredSettings.fps === "number"
                ? Math.round(configuredSettings.fps)
                : null;
            const configuredQuality =
              configuredSettings && typeof configuredSettings.jpeg_quality === "number"
                ? Math.round(configuredSettings.jpeg_quality)
                : null;
            if (configuredFps !== null && Number.isFinite(configuredFps)) {
              configuredParts.push(`${configuredFps} fps`);
            }
            if (configuredQuality !== null && Number.isFinite(configuredQuality)) {
              configuredParts.push(`quality ${configuredQuality}`);
            }
            const configSummary =
              configuredParts.length > 0
                ? `Configured for ${configuredParts.join(" · ")}.`
                : "";
            const baseMessage = detail
              ? `Streaming disabled: ${detail}`
              : "Streaming disabled.";
            streamSummary.textContent = configSummary
              ? `${baseMessage} ${configSummary}`
              : baseMessage;
          }
          if (openStreamLink) {
            openStreamLink.classList.add("disabled");
            openStreamLink.setAttribute("aria-disabled", "true");
            openStreamLink.href = "/stream/mjpeg";
          }
          if (copyStreamButton) {
            copyStreamButton.disabled = true;
          }
          if (streamUrlElement) {
            streamUrlElement.textContent = "—";
          }
          return;
        }

        const endpoint = typeof stream.endpoint === "string" && stream.endpoint
          ? stream.endpoint
          : "/stream/mjpeg";
        const absoluteUrl = new URL(endpoint, window.location.origin).toString();
        const streamType = stream.content_type ? String(stream.content_type) : "MJPEG";
        const activeFps =
          activeSettings && typeof activeSettings.fps === "number"
            ? activeSettings.fps
            : null;
        const activeQuality =
          activeSettings && typeof activeSettings.jpeg_quality === "number"
            ? activeSettings.jpeg_quality
            : null;
        const configuredFps =
          configuredSettings && typeof configuredSettings.fps === "number"
            ? configuredSettings.fps
            : null;
        const configuredQuality =
          configuredSettings && typeof configuredSettings.jpeg_quality === "number"
            ? configuredSettings.jpeg_quality
            : null;
        const fpsDisplay =
          activeFps !== null && Number.isFinite(activeFps)
            ? Math.round(activeFps)
            : configuredFps !== null && Number.isFinite(configuredFps)
            ? Math.round(configuredFps)
            : null;
        const qualityDisplay =
          activeQuality !== null && Number.isFinite(activeQuality)
            ? Math.round(activeQuality)
            : configuredQuality !== null && Number.isFinite(configuredQuality)
            ? Math.round(configuredQuality)
            : null;
        if (streamSummary) {
          if (stream.error) {
            streamSummary.textContent = `Streaming issue: ${stream.error}`;
          } else {
            const detailParts = [];
            if (fpsDisplay !== null) {
              detailParts.push(`${fpsDisplay} fps`);
            }
            if (qualityDisplay !== null) {
              detailParts.push(`quality ${qualityDisplay}`);
            }
            const detailText = detailParts.length ? ` – ${detailParts.join(" · ")}` : "";
            streamSummary.textContent = `Live stream ready (${streamType})${detailText}`;
          }
        }
        if (openStreamLink) {
          openStreamLink.classList.remove("disabled");
          openStreamLink.removeAttribute("aria-disabled");
          openStreamLink.href = absoluteUrl;
        }
        if (copyStreamButton) {
          copyStreamButton.disabled = false;
        }
        if (streamUrlElement) {
          streamUrlElement.textContent = absoluteUrl;
        }
      }

      function resetCopyFeedback() {
        if (copyStreamButton) {
          copyStreamButton.textContent = copyButtonDefault;
        }
        copyResetTimer = null;
      }

      function applySettings(orientation, camera, message = "Settings loaded") {
        form.rotation.value = orientation.rotation;
        form.flip_horizontal.checked = orientation.flip_horizontal;
        form.flip_vertical.checked = orientation.flip_vertical;

        updateVersion(camera);
        updateStreamSection(camera);

        const cameraSelect = form.elements.namedItem("camera");
        if (!(cameraSelect instanceof HTMLSelectElement)) {
          throw new Error("Camera select element missing");
        }
        cameraSelect.innerHTML = "";
        cameraLabels.clear();
        for (const option of camera.options || []) {
          const opt = document.createElement("option");
          opt.value = option.value;
          opt.textContent = option.label;
          cameraSelect.appendChild(opt);
          cameraLabels.set(option.value, option.label);
        }
        if (camera.selected && cameraLabels.has(camera.selected)) {
          cameraSelect.value = camera.selected;
        }

        const resolutionSelect = form.elements.namedItem("resolution");
        if (!(resolutionSelect instanceof HTMLSelectElement)) {
          throw new Error("Resolution select element missing");
        }
        resolutionSelect.innerHTML = "";
        resolutionLabels.clear();
        const resolutionInfo = camera && camera.resolution ? camera.resolution : null;
        const resolutionOptions =
          resolutionInfo && Array.isArray(resolutionInfo.options) ? resolutionInfo.options : [];
        for (const option of resolutionOptions) {
          const opt = document.createElement("option");
          opt.value = option.value;
          opt.textContent = option.label;
          resolutionSelect.appendChild(opt);
          resolutionLabels.set(option.value, option.label);
        }
        if (
          resolutionInfo &&
          typeof resolutionInfo.selected === "string" &&
          resolutionLabels.has(resolutionInfo.selected)
        ) {
          resolutionSelect.value = resolutionInfo.selected;
        } else if (resolutionSelect.options.length > 0) {
          resolutionSelect.selectedIndex = 0;
        }

        let status = message;
        const initialStatusLower = typeof status === "string" ? status.toLowerCase() : "";
        const selectedCamera = typeof camera.selected === "string" ? camera.selected : "";
        const activeCamera = typeof camera.active === "string" ? camera.active : "";
        if (
          !initialStatusLower.startsWith("error") &&
          activeCamera &&
          selectedCamera &&
          activeCamera !== selectedCamera
        ) {
          const activeLabel = cameraLabels.get(activeCamera) || activeCamera;
          status += ` (active: ${activeLabel})`;
        }
        if (
          resolutionInfo &&
          typeof resolutionInfo.active === "string" &&
          typeof resolutionInfo.selected === "string" &&
          resolutionInfo.active &&
          resolutionInfo.selected &&
          resolutionInfo.active !== resolutionInfo.selected
        ) {
          const activeLabel =
            resolutionLabels.get(resolutionInfo.active) ||
            resolutionInfo.active.replace(/x/gi, "×");
          status += ` (active resolution: ${activeLabel})`;
        }
        const statusLower = typeof status === "string" ? status.toLowerCase() : "";
        const errorMessages = describeCameraErrors(camera).filter((detail) => {
          if (!statusLower) {
            return true;
          }
          const detailLower = detail.toLowerCase();
          if (statusLower.includes(detailLower)) {
            return false;
          }
          const colonIndex = detail.indexOf(":");
          if (colonIndex !== -1) {
            const tail = detail
              .slice(colonIndex + 1)
              .trim()
              .toLowerCase();
            if (tail && statusLower.includes(tail)) {
              return false;
            }
          }
          return true;
        });
        if (camera.stream) {
          const streamDetail = camera.stream.error ? String(camera.stream.error).trim() : "";
          if (streamDetail) {
            const streamMessage = `Streaming disabled: ${streamDetail}`;
            const streamLower = streamMessage.toLowerCase();
            const alreadyIncluded =
              statusLower.includes(streamLower) ||
              errorMessages.some((detail) => detail.toLowerCase() === streamLower);
            if (!alreadyIncluded) {
              errorMessages.push(streamMessage);
            }
          } else if (camera.stream.enabled === false) {
            const disabledMessage = "Streaming disabled";
            const disabledLower = disabledMessage.toLowerCase();
            const alreadyIncluded =
              statusLower.includes(disabledLower) ||
              errorMessages.some((detail) => detail.toLowerCase() === disabledLower);
            if (!alreadyIncluded) {
              errorMessages.push(disabledMessage);
            }
          }
        }
        if (errorMessages.length) {
          status += ` • ${errorMessages.join(" • ")}`;
        }
        statusLabel.textContent = status;
      }

      if (copyStreamButton && streamUrlElement) {
        copyStreamButton.addEventListener("click", async () => {
          const url = streamUrlElement.textContent ? streamUrlElement.textContent.trim() : "";
          if (!url) {
            return;
          }
          try {
            await navigator.clipboard.writeText(url);
            copyStreamButton.textContent = "Copied!";
            if (copyResetTimer) {
              clearTimeout(copyResetTimer);
            }
            copyResetTimer = setTimeout(resetCopyFeedback, 2000);
          } catch (err) {
            console.error(err);
            copyStreamButton.textContent = "Copy failed";
            copyStreamButton.disabled = true;
            if (copyResetTimer) {
              clearTimeout(copyResetTimer);
            }
            copyResetTimer = setTimeout(() => {
              if (copyStreamButton) {
                copyStreamButton.disabled = false;
                resetCopyFeedback();
              }
            }, 2500);
          }
        });
      }

      if (streamFpsInput) {
        streamFpsInput.addEventListener("input", () => {
          streamFpsInput.dataset.userEdited = "true";
          clearStreamSettingsStatus();
        });
      }

      if (streamQualityInput) {
        const handleQualityChange = () => {
          streamQualityInput.dataset.userEdited = "true";
          setStreamQualityDisplay(Number.parseInt(streamQualityInput.value, 10));
          clearStreamSettingsStatus();
        };
        streamQualityInput.addEventListener("input", handleQualityChange);
        streamQualityInput.addEventListener("change", handleQualityChange);
      }

      if (streamSettingsForm) {
        streamSettingsForm.addEventListener("submit", async (event) => {
          event.preventDefault();
          clearStreamSettingsStatus();
          if (streamSettingsStatus) {
            streamSettingsStatus.textContent = "Saving…";
          }
          const payload = {};
          if (streamFpsInput) {
            const parsedFps = Number.parseInt(streamFpsInput.value, 10);
            if (!Number.isFinite(parsedFps) || parsedFps < 1 || parsedFps > 60) {
              if (streamSettingsStatus) {
                streamSettingsStatus.textContent = "Enter a valid FPS between 1 and 60.";
              }
              return;
            }
            payload.fps = parsedFps;
          }
          if (streamQualityInput) {
            const parsedQuality = Number.parseInt(streamQualityInput.value, 10);
            if (!Number.isFinite(parsedQuality) || parsedQuality < 1 || parsedQuality > 100) {
              if (streamSettingsStatus) {
                streamSettingsStatus.textContent = "Quality must be between 1 and 100.";
              }
              return;
            }
            payload.jpeg_quality = parsedQuality;
          }

          try {
            const response = await fetch("/api/stream/settings", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            });
            if (!response.ok) {
              let errorDetail = "Unable to save streaming settings.";
              try {
                const error = await response.json();
                if (error && typeof error.detail === "string" && error.detail.trim()) {
                  errorDetail = error.detail.trim();
                }
              } catch (err) {
                console.error(err);
              }
              if (streamSettingsStatus) {
                streamSettingsStatus.textContent = `Error: ${errorDetail}`;
              }
              return;
            }
            const data = await response.json();
            const updatedSettings = {
              fps:
                data && typeof data.fps === "number" && Number.isFinite(data.fps)
                  ? data.fps
                  : payload.fps,
              jpeg_quality:
                data &&
                typeof data.jpeg_quality === "number" &&
                Number.isFinite(data.jpeg_quality)
                  ? data.jpeg_quality
                  : payload.jpeg_quality,
            };
            updateStreamInputs(updatedSettings, { force: true });
            if (streamSettingsStatus) {
              streamSettingsStatus.textContent = "Streaming settings saved";
            }
            if (streamSettingsStatusTimer) {
              clearTimeout(streamSettingsStatusTimer);
            }
            streamSettingsStatusTimer = window.setTimeout(() => {
              if (streamSettingsStatus) {
                streamSettingsStatus.textContent = "";
              }
              streamSettingsStatusTimer = null;
            }, 3000);
            try {
              const cameraResponse = await fetch("/api/camera", { cache: "no-store" });
              if (cameraResponse.ok) {
                const cameraData = await cameraResponse.json();
                updateStreamSection(cameraData);
              }
            } catch (err) {
              console.error(err);
            }
          } catch (err) {
            console.error(err);
            if (streamSettingsStatus) {
              streamSettingsStatus.textContent = "Error: Unable to save streaming settings.";
            }
          }
        });
      }

      if (wifiRefreshButton) {
        wifiRefreshButton.addEventListener("click", () => {
          refreshWifiStatus().catch((err) => console.error(err));
        });
      }

      if (wifiScanButton) {
        wifiScanButton.addEventListener("click", () => {
          scanWifiNetworks().catch((err) => console.error(err));
        });
      }

      if (wifiCancelConnect) {
        wifiCancelConnect.addEventListener("click", () => {
          hideWifiConnectForm();
        });
      }

      if (wifiConnectForm) {
        wifiConnectForm.addEventListener("submit", (event) => {
          event.preventDefault();
          connectToWifi().catch((err) => console.error(err));
        });
      }

      if (wifiRollbackInput) {
        wifiRollbackInput.addEventListener("input", () => {
          wifiRollbackInput.dataset.userEdited = "true";
        });
      }

      if (wifiEnableHotspot) {
        wifiEnableHotspot.addEventListener("click", () => {
          toggleHotspot(true).catch((err) => console.error(err));
        });
      }

      if (wifiDisableHotspot) {
        wifiDisableHotspot.addEventListener("click", () => {
          toggleHotspot(false).catch((err) => console.error(err));
        });
      }

      async function fetchSettings() {
        const [
          orientationResponse,
          cameraResponse,
          distanceResponse,
          reversingResponse,
        ] = await Promise.all([
          fetch("/api/orientation"),
          fetch("/api/camera"),
          fetch("/api/distance"),
          fetch("/api/reversing-aids"),
        ]);
        if (!orientationResponse.ok) {
          throw new Error("Unable to fetch current orientation");
        }
        if (!cameraResponse.ok) {
          throw new Error("Unable to fetch camera configuration");
        }
        if (!distanceResponse.ok) {
          throw new Error("Unable to fetch distance configuration");
        }
        if (!reversingResponse.ok) {
          throw new Error("Unable to fetch reversing aid configuration");
        }
        const [orientationData, cameraData, distanceData, reversingData] = await Promise.all([
          orientationResponse.json(),
          cameraResponse.json(),
          distanceResponse.json(),
          reversingResponse.json(),
        ]);
        return {
          orientation: orientationData,
          camera: cameraData,
          distance: distanceData,
          reversing: reversingData,
        };
      }

      async function loadSettings() {
        const data = await fetchSettings();
        applySettings(data.orientation, data.camera);
        applyDistanceData(data.distance, { updateInputs: true, updateCalibration: true });
        applyReversingAids(data.reversing, { forceUpdate: true });
      }

      form.addEventListener("submit", async (event) => {
        event.preventDefault();
        statusLabel.textContent = "Saving…";
        const payload = {
          rotation: parseInt(form.rotation.value, 10),
          flip_horizontal: form.flip_horizontal.checked,
          flip_vertical: form.flip_vertical.checked,
        };
        const orientationResponse = await fetch("/api/orientation", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        if (!orientationResponse.ok) {
          let errorDetail = "Unable to save orientation";
          try {
            const error = await orientationResponse.json();
            errorDetail = error.detail || errorDetail;
          } catch (err) {
            console.error(err);
          }
          statusLabel.textContent = "Error: " + errorDetail;
          return;
        }
        const cameraSelect = form.elements.namedItem("camera");
        if (!(cameraSelect instanceof HTMLSelectElement)) {
          statusLabel.textContent = "Error: camera selector missing";
          return;
        }
        const resolutionSelect = form.elements.namedItem("resolution");
        if (!(resolutionSelect instanceof HTMLSelectElement)) {
          statusLabel.textContent = "Error: resolution selector missing";
          return;
        }
        const cameraResponse = await fetch("/api/camera", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            source: cameraSelect.value,
            resolution: resolutionSelect.value,
          }),
        });
        if (!cameraResponse.ok) {
          let errorDetail = "Unable to update camera";
          try {
            const error = await cameraResponse.json();
            errorDetail = error.detail || errorDetail;
          } catch (err) {
            console.error(err);
          }
          statusLabel.textContent = "Error: " + errorDetail;
          try {
            const data = await fetchSettings();
            applySettings(data.orientation, data.camera, statusLabel.textContent);
            applyDistanceData(data.distance, { updateInputs: true, updateCalibration: true });
            applyReversingAids(data.reversing, { forceUpdate: true });
          } catch (err) {
            console.error(err);
          }
          return;
        }
        try {
          const data = await fetchSettings();
          applySettings(data.orientation, data.camera, "Settings saved");
          applyDistanceData(data.distance, { updateInputs: true, updateCalibration: true });
          applyReversingAids(data.reversing, { forceUpdate: true });
        } catch (err) {
          console.error(err);
          statusLabel.textContent = "Settings saved";
        }
      });

      loadSettings().catch((err) => {
        console.error(err);
        statusLabel.textContent = err.message;
      });

      refreshWifiStatus().catch((err) => {
        console.error(err);
        if (wifiSummary) {
          const message = err instanceof Error ? err.message : "Wi-Fi status unavailable.";
          wifiSummary.textContent = message;
        }
      });

      if (wifiNetworkList) {
        scanWifiNetworks().catch((err) => console.error(err));
      }
    </script>
  </body>
</html>
