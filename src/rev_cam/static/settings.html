<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>RevCam Settings</title>
    <style>
      body {
        margin: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background-color: #111;
        color: #f5f5f5;
        padding: 2rem 1.5rem 3rem;
      }
      h1 {
        margin: 0;
        font-size: 2rem;
      }
      h2 {
        margin: 0 0 0.75rem;
        font-size: 1.35rem;
      }
      h3 {
        margin: 1rem 0 0.5rem;
        font-size: 1.1rem;
      }
      p {
        margin: 0 0 1rem;
      }
      a {
        color: #0a84ff;
      }
      label {
        display: block;
        margin-bottom: 1rem;
      }
      select,
      input[type="text"],
      input[type="password"],
      input[type="number"] {
        margin-top: 0.5rem;
        font-size: 1rem;
        padding: 0.55rem 0.65rem;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(0, 0, 0, 0.35);
        color: inherit;
        width: 100%;
        box-sizing: border-box;
      }
      input[type="checkbox"] {
        margin-top: 0.5rem;
        transform: scale(1.2);
      }
      button {
        background: #0a84ff;
        color: #fff;
        border: none;
        padding: 0.6rem 1.2rem;
        border-radius: 999px;
        font-size: 1rem;
        cursor: pointer;
        font-weight: 600;
      }
      .button-link,
      button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.35rem;
        text-decoration: none;
      }
      .button-link {
        background: #0a84ff;
        color: #fff;
        border-radius: 999px;
        padding: 0.6rem 1.2rem;
        font-size: 1rem;
        font-weight: 600;
      }
      .button-link.disabled {
        opacity: 0.5;
        pointer-events: none;
      }
      button.secondary-button {
        background: transparent;
        border: 1px solid #0a84ff;
        color: #0a84ff;
      }
      button.secondary-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      button:disabled {
        cursor: not-allowed;
      }
      .muted {
        opacity: 0.75;
      }
      .page-content {
        max-width: 960px;
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }
      .page-header {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      .back-link {
        width: fit-content;
        font-weight: 600;
        text-decoration: none;
      }
      .back-link:hover,
      .back-link:focus-visible {
        text-decoration: underline;
      }
      .tab-container {
        display: flex;
        flex-direction: column;
        gap: 1.25rem;
      }
      .tab-list {
        display: inline-flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        padding: 0.35rem;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.06);
      }
      .tab-button {
        border: none;
        background: transparent;
        color: rgba(245, 245, 245, 0.7);
        border-radius: 999px;
        padding: 0.45rem 1rem;
        font-size: 0.95rem;
        font-weight: 600;
        transition: background 0.2s ease, color 0.2s ease;
      }
      .tab-button[aria-selected="true"] {
        background: #0a84ff;
        color: #fff;
        box-shadow: 0 0 0 1px rgba(10, 132, 255, 0.3);
      }
      .tab-button:hover,
      .tab-button:focus-visible {
        color: #fff;
      }
      .tab-button:focus-visible {
        outline: 2px solid rgba(255, 255, 255, 0.7);
        outline-offset: 2px;
      }
      .tab-panel {
        display: none;
        flex-direction: column;
        gap: 1.5rem;
      }
      .tab-panel:not([hidden]) {
        display: flex;
      }
      .card {
        padding: 1.5rem;
        border-radius: 16px;
        background: rgba(255, 255, 255, 0.04);
      }
      #stream-section h2 {
        margin-top: 0;
      }
      #stream-summary {
        margin: 0;
        opacity: 0.85;
      }
      #stream-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-top: 0.75rem;
      }
      #stream-url {
        display: block;
        margin-top: 0.75rem;
        padding: 0.6rem 0.75rem;
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.35);
        font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        word-break: break-all;
      }
      #orientation-form {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      #orientation-form h2,
      #orientation-form h3 {
        margin-top: 0;
      }
      .form-actions {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        flex-wrap: wrap;
      }
      #status {
        font-size: 0.95rem;
        opacity: 0.85;
      }
      #wifi-section h2,
      #wifi-section h3 {
        margin-top: 0;
      }
      #wifi-summary {
        margin: 0 0 0.75rem;
        opacity: 0.85;
      }
      #wifi-controls {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 0.75rem;
        margin-bottom: 0.75rem;
      }
      #wifi-controls label {
        margin: 0;
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.95rem;
      }
      #wifi-feedback {
        min-height: 1.2rem;
        font-size: 0.9rem;
        opacity: 0.85;
      }
      #wifi-feedback.error {
        color: #ff6b6b;
        opacity: 1;
      }
      #wifi-network-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      .wifi-network {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
        padding: 0.85rem 1rem;
        border-radius: 12px;
        background: rgba(0, 0, 0, 0.35);
      }
      .wifi-network strong {
        display: block;
        font-size: 1rem;
      }
      .wifi-network span {
        font-size: 0.9rem;
        opacity: 0.8;
      }
      .wifi-network .actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }
      #wifi-connect-form {
        margin-top: 1rem;
        padding: 1rem;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.05);
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }
      #wifi-connect-form[hidden] {
        display: none;
      }
      #wifi-hotspot-section {
        margin-top: 1.5rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }
      #wifi-hotspot-section .button-group {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }
      .battery-card {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 1.5rem;
      }
      #battery-indicator {
        display: inline-flex;
        align-items: center;
        gap: 1rem;
        padding: 0.5rem 0.75rem;
        border-radius: 12px;
        background: rgba(0, 0, 0, 0.35);
        min-width: 200px;
      }
      .battery-icon {
        position: relative;
        display: inline-flex;
        align-items: center;
        justify-content: flex-start;
        width: 52px;
        height: 24px;
        padding: 2px;
        border-radius: 6px;
        border: 2px solid currentColor;
        color: #0a84ff;
      }
      .battery-icon::after {
        content: "";
        position: absolute;
        right: -6px;
        top: 50%;
        transform: translateY(-50%);
        width: 4px;
        height: 12px;
        border-radius: 4px;
        background: currentColor;
      }
      .battery-level {
        display: block;
        height: 100%;
        border-radius: 4px;
        background: currentColor;
        width: 0%;
        transition: width 0.3s ease;
      }
      .battery-icon.low {
        color: #ff9f0a;
      }
      .battery-icon.charging {
        color: #30d158;
      }
      .battery-icon.unavailable {
        color: rgba(245, 245, 245, 0.4);
      }
      #battery-status {
        display: flex;
        flex-direction: column;
        gap: 0.2rem;
      }
      #battery-text {
        font-size: 1.2rem;
        font-weight: 600;
      }
      #battery-details {
        font-size: 0.95rem;
        opacity: 0.8;
      }
      .battery-metrics {
        display: grid;
        gap: 1rem;
        flex: 1 1 260px;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      }
      .battery-metrics div {
        background: rgba(255, 255, 255, 0.03);
        padding: 0.75rem;
        border-radius: 12px;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }
      .battery-metrics dt {
        font-size: 0.85rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        opacity: 0.7;
      }
      .battery-metrics dd {
        margin: 0;
        font-size: 1rem;
        font-weight: 600;
      }
      .battery-actions {
        display: flex;
        gap: 0.5rem;
        margin-top: 1.25rem;
      }
      .battery-note {
        font-size: 0.9rem;
        opacity: 0.75;
        margin-top: 0.75rem;
      }
      .distance-readout {
        display: flex;
        flex-wrap: wrap;
        align-items: baseline;
        gap: 0.75rem;
        margin: 0.5rem 0 0;
      }
      .distance-value {
        font-size: 2.4rem;
        font-weight: 700;
        letter-spacing: -0.02em;
      }
      .distance-zone {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border-radius: 999px;
        padding: 0.25rem 0.85rem;
        font-size: 0.75rem;
        font-weight: 700;
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }
      .zone-badge.clear {
        color: #30d158;
        background: rgba(48, 209, 88, 0.18);
      }
      .zone-badge.caution {
        color: #ffd60a;
        background: rgba(255, 214, 10, 0.18);
      }
      .zone-badge.warning {
        color: #ff9f0a;
        background: rgba(255, 159, 10, 0.18);
      }
      .zone-badge.danger {
        color: #ff453a;
        background: rgba(255, 69, 58, 0.2);
      }
      .zone-badge.unavailable {
        color: rgba(245, 245, 245, 0.7);
        background: rgba(245, 245, 245, 0.12);
      }
      .distance-actions {
        margin-top: 1rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }
      .distance-error {
        margin: 0.75rem 0 0;
        min-height: 1rem;
      }
      #distance-zones-status {
        font-size: 0.9rem;
      }
      #battery-limits-status {
        font-size: 0.9rem;
      }
      @media (max-width: 640px) {
        body {
          padding: 1.5rem 1rem 2.5rem;
        }
        .card {
          padding: 1.25rem;
        }
        #battery-indicator {
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <div class="page-content">
      <header class="page-header">
        <a class="back-link" href="/">← Back to live view</a>
        <h1>Settings</h1>
        <p id="app-version" class="muted">
          Version <span id="version-value">Loading…</span>
        </p>
      </header>

      <div class="tab-container">
        <div class="tab-list" role="tablist" aria-label="Settings sections">
          <button
            type="button"
            class="tab-button"
            role="tab"
            id="tab-camera"
            aria-controls="panel-camera"
            aria-selected="true"
            data-tab="camera"
            tabindex="0"
          >
            Camera
          </button>
          <button
            type="button"
            class="tab-button"
            role="tab"
            id="tab-distance"
            aria-controls="panel-distance"
            aria-selected="false"
            data-tab="distance"
            tabindex="-1"
          >
            Distance
          </button>
          <button
            type="button"
            class="tab-button"
            role="tab"
            id="tab-network"
            aria-controls="panel-network"
            aria-selected="false"
            data-tab="network"
            tabindex="-1"
          >
            Network
          </button>
          <button
            type="button"
            class="tab-button"
            role="tab"
            id="tab-battery"
            aria-controls="panel-battery"
            aria-selected="false"
            data-tab="battery"
            tabindex="-1"
          >
            Battery
          </button>
        </div>

        <section
          id="panel-camera"
          class="tab-panel"
          role="tabpanel"
          aria-labelledby="tab-camera"
          data-tab="camera"
        >
          <section id="stream-section" class="card">
            <h2>Streaming</h2>
            <p id="stream-summary">Loading…</p>
            <div id="stream-actions">
              <a
                id="open-stream"
                class="button-link disabled"
                href="/stream/mjpeg"
                target="_blank"
                rel="noopener"
                aria-disabled="true"
                >Open MJPEG stream</a
              >
              <button type="button" id="copy-stream-url" class="secondary-button" disabled>
                Copy stream URL
              </button>
            </div>
            <code id="stream-url">—</code>
          </section>

          <form id="orientation-form" class="card">
            <h2>Camera configuration</h2>
            <label>
              Camera source
              <select name="camera"></select>
            </label>
            <label>
              Resolution
              <select name="resolution"></select>
            </label>
            <h3>Orientation</h3>
            <label>
              Rotation
              <select name="rotation">
                <option value="0">0°</option>
                <option value="90">90°</option>
                <option value="180">180°</option>
                <option value="270">270°</option>
              </select>
            </label>
            <label>
              <input type="checkbox" name="flip_horizontal" /> Flip horizontally
            </label>
            <label>
              <input type="checkbox" name="flip_vertical" /> Flip vertically
            </label>
            <div class="form-actions">
              <button type="submit">Save settings</button>
              <div id="status">Loading…</div>
            </div>
          </form>
        </section>

        <section
          id="panel-distance"
          class="tab-panel"
          role="tabpanel"
          aria-labelledby="tab-distance"
          data-tab="distance"
          hidden
        >
          <section class="card">
            <h2>Distance sensor</h2>
            <p id="distance-summary" class="muted">Distance readings are unavailable.</p>
            <div class="distance-readout" id="distance-readout">
              <span class="distance-value" id="distance-value">—</span>
              <span class="distance-zone zone-badge unavailable" id="distance-zone">N/A</span>
            </div>
            <p id="distance-error" class="distance-error muted"></p>
            <div class="distance-actions">
              <button type="button" id="distance-refresh" class="secondary-button">
                Refresh reading
              </button>
            </div>
          </section>

          <form id="distance-zones-form" class="card">
            <h2>Warning zones</h2>
            <p class="muted">
              Set the thresholds for each warning zone. Distances are measured in metres.
            </p>
            <label>
              Caution threshold (m)
              <input
                type="number"
                name="caution"
                min="0.1"
                max="10"
                step="0.1"
                inputmode="decimal"
              />
            </label>
            <label>
              Warning threshold (m)
              <input
                type="number"
                name="warning"
                min="0.1"
                max="10"
                step="0.1"
                inputmode="decimal"
              />
            </label>
            <label>
              Danger threshold (m)
              <input
                type="number"
                name="danger"
                min="0.1"
                max="10"
                step="0.1"
                inputmode="decimal"
              />
            </label>
            <div class="form-actions">
              <button type="submit">Save warning zones</button>
              <span id="distance-zones-status" class="muted"></span>
            </div>
          </form>
        </section>

        <section
          id="panel-network"
          class="tab-panel"
          role="tabpanel"
          aria-labelledby="tab-network"
          data-tab="network"
          hidden
        >
          <section id="wifi-section" class="card">
            <h2>Wi-Fi</h2>
            <p id="wifi-summary">Loading…</p>
            <div id="wifi-controls">
              <button type="button" id="wifi-refresh" class="secondary-button">Refresh status</button>
              <button type="button" id="wifi-scan">Scan networks</button>
              <label>
                <input type="checkbox" id="wifi-dev-mode" /> Development mode (auto-rollback)
              </label>
            </div>
            <div id="wifi-feedback" role="status" aria-live="polite"></div>
            <ul id="wifi-network-list"></ul>
            <form id="wifi-connect-form" hidden>
              <h3 style="margin: 0;">Connect to network</h3>
              <p id="wifi-connect-selected" style="margin: 0; opacity: 0.85;"></p>
              <input type="hidden" name="ssid" />
              <label>
                Password
                <input type="password" name="password" autocomplete="current-password" />
              </label>
              <label>
                Rollback timeout (seconds)
                <input type="number" name="rollback" min="5" max="180" step="5" value="30" />
              </label>
              <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                <button type="submit">Connect</button>
                <button type="button" id="wifi-cancel-connect" class="secondary-button">Cancel</button>
              </div>
            </form>
            <section id="wifi-hotspot-section">
              <h3>Hotspot</h3>
              <p class="muted" style="margin: 0 0 0.5rem;">
                Development mode auto-rollback applies when enabling the hotspot.
              </p>
              <p id="wifi-hotspot-status" style="margin: 0; opacity: 0.85;">Hotspot disabled.</p>
              <label>
                Hotspot name
                <input type="text" id="wifi-hotspot-ssid" placeholder="RevCam Hotspot" autocomplete="ssid" />
              </label>
              <label>
                Hotspot password
                <input
                  type="password"
                  id="wifi-hotspot-password"
                  placeholder="Optional (min 8 characters)"
                  autocomplete="new-password"
                />
              </label>
              <div class="button-group">
                <button type="button" id="wifi-enable-hotspot">Enable hotspot</button>
                <button type="button" id="wifi-disable-hotspot" class="secondary-button">Disable hotspot</button>
              </div>
            </section>
          </section>
        </section>

        <section
          id="panel-battery"
          class="tab-panel"
          role="tabpanel"
          aria-labelledby="tab-battery"
          data-tab="battery"
          hidden
        >
          <section class="card">
            <h2>Battery status</h2>
            <p id="battery-summary" class="muted">Battery readings are unavailable until refreshed.</p>
            <div class="battery-card">
              <div id="battery-indicator" aria-live="polite" aria-label="Battery unavailable">
                <span class="battery-icon unavailable" id="battery-icon" aria-hidden="true">
                  <span class="battery-level" id="battery-level"></span>
                </span>
                <div id="battery-status">
                  <span id="battery-text">—%</span>
                  <span id="battery-details">Battery unavailable</span>
                </div>
              </div>
              <dl class="battery-metrics">
                <div>
                  <dt>Status</dt>
                  <dd id="battery-state">Unavailable</dd>
                </div>
                <div>
                  <dt>Voltage</dt>
                  <dd id="battery-voltage">—</dd>
                </div>
                <div>
                  <dt>Current</dt>
                  <dd id="battery-current">—</dd>
                </div>
                <div>
                  <dt>Capacity</dt>
                  <dd id="battery-capacity">—</dd>
                </div>
              </dl>
            </div>
            <div class="battery-actions">
              <button type="button" id="battery-refresh" class="secondary-button">Refresh battery status</button>
            </div>
            <p class="battery-note">
              Battery data is shown when an INA219 sensor is connected.
              The system will shut down automatically when the battery falls below the
              configured shutdown threshold.
            </p>
          </section>
          <form id="battery-limits-form" class="card">
            <h2>Battery settings</h2>
            <p class="muted">
              Configure the warning and shutdown thresholds used for on-screen alerts and automatic
              shutdown, and the capacity of the connected battery pack.
            </p>
            <label>
              Battery capacity (mAh)
              <input
                type="number"
                name="capacity_mah"
                min="50"
                max="200000"
                step="50"
                inputmode="numeric"
              />
            </label>
            <label>
              Warning threshold (%)
              <input
                type="number"
                name="warning_percent"
                min="0"
                max="100"
                step="0.5"
                inputmode="decimal"
              />
            </label>
            <label>
              Shutdown threshold (%)
              <input
                type="number"
                name="shutdown_percent"
                min="0"
                max="100"
                step="0.5"
                inputmode="decimal"
              />
            </label>
            <div class="form-actions">
              <button type="submit">Save battery settings</button>
              <span id="battery-limits-status" class="muted"></span>
            </div>
          </form>
        </section>
      </div>
    </div>
    <script>
      const tabButtons = Array.from(document.querySelectorAll('.tab-button[role="tab"]'));
      const tabPanels = Array.from(document.querySelectorAll('.tab-panel[role="tabpanel"]'));
      const availableTabs = tabButtons
        .map((button) => button.dataset.tab)
        .filter((value) => typeof value === "string" && value.length > 0);
      const DISTANCE_ZONE_LABELS = {
        danger: "Danger",
        warning: "Warning",
        caution: "Caution",
        clear: "Clear",
        unavailable: "Unavailable",
      };
      const distanceSummary = document.getElementById("distance-summary");
      const distanceValue = document.getElementById("distance-value");
      const distanceZone = document.getElementById("distance-zone");
      const distanceError = document.getElementById("distance-error");
      const distanceRefreshButton = document.getElementById("distance-refresh");
      const distanceZonesForm = document.getElementById("distance-zones-form");
      const distanceZonesStatus = document.getElementById("distance-zones-status");
      const distanceInputs = distanceZonesForm
        ? {
            caution: distanceZonesForm.querySelector('input[name="caution"]'),
            warning: distanceZonesForm.querySelector('input[name="warning"]'),
            danger: distanceZonesForm.querySelector('input[name="danger"]'),
          }
        : null;
      let distanceLoading = false;
      if (distanceInputs) {
        for (const input of Object.values(distanceInputs)) {
          if (input instanceof HTMLInputElement) {
            input.addEventListener("input", () => {
              input.dataset.userEdited = "true";
              if (distanceZonesStatus) {
                distanceZonesStatus.textContent = "";
              }
            });
          }
        }
      }
      const batterySummary = document.getElementById("battery-summary");
      const batteryRefreshButton = document.getElementById("battery-refresh");
      const batteryIndicator = document.getElementById("battery-indicator");
      const batteryIcon = document.getElementById("battery-icon");
      const batteryLevel = document.getElementById("battery-level");
      const batteryText = document.getElementById("battery-text");
      const batteryDetails = document.getElementById("battery-details");
      const batteryState = document.getElementById("battery-state");
      const batteryVoltage = document.getElementById("battery-voltage");
      const batteryCurrent = document.getElementById("battery-current");
      const batteryCapacity = document.getElementById("battery-capacity");
      const batteryLimitsForm = document.getElementById("battery-limits-form");
      const batteryLimitsStatus = document.getElementById("battery-limits-status");
      const batteryLimitsInputs = batteryLimitsForm
        ? {
            capacity: batteryLimitsForm.querySelector('input[name="capacity_mah"]'),
            warning: batteryLimitsForm.querySelector('input[name="warning_percent"]'),
            shutdown: batteryLimitsForm.querySelector('input[name="shutdown_percent"]'),
          }
        : null;
      const batteryLimitsSubmit = batteryLimitsForm
        ? batteryLimitsForm.querySelector('button[type="submit"]')
        : null;
      let batteryLoading = false;
      let batteryLimitsLoaded = false;
      let batteryLimitsLoading = false;
      let batteryLimitsStatusTimer = null;
      if (batteryLimitsInputs) {
        for (const input of Object.values(batteryLimitsInputs)) {
          if (input instanceof HTMLInputElement) {
            input.addEventListener("input", () => {
              input.dataset.userEdited = "true";
              if (batteryLimitsStatus) {
                batteryLimitsStatus.textContent = "";
              }
              if (batteryLimitsStatusTimer) {
                clearTimeout(batteryLimitsStatusTimer);
                batteryLimitsStatusTimer = null;
              }
            });
          }
        }
      }
      const form = document.getElementById("orientation-form");
      const statusLabel = document.getElementById("status");
      const versionValue = document.getElementById("version-value");
      const cameraLabels = new Map();
      const resolutionLabels = new Map();
      const streamSection = document.getElementById("stream-section");
      const streamSummary = document.getElementById("stream-summary");
      const streamUrlElement = document.getElementById("stream-url");
      const openStreamLink = document.getElementById("open-stream");
      const copyStreamButton = document.getElementById("copy-stream-url");
      const copyButtonDefault = copyStreamButton ? copyStreamButton.textContent : "";
      let copyResetTimer = null;
      const wifiSummary = document.getElementById("wifi-summary");
      const wifiRefreshButton = document.getElementById("wifi-refresh");
      const wifiScanButton = document.getElementById("wifi-scan");
      const wifiFeedback = document.getElementById("wifi-feedback");
      const wifiNetworkList = document.getElementById("wifi-network-list");
      const wifiConnectForm = document.getElementById("wifi-connect-form");
      const wifiConnectSelected = document.getElementById("wifi-connect-selected");
      const wifiDevToggle = document.getElementById("wifi-dev-mode");
      const wifiCancelConnect = document.getElementById("wifi-cancel-connect");
      const wifiHotspotStatus = document.getElementById("wifi-hotspot-status");
      const wifiHotspotSsid = document.getElementById("wifi-hotspot-ssid");
      const wifiHotspotPassword = document.getElementById("wifi-hotspot-password");
      const wifiEnableHotspot = document.getElementById("wifi-enable-hotspot");
      const wifiDisableHotspot = document.getElementById("wifi-disable-hotspot");
      const wifiConnectSsidInput = wifiConnectForm
        ? wifiConnectForm.querySelector('input[name="ssid"]')
        : null;
      const wifiConnectPasswordInput = wifiConnectForm
        ? wifiConnectForm.querySelector('input[name="password"]')
        : null;
      const wifiRollbackInput = wifiConnectForm
        ? wifiConnectForm.querySelector('input[name="rollback"]')
        : null;
      const HOTSPOT_HOSTNAME = "motion.local";
      const HOTSPOT_DEV_ROLLBACK_DEFAULT = 120;

      function formatDistance(value) {
        if (typeof value !== "number" || Number.isNaN(value)) {
          return "—";
        }
        return `${Math.max(0, value).toFixed(1)} m`;
      }

      function updateDistanceBadge(zoneName) {
        if (!distanceZone) {
          return;
        }
        const valid = new Set(["danger", "warning", "caution", "clear"]);
        const zoneKey =
          typeof zoneName === "string" && valid.has(zoneName.toLowerCase())
            ? zoneName.toLowerCase()
            : "unavailable";
        distanceZone.className = `distance-zone zone-badge ${zoneKey}`;
        const label = DISTANCE_ZONE_LABELS[zoneKey] || DISTANCE_ZONE_LABELS.unavailable;
        distanceZone.textContent = label.toUpperCase();
      }

      function updateDistanceInputs(zones, forceUpdate = false) {
        if (!zones || !distanceInputs) {
          return;
        }
        const keys = ["caution", "warning", "danger"];
        for (const key of keys) {
          const input = distanceInputs[key];
          if (!(input instanceof HTMLInputElement)) {
            continue;
          }
          if (!forceUpdate && input.dataset.userEdited === "true") {
            continue;
          }
          const value = zones[key];
          if (typeof value === "number" && Number.isFinite(value)) {
            input.value = value.toFixed(1);
          } else {
            input.value = "";
          }
          delete input.dataset.userEdited;
        }
      }

      function updateDistanceSummary(data) {
        if (!distanceSummary) {
          return;
        }
        if (
          !data ||
          data.available !== true ||
          typeof data.distance_m !== "number" ||
          Number.isNaN(data.distance_m)
        ) {
          const fallback =
            data && typeof data.error === "string" && data.error.trim()
              ? data.error.trim()
              : "Distance sensor unavailable.";
          distanceSummary.textContent = fallback;
          return;
        }
        const zoneKey =
          typeof data.zone === "string" ? data.zone.toLowerCase() : "clear";
        const label = DISTANCE_ZONE_LABELS[zoneKey] || DISTANCE_ZONE_LABELS.clear;
        distanceSummary.textContent = `${formatDistance(data.distance_m)} • ${label}`;
      }

      function applyDistanceData(data, options = {}) {
        if (distanceValue) {
          if (
            data &&
            data.available === true &&
            typeof data.distance_m === "number" &&
            Number.isFinite(data.distance_m)
          ) {
            distanceValue.textContent = formatDistance(data.distance_m);
          } else {
            distanceValue.textContent = "—";
          }
        }
        const zoneKey = data && typeof data.zone === "string" ? data.zone.toLowerCase() : null;
        updateDistanceBadge(zoneKey);
        updateDistanceSummary(data);
        if (distanceError) {
          const message = data && typeof data.error === "string" ? data.error.trim() : "";
          distanceError.textContent = message;
          distanceError.classList.toggle("muted", !message);
        }
        if (data && data.zones) {
          updateDistanceInputs(data.zones, options.updateInputs === true);
        }
      }

      async function refreshDistanceReading(showLoading = false) {
        if (distanceLoading) {
          return;
        }
        distanceLoading = true;
        if (showLoading && distanceSummary) {
          distanceSummary.textContent = "Refreshing distance…";
        }
        if (distanceRefreshButton) {
          distanceRefreshButton.disabled = true;
        }
        try {
          const response = await fetch("/api/distance", { cache: "no-store" });
          if (!response.ok) {
            throw new Error(`Distance request failed with status ${response.status}`);
          }
          const payload = await response.json();
          applyDistanceData(payload);
        } catch (error) {
          console.error("Distance status error", error);
          applyDistanceData({ available: false, error: "Unable to load distance reading." });
        } finally {
          distanceLoading = false;
          if (distanceRefreshButton) {
            distanceRefreshButton.disabled = false;
          }
        }
      }

      function getTabFromHash(hash) {
        if (typeof hash !== "string" || !hash) {
          return null;
        }
        const value = hash.replace(/^#/, "").trim();
        if (!value) {
          return null;
        }
        return availableTabs.includes(value) ? value : null;
      }

      function updateBatteryIndicator(data) {
        if (!batteryIcon || !batteryLevel || !batteryText || !batteryDetails) {
          return;
        }
        batteryIcon.classList.remove("low", "charging", "unavailable");
        if (
          !data ||
          data.available !== true ||
          typeof data.percentage !== "number" ||
          Number.isNaN(data.percentage)
        ) {
          batteryIcon.classList.add("unavailable");
          batteryLevel.style.width = "0%";
          batteryText.textContent = "—";
          const fallback =
            data && typeof data.error === "string" && data.error.trim()
              ? data.error.trim()
              : "Battery unavailable";
          batteryDetails.textContent = fallback;
          if (batteryIndicator) {
            batteryIndicator.setAttribute("aria-label", fallback);
          }
          return;
        }
        const percentage = Math.max(0, Math.min(100, Number(data.percentage)));
        const rounded = Math.round(percentage);
        batteryLevel.style.width = `${percentage}%`;
        batteryText.textContent = `${rounded}%`;
        if (data.charging === true) {
          batteryIcon.classList.add("charging");
        } else if (percentage <= 20) {
          batteryIcon.classList.add("low");
        }
        const detailParts = [];
        if (typeof data.voltage === "number" && Number.isFinite(data.voltage)) {
          detailParts.push(`${data.voltage.toFixed(2)} V`);
        }
        if (typeof data.current_ma === "number" && Number.isFinite(data.current_ma)) {
          const magnitude = Math.abs(data.current_ma);
          const decimals = magnitude >= 100 ? 0 : magnitude >= 10 ? 1 : 2;
          const formatted = magnitude.toFixed(decimals);
          const suffix = data.charging === true ? "charging" : "draw";
          detailParts.push(`${formatted} mA ${suffix}`);
        } else if (data.charging === true) {
          detailParts.push("Charging");
        }
        const detailText = detailParts.join(" · ") || "Battery OK";
        batteryDetails.textContent = detailText;
        if (batteryIndicator) {
          batteryIndicator.setAttribute(
            "aria-label",
            `Battery ${rounded}%, ${detailParts.join(", ") || "status"}`,
          );
        }
      }

      function updateBatteryMetrics(data) {
        if (batteryState) {
          if (!data || data.available !== true) {
            const fallback =
              data && typeof data.error === "string" && data.error.trim()
                ? data.error.trim()
                : "Unavailable";
            batteryState.textContent = fallback;
          } else if (data.charging === true) {
            batteryState.textContent = "Charging";
          } else if (data.charging === false) {
            batteryState.textContent = "On battery power";
          } else {
            batteryState.textContent = "Status unknown";
          }
        }
        if (batteryVoltage) {
          if (data && typeof data.voltage === "number" && Number.isFinite(data.voltage)) {
            batteryVoltage.textContent = `${data.voltage.toFixed(2)} V`;
          } else {
            batteryVoltage.textContent = "—";
          }
        }
        if (batteryCurrent) {
          if (data && typeof data.current_ma === "number" && Number.isFinite(data.current_ma)) {
            const magnitude = Math.abs(data.current_ma);
            const decimals = magnitude >= 100 ? 0 : magnitude >= 10 ? 1 : 2;
            const formatted = magnitude.toFixed(decimals);
            const suffix = data && data.charging === true ? "charging" : "draw";
            batteryCurrent.textContent = `${formatted} mA ${suffix}`;
          } else if (data && data.charging === true) {
            batteryCurrent.textContent = "Charging";
          } else {
            batteryCurrent.textContent = "—";
          }
        }
        if (batteryCapacity) {
          if (data && typeof data.capacity_mah === "number" && Number.isFinite(data.capacity_mah)) {
            batteryCapacity.textContent = `${Math.round(data.capacity_mah)} mAh`;
          } else {
            batteryCapacity.textContent = "—";
          }
        }
      }

      function updateBatterySummary(data) {
        if (!batterySummary) {
          return;
        }
        if (
          !data ||
          data.available !== true ||
          typeof data.percentage !== "number" ||
          Number.isNaN(data.percentage)
        ) {
          const fallback =
            data && typeof data.error === "string" && data.error.trim()
              ? data.error.trim()
              : "Battery sensor unavailable.";
          batterySummary.textContent = fallback;
          return;
        }
        const percentage = Math.max(0, Math.min(100, Number(data.percentage)));
        const rounded = Math.round(percentage);
        const pieces = [`${rounded}% charged`];
        if (typeof data.voltage === "number" && Number.isFinite(data.voltage)) {
          pieces.push(`${data.voltage.toFixed(2)} V`);
        }
        if (typeof data.current_ma === "number" && Number.isFinite(data.current_ma)) {
          const magnitude = Math.abs(data.current_ma);
          const decimals = magnitude >= 100 ? 0 : magnitude >= 10 ? 1 : 2;
          const formatted = magnitude.toFixed(decimals);
          const suffix = data.charging === true ? "charging" : "draw";
          pieces.push(`${formatted} mA ${suffix}`);
        } else if (data.charging === true) {
          pieces.push("Charging");
        }
        if (
          typeof data.capacity_mah === "number" &&
          Number.isFinite(data.capacity_mah) &&
          data.capacity_mah > 0
        ) {
          pieces.push(`${Math.round(data.capacity_mah)} mAh pack`);
        }
        batterySummary.textContent = pieces.join(" • ");
      }

      function applyBatteryReading(data) {
        updateBatteryIndicator(data);
        updateBatteryMetrics(data);
        updateBatterySummary(data);
      }

      async function refreshBatteryStatus(showLoading = false) {
        if (!batteryIndicator) {
          return;
        }
        if (batteryLoading) {
          return;
        }
        batteryLoading = true;
        if (showLoading && batterySummary) {
          batterySummary.textContent = "Refreshing battery status…";
        }
        if (batteryRefreshButton) {
          batteryRefreshButton.disabled = true;
        }
        try {
          const response = await fetch("/api/battery", { cache: "no-store" });
          if (!response.ok) {
            throw new Error(`Battery request failed with status ${response.status}`);
          }
          const payload = await response.json();
          applyBatteryReading(payload);
        } catch (error) {
          console.error("Battery status error", error);
          applyBatteryReading({ available: false, error: "Unable to load battery status." });
        } finally {
          batteryLoading = false;
          if (batteryRefreshButton) {
            batteryRefreshButton.disabled = false;
          }
        }
      }

      function updateBatteryLimitsInputs(limits, options = {}) {
        if (!batteryLimitsInputs) {
          return;
        }
        const { force = false, clearUserEdited = false } = options;
        const entries = [
          ["capacity_mah", batteryLimitsInputs.capacity],
          ["warning_percent", batteryLimitsInputs.warning],
          ["shutdown_percent", batteryLimitsInputs.shutdown],
        ];
        for (const [property, input] of entries) {
          if (!(input instanceof HTMLInputElement)) {
            continue;
          }
          if (!force && input.dataset.userEdited === "true") {
            continue;
          }
          let rawValue = undefined;
          if (limits && typeof limits === "object" && property in limits) {
            const candidate = limits[property];
            if (typeof candidate === "number") {
              rawValue = candidate;
            } else if (typeof candidate === "string") {
              const parsed = Number.parseFloat(candidate);
              rawValue = Number.isFinite(parsed) ? parsed : undefined;
            }
          }
          if (typeof rawValue === "number" && Number.isFinite(rawValue)) {
            const displayValue =
              property === "capacity_mah" ? Math.round(rawValue) : rawValue;
            input.value = displayValue.toString();
            if (property === "capacity_mah" && batteryCapacity) {
              batteryCapacity.textContent = `${Math.round(displayValue)} mAh`;
            }
          } else {
            input.value = "";
            if (property === "capacity_mah" && batteryCapacity) {
              batteryCapacity.textContent = "—";
            }
          }
          if (clearUserEdited) {
            delete input.dataset.userEdited;
          }
        }
      }

      async function loadBatteryLimits({ showLoading = false, force = false } = {}) {
        if (!batteryLimitsForm) {
          return;
        }
        if (batteryLimitsLoading) {
          return;
        }
        if (batteryLimitsLoaded && !force) {
          return;
        }
        batteryLimitsLoading = true;
        if (batteryLimitsStatusTimer) {
          clearTimeout(batteryLimitsStatusTimer);
          batteryLimitsStatusTimer = null;
        }
        if (batteryLimitsStatus && showLoading) {
          batteryLimitsStatus.textContent = "Loading battery settings…";
        }
        if (batteryLimitsSubmit) {
          batteryLimitsSubmit.disabled = true;
        }
        try {
          const response = await fetch("/api/battery/limits", { cache: "no-store" });
          if (!response.ok) {
            throw new Error(`Battery settings request failed with status ${response.status}`);
          }
          const payload = await response.json();
          updateBatteryLimitsInputs(payload, { force: true, clearUserEdited: true });
          batteryLimitsLoaded = true;
          if (batteryLimitsStatus) {
            batteryLimitsStatus.textContent = "";
          }
        } catch (error) {
          console.error("Battery limits load error", error);
          batteryLimitsLoaded = false;
          if (batteryLimitsStatus) {
            batteryLimitsStatus.textContent = "Unable to load battery settings.";
          }
        } finally {
          batteryLimitsLoading = false;
          if (batteryLimitsSubmit) {
            batteryLimitsSubmit.disabled = false;
          }
        }
      }

      function setActiveTab(tabName, { updateHash = true } = {}) {
        if (!availableTabs.length) {
          return;
        }
        const desired =
          typeof tabName === "string" && availableTabs.includes(tabName)
            ? tabName
            : availableTabs[0];
        for (const button of tabButtons) {
          const isActive = button.dataset.tab === desired;
          button.setAttribute("aria-selected", isActive ? "true" : "false");
          button.tabIndex = isActive ? 0 : -1;
        }
        for (const panel of tabPanels) {
          if (panel.dataset.tab === desired) {
            panel.removeAttribute("hidden");
          } else {
            panel.setAttribute("hidden", "");
          }
        }
        if (updateHash) {
          const desiredHash = `#${desired}`;
          try {
            if (window.location.hash !== desiredHash) {
              if (typeof window.history?.replaceState === "function") {
                window.history.replaceState(null, "", desiredHash);
              } else {
                window.location.hash = desiredHash;
              }
            }
          } catch (err) {
            console.error(err);
          }
        }
        if (desired === "battery") {
          refreshBatteryStatus().catch((err) => console.error(err));
          loadBatteryLimits({ showLoading: !batteryLimitsLoaded })
            .catch((err) => console.error(err));
        }
      }

      function focusTabByIndex(index) {
        if (!tabButtons.length) {
          return;
        }
        const total = tabButtons.length;
        const normalized = ((index % total) + total) % total;
        const button = tabButtons[normalized];
        if (!button) {
          return;
        }
        button.focus();
        const tabName = button.dataset.tab;
        if (typeof tabName === "string" && tabName) {
          setActiveTab(tabName);
        }
      }

      tabButtons.forEach((button, index) => {
        button.addEventListener("click", () => {
          const tabName = button.dataset.tab;
          if (typeof tabName === "string" && tabName) {
            setActiveTab(tabName);
          }
        });
        button.addEventListener("keydown", (event) => {
          switch (event.key) {
            case "ArrowRight":
            case "ArrowDown":
              event.preventDefault();
              focusTabByIndex(index + 1);
              break;
            case "ArrowLeft":
            case "ArrowUp":
              event.preventDefault();
              focusTabByIndex(index - 1);
              break;
            case "Home":
              event.preventDefault();
              focusTabByIndex(0);
              break;
            case "End":
              event.preventDefault();
              focusTabByIndex(tabButtons.length - 1);
              break;
            default:
              break;
          }
        });
      });

      if (distanceRefreshButton) {
        distanceRefreshButton.addEventListener("click", () => {
          refreshDistanceReading(true).catch((err) => console.error(err));
        });
      }

      if (distanceZonesForm) {
        distanceZonesForm.addEventListener("submit", async (event) => {
          event.preventDefault();
          if (!distanceInputs) {
            return;
          }
          if (distanceZonesStatus) {
            distanceZonesStatus.textContent = "Saving…";
          }
          const cautionInput = distanceInputs.caution;
          const warningInput = distanceInputs.warning;
          const dangerInput = distanceInputs.danger;
          const caution =
            cautionInput instanceof HTMLInputElement ? Number.parseFloat(cautionInput.value) : Number.NaN;
          const warning =
            warningInput instanceof HTMLInputElement ? Number.parseFloat(warningInput.value) : Number.NaN;
          const danger =
            dangerInput instanceof HTMLInputElement ? Number.parseFloat(dangerInput.value) : Number.NaN;
          if (!Number.isFinite(caution) || !Number.isFinite(warning) || !Number.isFinite(danger)) {
            if (distanceZonesStatus) {
              distanceZonesStatus.textContent = "Enter numeric thresholds for all zones.";
            }
            return;
          }
          if (caution <= 0 || warning <= 0 || danger <= 0) {
            if (distanceZonesStatus) {
              distanceZonesStatus.textContent = "Thresholds must be positive values.";
            }
            return;
          }
          if (!(caution >= warning && warning >= danger)) {
            if (distanceZonesStatus) {
              distanceZonesStatus.textContent = "Ensure caution ≥ warning ≥ danger.";
            }
            return;
          }
          try {
            const response = await fetch("/api/distance/zones", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ caution, warning, danger }),
            });
            if (!response.ok) {
              let errorDetail = "Unable to save warning zones.";
              try {
                const payload = await response.json();
                if (payload && typeof payload.detail === "string") {
                  errorDetail = payload.detail;
                }
              } catch (err) {
                console.error(err);
              }
              if (distanceZonesStatus) {
                distanceZonesStatus.textContent = errorDetail;
              }
              return;
            }
            const payload = await response.json();
            applyDistanceData(payload, { updateInputs: true });
            if (distanceZonesStatus) {
              distanceZonesStatus.textContent = "Warning zones saved";
              setTimeout(() => {
                if (distanceZonesStatus && distanceZonesStatus.textContent === "Warning zones saved") {
                  distanceZonesStatus.textContent = "";
                }
              }, 3000);
            }
          } catch (err) {
            console.error("Distance zone update error", err);
            if (distanceZonesStatus) {
              distanceZonesStatus.textContent = "Unable to save warning zones.";
            }
          }
        });
      }

      if (batteryRefreshButton) {
        batteryRefreshButton.addEventListener("click", () => {
          refreshBatteryStatus(true).catch((err) => console.error(err));
        });
      }

      if (batteryLimitsForm) {
        batteryLimitsForm.addEventListener("submit", async (event) => {
          event.preventDefault();
          if (!batteryLimitsInputs) {
            return;
          }
          const capacityInput = batteryLimitsInputs.capacity;
          const warningInput = batteryLimitsInputs.warning;
          const shutdownInput = batteryLimitsInputs.shutdown;
          const capacityValue =
            capacityInput instanceof HTMLInputElement
              ? Number.parseFloat(capacityInput.value)
              : Number.NaN;
          const warningValue =
            warningInput instanceof HTMLInputElement
              ? Number.parseFloat(warningInput.value)
              : Number.NaN;
          const shutdownValue =
            shutdownInput instanceof HTMLInputElement
              ? Number.parseFloat(shutdownInput.value)
              : Number.NaN;
          if (
            !Number.isFinite(capacityValue) ||
            !Number.isFinite(warningValue) ||
            !Number.isFinite(shutdownValue)
          ) {
            if (batteryLimitsStatus) {
              batteryLimitsStatus.textContent = "Enter numeric values for all battery settings.";
            }
            return;
          }
          const roundedCapacity = Math.round(capacityValue);
          if (roundedCapacity <= 0) {
            if (batteryLimitsStatus) {
              batteryLimitsStatus.textContent = "Capacity must be a positive number.";
            }
            return;
          }
          if (roundedCapacity < 50 || roundedCapacity > 200000) {
            if (batteryLimitsStatus) {
              batteryLimitsStatus.textContent = "Capacity must be between 50 and 200000 mAh.";
            }
            return;
          }
          if (warningValue < 0 || warningValue > 100 || shutdownValue < 0 || shutdownValue > 100) {
            if (batteryLimitsStatus) {
              batteryLimitsStatus.textContent = "Thresholds must be between 0% and 100%.";
            }
            return;
          }
          if (warningValue < shutdownValue) {
            if (batteryLimitsStatus) {
              batteryLimitsStatus.textContent = "Warning must be greater than or equal to shutdown.";
            }
            return;
          }
          if (batteryLimitsStatusTimer) {
            clearTimeout(batteryLimitsStatusTimer);
            batteryLimitsStatusTimer = null;
          }
          if (batteryLimitsStatus) {
            batteryLimitsStatus.textContent = "Saving…";
          }
          if (batteryLimitsSubmit) {
            batteryLimitsSubmit.disabled = true;
          }
          try {
            let payload = null;
            const limitsResponse = await fetch("/api/battery/limits", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                warning_percent: warningValue,
                shutdown_percent: shutdownValue,
              }),
            });
            if (!limitsResponse.ok) {
              let errorDetail = "Unable to save battery settings.";
              try {
                const problem = await limitsResponse.json();
                if (problem && typeof problem.detail === "string") {
                  errorDetail = problem.detail;
                }
              } catch (err) {
                console.error(err);
              }
              if (batteryLimitsStatus) {
                batteryLimitsStatus.textContent = errorDetail;
              }
              return;
            }
            payload = await limitsResponse.json();
            const capacityResponse = await fetch("/api/battery/capacity", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                capacity_mah: roundedCapacity,
              }),
            });
            if (!capacityResponse.ok) {
              let errorDetail = "Unable to save battery settings.";
              try {
                const problem = await capacityResponse.json();
                if (problem && typeof problem.detail === "string") {
                  errorDetail = problem.detail;
                }
              } catch (err) {
                console.error(err);
              }
              if (batteryLimitsStatus) {
                batteryLimitsStatus.textContent = errorDetail;
              }
              return;
            }
            payload = await capacityResponse.json();
            updateBatteryLimitsInputs(payload, { force: true, clearUserEdited: true });
            batteryLimitsLoaded = true;
            if (batteryLimitsStatus) {
              batteryLimitsStatus.textContent = "Battery settings saved";
              batteryLimitsStatusTimer = window.setTimeout(() => {
                if (
                  batteryLimitsStatus &&
                  batteryLimitsStatus.textContent === "Battery settings saved"
                ) {
                  batteryLimitsStatus.textContent = "";
                }
                batteryLimitsStatusTimer = null;
              }, 3000);
            }
            refreshBatteryStatus().catch((err) => console.error(err));
          } catch (err) {
            console.error("Battery settings update error", err);
            if (batteryLimitsStatus) {
              batteryLimitsStatus.textContent = "Unable to save battery settings.";
            }
          } finally {
            if (batteryLimitsSubmit) {
              batteryLimitsSubmit.disabled = false;
            }
          }
        });
      }

      if (availableTabs.length) {
        const initialTab = getTabFromHash(window.location.hash) || availableTabs[0];
        setActiveTab(initialTab, { updateHash: false });
      }

      window.addEventListener("hashchange", () => {
        const target = getTabFromHash(window.location.hash);
        if (target) {
          setActiveTab(target, { updateHash: false });
        }
      });

      function describeCameraErrors(camera) {
        if (!camera || !camera.errors) {
          return [];
        }
        const descriptions = [];
        const seen = new Set();
        for (const [source, detail] of Object.entries(camera.errors)) {
          if (!detail) {
            continue;
          }
          const label = cameraLabels.get(source) || source;
          const combined = `${label}: ${detail}`;
          const dedupeKey = detail.trim().toLowerCase();
          if (dedupeKey && seen.has(dedupeKey)) {
            continue;
          }
          if (dedupeKey) {
            seen.add(dedupeKey);
          }
          descriptions.push(combined);
        }
        return descriptions;
      }

      function formatSignalValue(signal) {
        if (typeof signal !== "number" || Number.isNaN(signal)) {
          return "—";
        }
        return `${signal}%`;
      }

      function summariseWifiStatus(status) {
        if (!status) {
          return "Wi-Fi status unavailable.";
        }
        const pieces = [];
        const name = status.ssid || status.profile || "network";
        if (status.hotspot_active) {
          pieces.push(`Hotspot active (${name})`);
          if (status.ip_address) {
            pieces.push(`IP ${status.ip_address}`);
          }
          pieces.push(`Visit http://${HOTSPOT_HOSTNAME}:9000/`);
        } else if (status.connected) {
          const signalText = formatSignalValue(status.signal);
          pieces.push(`Connected to ${name}${signalText !== "—" ? ` (${signalText})` : ""}`);
          if (status.ip_address) {
            pieces.push(`IP ${status.ip_address}`);
          }
        } else {
          pieces.push("Not connected to Wi-Fi.");
        }
        if (status.detail) {
          pieces.push(status.detail);
        }
        if (status.error) {
          pieces.push(`Error: ${status.error}`);
        }
        return pieces.join(" ");
      }

      function setWifiFeedback(message, isError = false) {
        if (!wifiFeedback) {
          return;
        }
        wifiFeedback.textContent = message || "";
        if (isError) {
          wifiFeedback.classList.add("error");
        } else {
          wifiFeedback.classList.remove("error");
        }
      }

      function hideWifiConnectForm() {
        if (!wifiConnectForm) {
          return;
        }
        wifiConnectForm.hidden = true;
        if (wifiConnectSelected) {
          wifiConnectSelected.textContent = "";
        }
        if (wifiConnectPasswordInput) {
          wifiConnectPasswordInput.value = "";
        }
      }

      function renderWifiNetworks(networks) {
        if (!wifiNetworkList) {
          return;
        }
        wifiNetworkList.innerHTML = "";
        if (!Array.isArray(networks) || networks.length === 0) {
          const empty = document.createElement("li");
          empty.className = "wifi-network";
          empty.textContent = "No Wi-Fi networks detected.";
          wifiNetworkList.appendChild(empty);
          return;
        }
        for (const network of networks) {
          const item = document.createElement("li");
          item.className = "wifi-network";
          const info = document.createElement("div");
          info.style.minWidth = "12rem";
          const name = document.createElement("strong");
          const ssid = typeof network.ssid === "string" && network.ssid.trim()
            ? network.ssid.trim()
            : "(hidden network)";
          name.textContent = ssid;
          info.appendChild(name);
          const details = document.createElement("span");
          const detailParts = [];
          if (typeof network.signal === "number" && !Number.isNaN(network.signal)) {
            detailParts.push(`${network.signal}%`);
          }
          if (network.security && typeof network.security === "string") {
            detailParts.push(network.security);
          }
          if (network.frequency) {
            const freqText = `${network.frequency} MHz`;
            if (network.channel) {
              detailParts.push(`${freqText} (ch ${network.channel})`);
            } else {
              detailParts.push(freqText);
            }
          }
          if (network.known) {
            detailParts.push("saved");
          }
          if (network.active) {
            detailParts.push("active");
          }
          details.textContent = detailParts.length ? detailParts.join(" • ") : "Details unavailable";
          info.appendChild(details);
          item.appendChild(info);
          const actions = document.createElement("div");
          actions.className = "actions";
          const connectButton = document.createElement("button");
          connectButton.type = "button";
          if (network.active) {
            connectButton.textContent = "Connected";
            connectButton.disabled = true;
          } else if (network.hidden) {
            connectButton.textContent = "Hidden network";
            connectButton.disabled = true;
          } else {
            connectButton.textContent = "Connect";
            connectButton.addEventListener("click", () => {
              if (!wifiConnectForm || !wifiConnectSsidInput || !wifiConnectSelected) {
                return;
              }
              wifiConnectForm.hidden = false;
              wifiConnectSsidInput.value = ssid;
              wifiConnectSelected.textContent = `Selected network: ${ssid}`;
              if (wifiConnectPasswordInput) {
                wifiConnectPasswordInput.value = "";
                wifiConnectPasswordInput.placeholder = network.security
                  ? `Security: ${network.security}`
                  : "Password (if required)";
              }
              if (wifiRollbackInput && typeof wifiRollbackInput.value === "string" && !wifiRollbackInput.value) {
                wifiRollbackInput.value = "30";
              }
            });
          }
          actions.appendChild(connectButton);
          item.appendChild(actions);
          wifiNetworkList.appendChild(item);
        }
      }

      async function refreshWifiStatus() {
        if (!wifiSummary) {
          return null;
        }
        try {
          const response = await fetch("/api/wifi/status");
          if (!response.ok) {
            throw new Error("Unable to fetch Wi-Fi status");
          }
          const status = await response.json();
          wifiSummary.textContent = summariseWifiStatus(status);
          if (wifiHotspotStatus) {
            if (status.hotspot_active) {
              const hotspotName = status.ssid || status.profile || "Hotspot";
              const pieces = [`Hotspot active (${hotspotName})`];
              if (status.ip_address) {
                pieces.push(`IP ${status.ip_address}`);
              }
              pieces.push(`Visit http://${HOTSPOT_HOSTNAME}:9000/`);
              wifiHotspotStatus.textContent = pieces.join(" • ");
            } else {
              wifiHotspotStatus.textContent = "Hotspot disabled.";
            }
          }
          if (status.detail) {
            setWifiFeedback(status.detail, false);
          } else if (!wifiFeedback || !wifiFeedback.textContent) {
            setWifiFeedback("", false);
          }
          return status;
        } catch (err) {
          console.error(err);
          if (wifiSummary) {
            const message = err instanceof Error ? err.message : "Wi-Fi status unavailable.";
            wifiSummary.textContent = message;
          }
          return null;
        }
      }

      async function scanWifiNetworks() {
        if (!wifiNetworkList) {
          return;
        }
        setWifiFeedback("Scanning for Wi-Fi networks…");
        try {
          const response = await fetch("/api/wifi/networks");
          if (!response.ok) {
            throw new Error("Unable to scan Wi-Fi networks");
          }
          const data = await response.json();
          const networks = Array.isArray(data.networks) ? data.networks : [];
          renderWifiNetworks(networks);
          if (networks.length) {
            setWifiFeedback(`Found ${networks.length} network${networks.length === 1 ? "" : "s"}.`);
          } else {
            setWifiFeedback("No Wi-Fi networks detected. Try scanning again.");
          }
        } catch (err) {
          console.error(err);
          setWifiFeedback("Unable to scan Wi-Fi networks.", true);
        }
      }

      async function connectToWifi() {
        if (!wifiConnectForm || !wifiConnectSsidInput) {
          return;
        }
        const ssid = wifiConnectSsidInput.value.trim();
        if (!ssid) {
          setWifiFeedback("Select a Wi-Fi network before connecting.", true);
          return;
        }
        const payload = {
          ssid,
          development_mode: wifiDevToggle ? !!wifiDevToggle.checked : false,
        };
        if (wifiConnectPasswordInput && wifiConnectPasswordInput.value) {
          payload.password = wifiConnectPasswordInput.value;
        }
        if (wifiRollbackInput) {
          const rollback = parseFloat(wifiRollbackInput.value);
          if (!Number.isNaN(rollback) && rollback > 0) {
            payload.rollback_seconds = rollback;
          }
        }
        setWifiFeedback(`Connecting to ${ssid}…`);
        try {
          const response = await fetch("/api/wifi/connect", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          if (!response.ok) {
            let errorDetail = "Unable to connect to Wi-Fi network.";
            try {
              const error = await response.json();
              if (error && error.detail) {
                errorDetail = error.detail;
              }
            } catch (parseErr) {
              console.error(parseErr);
            }
            setWifiFeedback(errorDetail, true);
            return;
          }
          const status = await response.json();
          const successMessage = status.detail
            ? status.detail
            : `Joined ${status.ssid || ssid}.`;
          setWifiFeedback(successMessage);
          hideWifiConnectForm();
          await refreshWifiStatus();
          await scanWifiNetworks();
        } catch (err) {
          console.error(err);
          setWifiFeedback("Connection attempt failed.", true);
        }
      }

      async function toggleHotspot(enabled) {
        let payload = { enabled };
        if (enabled) {
          const ssidValue = wifiHotspotSsid && typeof wifiHotspotSsid.value === "string"
            ? wifiHotspotSsid.value.trim()
            : "";
          const passwordValue = wifiHotspotPassword && typeof wifiHotspotPassword.value === "string"
            ? wifiHotspotPassword.value.trim()
            : "";
          if (passwordValue && passwordValue.length < 8) {
            setWifiFeedback("Hotspot password must contain at least 8 characters.", true);
            return;
          }
          const devModeEnabled = wifiDevToggle ? !!wifiDevToggle.checked : false;
          payload = {
            enabled: true,
            ssid: ssidValue || undefined,
            development_mode: devModeEnabled,
          };
          if (passwordValue) {
            payload.password = passwordValue;
          }
          let rollbackSeconds = null;
          let userProvidedRollback = NaN;
          if (wifiRollbackInput && wifiRollbackInput.dataset.userEdited === "true") {
            userProvidedRollback = parseFloat(wifiRollbackInput.value);
          }
          if (devModeEnabled) {
            if (!Number.isNaN(userProvidedRollback) && userProvidedRollback > 0) {
              rollbackSeconds = userProvidedRollback;
            } else {
              rollbackSeconds = HOTSPOT_DEV_ROLLBACK_DEFAULT;
            }
          } else if (!Number.isNaN(userProvidedRollback) && userProvidedRollback > 0) {
            rollbackSeconds = userProvidedRollback;
          }
          if (typeof rollbackSeconds === "number" && rollbackSeconds > 0) {
            payload.rollback_seconds = rollbackSeconds;
          }
          setWifiFeedback("Enabling hotspot…");
        } else {
          payload = { enabled: false };
          setWifiFeedback("Disabling hotspot…");
        }
        try {
          const response = await fetch("/api/wifi/hotspot", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          if (!response.ok) {
            let errorDetail = enabled ? "Unable to enable hotspot." : "Unable to disable hotspot.";
            try {
              const error = await response.json();
              if (error && error.detail) {
                errorDetail = error.detail;
              }
            } catch (parseErr) {
              console.error(parseErr);
            }
            setWifiFeedback(errorDetail, true);
            return;
          }
          const status = await response.json();
          const detailMessage = status.detail
            ? status.detail
            : enabled
            ? `Hotspot enabled. Connect via http://${HOTSPOT_HOSTNAME}:9000/.`
            : "Hotspot disabled.";
          setWifiFeedback(detailMessage);
          await refreshWifiStatus();
        } catch (err) {
          console.error(err);
          setWifiFeedback(enabled ? "Unable to enable hotspot." : "Unable to disable hotspot.", true);
        }
      }

      function updateVersion(camera) {
        if (!versionValue) {
          return;
        }
        const version = camera && camera.version ? String(camera.version).trim() : "";
        versionValue.textContent = version || "Unknown";
      }

      function updateStreamSection(camera) {
        if (!streamSection) {
          return;
        }
        const stream = camera && camera.stream ? camera.stream : null;
        if (copyStreamButton) {
          copyStreamButton.textContent = copyButtonDefault;
        }
        if (!stream || stream.enabled === false) {
          if (streamSummary) {
            const detail = stream && stream.error ? String(stream.error).trim() : "";
            streamSummary.textContent = detail
              ? `Streaming disabled: ${detail}`
              : "Streaming disabled.";
          }
          if (openStreamLink) {
            openStreamLink.classList.add("disabled");
            openStreamLink.setAttribute("aria-disabled", "true");
            openStreamLink.href = "/stream/mjpeg";
          }
          if (copyStreamButton) {
            copyStreamButton.disabled = true;
          }
          if (streamUrlElement) {
            streamUrlElement.textContent = "—";
          }
          return;
        }

        const endpoint = typeof stream.endpoint === "string" && stream.endpoint
          ? stream.endpoint
          : "/stream/mjpeg";
        const absoluteUrl = new URL(endpoint, window.location.origin).toString();
        const streamType = stream.content_type ? String(stream.content_type) : "MJPEG";
        if (streamSummary) {
          if (stream.error) {
            streamSummary.textContent = `Streaming issue: ${stream.error}`;
          } else {
            streamSummary.textContent = `Live stream ready (${streamType})`;
          }
        }
        if (openStreamLink) {
          openStreamLink.classList.remove("disabled");
          openStreamLink.removeAttribute("aria-disabled");
          openStreamLink.href = absoluteUrl;
        }
        if (copyStreamButton) {
          copyStreamButton.disabled = false;
        }
        if (streamUrlElement) {
          streamUrlElement.textContent = absoluteUrl;
        }
      }

      function resetCopyFeedback() {
        if (copyStreamButton) {
          copyStreamButton.textContent = copyButtonDefault;
        }
        copyResetTimer = null;
      }

      function applySettings(orientation, camera, message = "Settings loaded") {
        form.rotation.value = orientation.rotation;
        form.flip_horizontal.checked = orientation.flip_horizontal;
        form.flip_vertical.checked = orientation.flip_vertical;

        updateVersion(camera);
        updateStreamSection(camera);

        const cameraSelect = form.elements.namedItem("camera");
        if (!(cameraSelect instanceof HTMLSelectElement)) {
          throw new Error("Camera select element missing");
        }
        cameraSelect.innerHTML = "";
        cameraLabels.clear();
        for (const option of camera.options || []) {
          const opt = document.createElement("option");
          opt.value = option.value;
          opt.textContent = option.label;
          cameraSelect.appendChild(opt);
          cameraLabels.set(option.value, option.label);
        }
        if (camera.selected && cameraLabels.has(camera.selected)) {
          cameraSelect.value = camera.selected;
        }

        const resolutionSelect = form.elements.namedItem("resolution");
        if (!(resolutionSelect instanceof HTMLSelectElement)) {
          throw new Error("Resolution select element missing");
        }
        resolutionSelect.innerHTML = "";
        resolutionLabels.clear();
        const resolutionInfo = camera && camera.resolution ? camera.resolution : null;
        const resolutionOptions =
          resolutionInfo && Array.isArray(resolutionInfo.options) ? resolutionInfo.options : [];
        for (const option of resolutionOptions) {
          const opt = document.createElement("option");
          opt.value = option.value;
          opt.textContent = option.label;
          resolutionSelect.appendChild(opt);
          resolutionLabels.set(option.value, option.label);
        }
        if (
          resolutionInfo &&
          typeof resolutionInfo.selected === "string" &&
          resolutionLabels.has(resolutionInfo.selected)
        ) {
          resolutionSelect.value = resolutionInfo.selected;
        } else if (resolutionSelect.options.length > 0) {
          resolutionSelect.selectedIndex = 0;
        }

        let status = message;
        const initialStatusLower = typeof status === "string" ? status.toLowerCase() : "";
        const selectedCamera = typeof camera.selected === "string" ? camera.selected : "";
        const activeCamera = typeof camera.active === "string" ? camera.active : "";
        if (
          !initialStatusLower.startsWith("error") &&
          activeCamera &&
          selectedCamera &&
          activeCamera !== selectedCamera
        ) {
          const activeLabel = cameraLabels.get(activeCamera) || activeCamera;
          status += ` (active: ${activeLabel})`;
        }
        if (
          resolutionInfo &&
          typeof resolutionInfo.active === "string" &&
          typeof resolutionInfo.selected === "string" &&
          resolutionInfo.active &&
          resolutionInfo.selected &&
          resolutionInfo.active !== resolutionInfo.selected
        ) {
          const activeLabel =
            resolutionLabels.get(resolutionInfo.active) ||
            resolutionInfo.active.replace(/x/gi, "×");
          status += ` (active resolution: ${activeLabel})`;
        }
        const statusLower = typeof status === "string" ? status.toLowerCase() : "";
        const errorMessages = describeCameraErrors(camera).filter((detail) => {
          if (!statusLower) {
            return true;
          }
          const detailLower = detail.toLowerCase();
          if (statusLower.includes(detailLower)) {
            return false;
          }
          const colonIndex = detail.indexOf(":");
          if (colonIndex !== -1) {
            const tail = detail
              .slice(colonIndex + 1)
              .trim()
              .toLowerCase();
            if (tail && statusLower.includes(tail)) {
              return false;
            }
          }
          return true;
        });
        if (camera.stream) {
          const streamDetail = camera.stream.error ? String(camera.stream.error).trim() : "";
          if (streamDetail) {
            const streamMessage = `Streaming disabled: ${streamDetail}`;
            const streamLower = streamMessage.toLowerCase();
            const alreadyIncluded =
              statusLower.includes(streamLower) ||
              errorMessages.some((detail) => detail.toLowerCase() === streamLower);
            if (!alreadyIncluded) {
              errorMessages.push(streamMessage);
            }
          } else if (camera.stream.enabled === false) {
            const disabledMessage = "Streaming disabled";
            const disabledLower = disabledMessage.toLowerCase();
            const alreadyIncluded =
              statusLower.includes(disabledLower) ||
              errorMessages.some((detail) => detail.toLowerCase() === disabledLower);
            if (!alreadyIncluded) {
              errorMessages.push(disabledMessage);
            }
          }
        }
        if (errorMessages.length) {
          status += ` • ${errorMessages.join(" • ")}`;
        }
        statusLabel.textContent = status;
      }

      if (copyStreamButton && streamUrlElement) {
        copyStreamButton.addEventListener("click", async () => {
          const url = streamUrlElement.textContent ? streamUrlElement.textContent.trim() : "";
          if (!url) {
            return;
          }
          try {
            await navigator.clipboard.writeText(url);
            copyStreamButton.textContent = "Copied!";
            if (copyResetTimer) {
              clearTimeout(copyResetTimer);
            }
            copyResetTimer = setTimeout(resetCopyFeedback, 2000);
          } catch (err) {
            console.error(err);
            copyStreamButton.textContent = "Copy failed";
            copyStreamButton.disabled = true;
            if (copyResetTimer) {
              clearTimeout(copyResetTimer);
            }
            copyResetTimer = setTimeout(() => {
              if (copyStreamButton) {
                copyStreamButton.disabled = false;
                resetCopyFeedback();
              }
            }, 2500);
          }
        });
      }

      if (wifiRefreshButton) {
        wifiRefreshButton.addEventListener("click", () => {
          refreshWifiStatus().catch((err) => console.error(err));
        });
      }

      if (wifiScanButton) {
        wifiScanButton.addEventListener("click", () => {
          scanWifiNetworks().catch((err) => console.error(err));
        });
      }

      if (wifiCancelConnect) {
        wifiCancelConnect.addEventListener("click", () => {
          hideWifiConnectForm();
        });
      }

      if (wifiConnectForm) {
        wifiConnectForm.addEventListener("submit", (event) => {
          event.preventDefault();
          connectToWifi().catch((err) => console.error(err));
        });
      }

      if (wifiRollbackInput) {
        wifiRollbackInput.addEventListener("input", () => {
          wifiRollbackInput.dataset.userEdited = "true";
        });
      }

      if (wifiEnableHotspot) {
        wifiEnableHotspot.addEventListener("click", () => {
          toggleHotspot(true).catch((err) => console.error(err));
        });
      }

      if (wifiDisableHotspot) {
        wifiDisableHotspot.addEventListener("click", () => {
          toggleHotspot(false).catch((err) => console.error(err));
        });
      }

      async function fetchSettings() {
        const [orientationResponse, cameraResponse, distanceResponse] = await Promise.all([
          fetch("/api/orientation"),
          fetch("/api/camera"),
          fetch("/api/distance"),
        ]);
        if (!orientationResponse.ok) {
          throw new Error("Unable to fetch current orientation");
        }
        if (!cameraResponse.ok) {
          throw new Error("Unable to fetch camera configuration");
        }
        if (!distanceResponse.ok) {
          throw new Error("Unable to fetch distance configuration");
        }
        const [orientationData, cameraData, distanceData] = await Promise.all([
          orientationResponse.json(),
          cameraResponse.json(),
          distanceResponse.json(),
        ]);
        return { orientation: orientationData, camera: cameraData, distance: distanceData };
      }

      async function loadSettings() {
        const data = await fetchSettings();
        applySettings(data.orientation, data.camera);
        applyDistanceData(data.distance, { updateInputs: true });
      }

      form.addEventListener("submit", async (event) => {
        event.preventDefault();
        statusLabel.textContent = "Saving…";
        const payload = {
          rotation: parseInt(form.rotation.value, 10),
          flip_horizontal: form.flip_horizontal.checked,
          flip_vertical: form.flip_vertical.checked,
        };
        const orientationResponse = await fetch("/api/orientation", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        if (!orientationResponse.ok) {
          let errorDetail = "Unable to save orientation";
          try {
            const error = await orientationResponse.json();
            errorDetail = error.detail || errorDetail;
          } catch (err) {
            console.error(err);
          }
          statusLabel.textContent = "Error: " + errorDetail;
          return;
        }
        const cameraSelect = form.elements.namedItem("camera");
        if (!(cameraSelect instanceof HTMLSelectElement)) {
          statusLabel.textContent = "Error: camera selector missing";
          return;
        }
        const resolutionSelect = form.elements.namedItem("resolution");
        if (!(resolutionSelect instanceof HTMLSelectElement)) {
          statusLabel.textContent = "Error: resolution selector missing";
          return;
        }
        const cameraResponse = await fetch("/api/camera", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            source: cameraSelect.value,
            resolution: resolutionSelect.value,
          }),
        });
        if (!cameraResponse.ok) {
          let errorDetail = "Unable to update camera";
          try {
            const error = await cameraResponse.json();
            errorDetail = error.detail || errorDetail;
          } catch (err) {
            console.error(err);
          }
          statusLabel.textContent = "Error: " + errorDetail;
          try {
            const data = await fetchSettings();
            applySettings(data.orientation, data.camera, statusLabel.textContent);
            applyDistanceData(data.distance, { updateInputs: true });
          } catch (err) {
            console.error(err);
          }
          return;
        }
        try {
          const data = await fetchSettings();
          applySettings(data.orientation, data.camera, "Settings saved");
          applyDistanceData(data.distance, { updateInputs: true });
        } catch (err) {
          console.error(err);
          statusLabel.textContent = "Settings saved";
        }
      });

      loadSettings().catch((err) => {
        console.error(err);
        statusLabel.textContent = err.message;
      });

      refreshWifiStatus().catch((err) => {
        console.error(err);
        if (wifiSummary) {
          const message = err instanceof Error ? err.message : "Wi-Fi status unavailable.";
          wifiSummary.textContent = message;
        }
      });

      if (wifiNetworkList) {
        scanWifiNetworks().catch((err) => console.error(err));
      }
    </script>
  </body>
</html>
