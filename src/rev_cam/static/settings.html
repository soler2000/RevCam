<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>RevCam Settings</title>
    <style>
      body {
        margin: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background-color: #111;
        color: #f5f5f5;
        padding: 1.5rem;
      }
      h1 {
        margin-top: 0;
      }
      label {
        display: block;
        margin-bottom: 1rem;
      }
      select,
      input[type="checkbox"] {
        margin-top: 0.5rem;
        font-size: 1rem;
      }
      button {
        background: #0a84ff;
        color: #fff;
        border: none;
        padding: 0.6rem 1.2rem;
        border-radius: 999px;
        font-size: 1rem;
        cursor: pointer;
      }
      .button-link,
      button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.35rem;
        text-decoration: none;
      }
      .button-link {
        background: #0a84ff;
        color: #fff;
        border-radius: 999px;
        padding: 0.6rem 1.2rem;
        font-size: 1rem;
        font-weight: 600;
      }
      .button-link.disabled {
        opacity: 0.5;
        pointer-events: none;
      }
      button.secondary-button {
        background: transparent;
        border: 1px solid #0a84ff;
        color: #0a84ff;
      }
      button.secondary-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      #status {
        margin-top: 1rem;
        font-size: 0.95rem;
        opacity: 0.85;
      }
      a {
        color: #0a84ff;
      }
      #stream-section {
        margin: 2rem 0 1.5rem;
        padding: 1rem;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.04);
      }
      #stream-section h2 {
        margin-top: 0;
        margin-bottom: 0.5rem;
      }
      #stream-summary {
        margin: 0;
        opacity: 0.85;
      }
      #stream-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-top: 0.75rem;
      }
      #stream-url {
        display: block;
        margin-top: 0.75rem;
        padding: 0.6rem 0.75rem;
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.35);
        font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        word-break: break-all;
      }
      #wifi-section {
        margin: 2rem 0 1.5rem;
        padding: 1rem;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.04);
      }
      #wifi-section h2,
      #wifi-section h3 {
        margin-top: 0;
      }
      #wifi-summary {
        margin: 0 0 0.75rem;
        opacity: 0.85;
      }
      #wifi-controls {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 0.75rem;
        margin-bottom: 0.75rem;
      }
      #wifi-controls label {
        margin: 0;
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.95rem;
      }
      #wifi-feedback {
        min-height: 1.2rem;
        font-size: 0.9rem;
        opacity: 0.85;
      }
      #wifi-feedback.error {
        color: #ff6b6b;
        opacity: 1;
      }
      #wifi-network-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      .wifi-network {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
        padding: 0.85rem 1rem;
        border-radius: 12px;
        background: rgba(0, 0, 0, 0.35);
      }
      .wifi-network strong {
        display: block;
        font-size: 1rem;
      }
      .wifi-network span {
        font-size: 0.9rem;
        opacity: 0.8;
      }
      .wifi-network .actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }
      #wifi-connect-form {
        margin-top: 1rem;
        padding: 1rem;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.05);
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }
      #wifi-connect-form[hidden] {
        display: none;
      }
      #wifi-hotspot-section {
        margin-top: 1.5rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }
      #wifi-hotspot-section .button-group {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }
    </style>
  </head>
  <body>
    <a href="/">← Back to live view</a>
    <h1>Camera Settings</h1>
    <p id="app-version" style="margin-top: -0.5rem; opacity: 0.75;">
      Version <span id="version-value">Loading…</span>
    </p>
    <section id="stream-section">
      <h2>Streaming</h2>
      <p id="stream-summary">Loading…</p>
      <div id="stream-actions">
        <a
          id="open-stream"
          class="button-link disabled"
          href="/stream/mjpeg"
          target="_blank"
          rel="noopener"
          aria-disabled="true"
          >Open MJPEG stream</a
        >
        <button type="button" id="copy-stream-url" class="secondary-button" disabled>
          Copy stream URL
        </button>
      </div>
      <code id="stream-url">—</code>
    </section>
    <section id="wifi-section">
      <h2>Wi-Fi</h2>
      <p id="wifi-summary">Loading…</p>
      <div id="wifi-controls">
        <button type="button" id="wifi-refresh" class="secondary-button">Refresh status</button>
        <button type="button" id="wifi-scan">Scan networks</button>
        <label>
          <input type="checkbox" id="wifi-dev-mode" /> Development mode (auto-rollback)
        </label>
      </div>
      <div id="wifi-feedback" role="status" aria-live="polite"></div>
      <ul id="wifi-network-list"></ul>
      <form id="wifi-connect-form" hidden>
        <h3 style="margin: 0;">Connect to network</h3>
        <p id="wifi-connect-selected" style="margin: 0; opacity: 0.85;"></p>
        <input type="hidden" name="ssid" />
        <label>
          Password
          <input type="password" name="password" autocomplete="current-password" />
        </label>
        <label>
          Rollback timeout (seconds)
          <input type="number" name="rollback" min="5" max="180" step="5" value="30" />
        </label>
        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
          <button type="submit">Connect</button>
          <button type="button" id="wifi-cancel-connect" class="secondary-button">Cancel</button>
        </div>
      </form>
      <section id="wifi-hotspot-section">
        <h3>Hotspot</h3>
        <p style="margin: 0 0 0.5rem; opacity: 0.75;">
          Development mode auto-rollback applies when enabling the hotspot.
        </p>
        <p id="wifi-hotspot-status" style="margin: 0; opacity: 0.85;">Hotspot disabled.</p>
        <label>
          Hotspot name
          <input type="text" id="wifi-hotspot-ssid" placeholder="RevCam Hotspot" autocomplete="ssid" />
        </label>
        <label>
          Hotspot password
          <input
            type="password"
            id="wifi-hotspot-password"
            placeholder="Optional (min 8 characters)"
            autocomplete="new-password"
          />
        </label>
        <div class="button-group">
          <button type="button" id="wifi-enable-hotspot">Enable hotspot</button>
          <button type="button" id="wifi-disable-hotspot" class="secondary-button">Disable hotspot</button>
        </div>
      </section>
    </section>
    <form id="orientation-form">
      <label>
        Camera source
        <select name="camera"></select>
      </label>
      <label>
        Resolution
        <select name="resolution"></select>
      </label>
      <h2 style="margin-bottom: 0.5rem; margin-top: 1.5rem;">Orientation</h2>
      <label>
        Rotation
        <select name="rotation">
          <option value="0">0°</option>
          <option value="90">90°</option>
          <option value="180">180°</option>
          <option value="270">270°</option>
        </select>
      </label>
      <label>
        <input type="checkbox" name="flip_horizontal" /> Flip horizontally
      </label>
      <label>
        <input type="checkbox" name="flip_vertical" /> Flip vertically
      </label>
      <button type="submit">Save</button>
      <div id="status">Loading…</div>
    </form>
    <script>
      const form = document.getElementById("orientation-form");
      const statusLabel = document.getElementById("status");
      const versionValue = document.getElementById("version-value");
      const cameraLabels = new Map();
      const resolutionLabels = new Map();
      const streamSection = document.getElementById("stream-section");
      const streamSummary = document.getElementById("stream-summary");
      const streamUrlElement = document.getElementById("stream-url");
      const openStreamLink = document.getElementById("open-stream");
      const copyStreamButton = document.getElementById("copy-stream-url");
      const copyButtonDefault = copyStreamButton ? copyStreamButton.textContent : "";
      let copyResetTimer = null;
      const wifiSummary = document.getElementById("wifi-summary");
      const wifiRefreshButton = document.getElementById("wifi-refresh");
      const wifiScanButton = document.getElementById("wifi-scan");
      const wifiFeedback = document.getElementById("wifi-feedback");
      const wifiNetworkList = document.getElementById("wifi-network-list");
      const wifiConnectForm = document.getElementById("wifi-connect-form");
      const wifiConnectSelected = document.getElementById("wifi-connect-selected");
      const wifiDevToggle = document.getElementById("wifi-dev-mode");
      const wifiCancelConnect = document.getElementById("wifi-cancel-connect");
      const wifiHotspotStatus = document.getElementById("wifi-hotspot-status");
      const wifiHotspotSsid = document.getElementById("wifi-hotspot-ssid");
      const wifiHotspotPassword = document.getElementById("wifi-hotspot-password");
      const wifiEnableHotspot = document.getElementById("wifi-enable-hotspot");
      const wifiDisableHotspot = document.getElementById("wifi-disable-hotspot");
      const wifiConnectSsidInput = wifiConnectForm
        ? wifiConnectForm.querySelector('input[name="ssid"]')
        : null;
      const wifiConnectPasswordInput = wifiConnectForm
        ? wifiConnectForm.querySelector('input[name="password"]')
        : null;
      const wifiRollbackInput = wifiConnectForm
        ? wifiConnectForm.querySelector('input[name="rollback"]')
        : null;

      function describeCameraErrors(camera) {
        if (!camera || !camera.errors) {
          return [];
        }
        const descriptions = [];
        const seen = new Set();
        for (const [source, detail] of Object.entries(camera.errors)) {
          if (!detail) {
            continue;
          }
          const label = cameraLabels.get(source) || source;
          const combined = `${label}: ${detail}`;
          const dedupeKey = detail.trim().toLowerCase();
          if (dedupeKey && seen.has(dedupeKey)) {
            continue;
          }
          if (dedupeKey) {
            seen.add(dedupeKey);
          }
          descriptions.push(combined);
        }
        return descriptions;
      }

      function formatSignalValue(signal) {
        if (typeof signal !== "number" || Number.isNaN(signal)) {
          return "—";
        }
        return `${signal}%`;
      }

      function summariseWifiStatus(status) {
        if (!status) {
          return "Wi-Fi status unavailable.";
        }
        const pieces = [];
        const name = status.ssid || status.profile || "network";
        if (status.hotspot_active) {
          pieces.push(`Hotspot active (${name})`);
          if (status.ip_address) {
            pieces.push(`IP ${status.ip_address}`);
          }
        } else if (status.connected) {
          const signalText = formatSignalValue(status.signal);
          pieces.push(`Connected to ${name}${signalText !== "—" ? ` (${signalText})` : ""}`);
          if (status.ip_address) {
            pieces.push(`IP ${status.ip_address}`);
          }
        } else {
          pieces.push("Not connected to Wi-Fi.");
        }
        if (status.detail) {
          pieces.push(status.detail);
        }
        if (status.error) {
          pieces.push(`Error: ${status.error}`);
        }
        return pieces.join(" ");
      }

      function setWifiFeedback(message, isError = false) {
        if (!wifiFeedback) {
          return;
        }
        wifiFeedback.textContent = message || "";
        if (isError) {
          wifiFeedback.classList.add("error");
        } else {
          wifiFeedback.classList.remove("error");
        }
      }

      function hideWifiConnectForm() {
        if (!wifiConnectForm) {
          return;
        }
        wifiConnectForm.hidden = true;
        if (wifiConnectSelected) {
          wifiConnectSelected.textContent = "";
        }
        if (wifiConnectPasswordInput) {
          wifiConnectPasswordInput.value = "";
        }
      }

      function renderWifiNetworks(networks) {
        if (!wifiNetworkList) {
          return;
        }
        wifiNetworkList.innerHTML = "";
        if (!Array.isArray(networks) || networks.length === 0) {
          const empty = document.createElement("li");
          empty.className = "wifi-network";
          empty.textContent = "No Wi-Fi networks detected.";
          wifiNetworkList.appendChild(empty);
          return;
        }
        for (const network of networks) {
          const item = document.createElement("li");
          item.className = "wifi-network";
          const info = document.createElement("div");
          info.style.minWidth = "12rem";
          const name = document.createElement("strong");
          const ssid = typeof network.ssid === "string" && network.ssid.trim()
            ? network.ssid.trim()
            : "(hidden network)";
          name.textContent = ssid;
          info.appendChild(name);
          const details = document.createElement("span");
          const detailParts = [];
          if (typeof network.signal === "number" && !Number.isNaN(network.signal)) {
            detailParts.push(`${network.signal}%`);
          }
          if (network.security && typeof network.security === "string") {
            detailParts.push(network.security);
          }
          if (network.frequency) {
            const freqText = `${network.frequency} MHz`;
            if (network.channel) {
              detailParts.push(`${freqText} (ch ${network.channel})`);
            } else {
              detailParts.push(freqText);
            }
          }
          if (network.known) {
            detailParts.push("saved");
          }
          if (network.active) {
            detailParts.push("active");
          }
          details.textContent = detailParts.length ? detailParts.join(" • ") : "Details unavailable";
          info.appendChild(details);
          item.appendChild(info);
          const actions = document.createElement("div");
          actions.className = "actions";
          const connectButton = document.createElement("button");
          connectButton.type = "button";
          if (network.active) {
            connectButton.textContent = "Connected";
            connectButton.disabled = true;
          } else if (network.hidden) {
            connectButton.textContent = "Hidden network";
            connectButton.disabled = true;
          } else {
            connectButton.textContent = "Connect";
            connectButton.addEventListener("click", () => {
              if (!wifiConnectForm || !wifiConnectSsidInput || !wifiConnectSelected) {
                return;
              }
              wifiConnectForm.hidden = false;
              wifiConnectSsidInput.value = ssid;
              wifiConnectSelected.textContent = `Selected network: ${ssid}`;
              if (wifiConnectPasswordInput) {
                wifiConnectPasswordInput.value = "";
                wifiConnectPasswordInput.placeholder = network.security
                  ? `Security: ${network.security}`
                  : "Password (if required)";
              }
              if (wifiRollbackInput && typeof wifiRollbackInput.value === "string" && !wifiRollbackInput.value) {
                wifiRollbackInput.value = "30";
              }
            });
          }
          actions.appendChild(connectButton);
          item.appendChild(actions);
          wifiNetworkList.appendChild(item);
        }
      }

      async function refreshWifiStatus() {
        if (!wifiSummary) {
          return null;
        }
        try {
          const response = await fetch("/api/wifi/status");
          if (!response.ok) {
            throw new Error("Unable to fetch Wi-Fi status");
          }
          const status = await response.json();
          wifiSummary.textContent = summariseWifiStatus(status);
          if (wifiHotspotStatus) {
            if (status.hotspot_active) {
              const hotspotName = status.ssid || status.profile || "Hotspot";
              wifiHotspotStatus.textContent = `Hotspot active (${hotspotName})`;
            } else {
              wifiHotspotStatus.textContent = "Hotspot disabled.";
            }
          }
          if (status.detail) {
            setWifiFeedback(status.detail, false);
          } else if (!wifiFeedback || !wifiFeedback.textContent) {
            setWifiFeedback("", false);
          }
          return status;
        } catch (err) {
          console.error(err);
          if (wifiSummary) {
            const message = err instanceof Error ? err.message : "Wi-Fi status unavailable.";
            wifiSummary.textContent = message;
          }
          return null;
        }
      }

      async function scanWifiNetworks() {
        if (!wifiNetworkList) {
          return;
        }
        setWifiFeedback("Scanning for Wi-Fi networks…");
        try {
          const response = await fetch("/api/wifi/networks");
          if (!response.ok) {
            throw new Error("Unable to scan Wi-Fi networks");
          }
          const data = await response.json();
          const networks = Array.isArray(data.networks) ? data.networks : [];
          renderWifiNetworks(networks);
          if (networks.length) {
            setWifiFeedback(`Found ${networks.length} network${networks.length === 1 ? "" : "s"}.`);
          } else {
            setWifiFeedback("No Wi-Fi networks detected. Try scanning again.");
          }
        } catch (err) {
          console.error(err);
          setWifiFeedback("Unable to scan Wi-Fi networks.", true);
        }
      }

      async function connectToWifi() {
        if (!wifiConnectForm || !wifiConnectSsidInput) {
          return;
        }
        const ssid = wifiConnectSsidInput.value.trim();
        if (!ssid) {
          setWifiFeedback("Select a Wi-Fi network before connecting.", true);
          return;
        }
        const payload = {
          ssid,
          development_mode: wifiDevToggle ? !!wifiDevToggle.checked : false,
        };
        if (wifiConnectPasswordInput && wifiConnectPasswordInput.value) {
          payload.password = wifiConnectPasswordInput.value;
        }
        if (wifiRollbackInput) {
          const rollback = parseFloat(wifiRollbackInput.value);
          if (!Number.isNaN(rollback) && rollback > 0) {
            payload.rollback_seconds = rollback;
          }
        }
        setWifiFeedback(`Connecting to ${ssid}…`);
        try {
          const response = await fetch("/api/wifi/connect", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          if (!response.ok) {
            let errorDetail = "Unable to connect to Wi-Fi network.";
            try {
              const error = await response.json();
              if (error && error.detail) {
                errorDetail = error.detail;
              }
            } catch (parseErr) {
              console.error(parseErr);
            }
            setWifiFeedback(errorDetail, true);
            return;
          }
          const status = await response.json();
          const successMessage = status.detail
            ? status.detail
            : `Joined ${status.ssid || ssid}.`;
          setWifiFeedback(successMessage);
          hideWifiConnectForm();
          await refreshWifiStatus();
          await scanWifiNetworks();
        } catch (err) {
          console.error(err);
          setWifiFeedback("Connection attempt failed.", true);
        }
      }

      async function toggleHotspot(enabled) {
        let payload = { enabled };
        if (enabled) {
          const ssidValue = wifiHotspotSsid && typeof wifiHotspotSsid.value === "string"
            ? wifiHotspotSsid.value.trim()
            : "";
          const passwordValue = wifiHotspotPassword && typeof wifiHotspotPassword.value === "string"
            ? wifiHotspotPassword.value.trim()
            : "";
          if (passwordValue && passwordValue.length < 8) {
            setWifiFeedback("Hotspot password must contain at least 8 characters.", true);
            return;
          }
          payload = {
            enabled: true,
            ssid: ssidValue || undefined,
            development_mode: wifiDevToggle ? !!wifiDevToggle.checked : false,
          };
          if (passwordValue) {
            payload.password = passwordValue;
          }
          if (wifiRollbackInput) {
            const rollback = parseFloat(wifiRollbackInput.value);
            if (!Number.isNaN(rollback) && rollback > 0) {
              payload.rollback_seconds = rollback;
            }
          }
          setWifiFeedback("Enabling hotspot…");
        } else {
          payload = { enabled: false };
          setWifiFeedback("Disabling hotspot…");
        }
        try {
          const response = await fetch("/api/wifi/hotspot", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          if (!response.ok) {
            let errorDetail = enabled ? "Unable to enable hotspot." : "Unable to disable hotspot.";
            try {
              const error = await response.json();
              if (error && error.detail) {
                errorDetail = error.detail;
              }
            } catch (parseErr) {
              console.error(parseErr);
            }
            setWifiFeedback(errorDetail, true);
            return;
          }
          const status = await response.json();
          const detailMessage = status.detail
            ? status.detail
            : enabled
            ? "Hotspot enabled."
            : "Hotspot disabled.";
          setWifiFeedback(detailMessage);
          await refreshWifiStatus();
        } catch (err) {
          console.error(err);
          setWifiFeedback(enabled ? "Unable to enable hotspot." : "Unable to disable hotspot.", true);
        }
      }

      function updateVersion(camera) {
        if (!versionValue) {
          return;
        }
        const version = camera && camera.version ? String(camera.version).trim() : "";
        versionValue.textContent = version || "Unknown";
      }

      function updateStreamSection(camera) {
        if (!streamSection) {
          return;
        }
        const stream = camera && camera.stream ? camera.stream : null;
        if (copyStreamButton) {
          copyStreamButton.textContent = copyButtonDefault;
        }
        if (!stream || stream.enabled === false) {
          if (streamSummary) {
            const detail = stream && stream.error ? String(stream.error).trim() : "";
            streamSummary.textContent = detail
              ? `Streaming disabled: ${detail}`
              : "Streaming disabled.";
          }
          if (openStreamLink) {
            openStreamLink.classList.add("disabled");
            openStreamLink.setAttribute("aria-disabled", "true");
            openStreamLink.href = "/stream/mjpeg";
          }
          if (copyStreamButton) {
            copyStreamButton.disabled = true;
          }
          if (streamUrlElement) {
            streamUrlElement.textContent = "—";
          }
          return;
        }

        const endpoint = typeof stream.endpoint === "string" && stream.endpoint
          ? stream.endpoint
          : "/stream/mjpeg";
        const absoluteUrl = new URL(endpoint, window.location.origin).toString();
        const streamType = stream.content_type ? String(stream.content_type) : "MJPEG";
        if (streamSummary) {
          if (stream.error) {
            streamSummary.textContent = `Streaming issue: ${stream.error}`;
          } else {
            streamSummary.textContent = `Live stream ready (${streamType})`;
          }
        }
        if (openStreamLink) {
          openStreamLink.classList.remove("disabled");
          openStreamLink.removeAttribute("aria-disabled");
          openStreamLink.href = absoluteUrl;
        }
        if (copyStreamButton) {
          copyStreamButton.disabled = false;
        }
        if (streamUrlElement) {
          streamUrlElement.textContent = absoluteUrl;
        }
      }

      function resetCopyFeedback() {
        if (copyStreamButton) {
          copyStreamButton.textContent = copyButtonDefault;
        }
        copyResetTimer = null;
      }

      function applySettings(orientation, camera, message = "Settings loaded") {
        form.rotation.value = orientation.rotation;
        form.flip_horizontal.checked = orientation.flip_horizontal;
        form.flip_vertical.checked = orientation.flip_vertical;

        updateVersion(camera);
        updateStreamSection(camera);

        const cameraSelect = form.elements.namedItem("camera");
        if (!(cameraSelect instanceof HTMLSelectElement)) {
          throw new Error("Camera select element missing");
        }
        cameraSelect.innerHTML = "";
        cameraLabels.clear();
        for (const option of camera.options || []) {
          const opt = document.createElement("option");
          opt.value = option.value;
          opt.textContent = option.label;
          cameraSelect.appendChild(opt);
          cameraLabels.set(option.value, option.label);
        }
        if (camera.selected && cameraLabels.has(camera.selected)) {
          cameraSelect.value = camera.selected;
        }

        const resolutionSelect = form.elements.namedItem("resolution");
        if (!(resolutionSelect instanceof HTMLSelectElement)) {
          throw new Error("Resolution select element missing");
        }
        resolutionSelect.innerHTML = "";
        resolutionLabels.clear();
        const resolutionInfo = camera && camera.resolution ? camera.resolution : null;
        const resolutionOptions =
          resolutionInfo && Array.isArray(resolutionInfo.options) ? resolutionInfo.options : [];
        for (const option of resolutionOptions) {
          const opt = document.createElement("option");
          opt.value = option.value;
          opt.textContent = option.label;
          resolutionSelect.appendChild(opt);
          resolutionLabels.set(option.value, option.label);
        }
        if (
          resolutionInfo &&
          typeof resolutionInfo.selected === "string" &&
          resolutionLabels.has(resolutionInfo.selected)
        ) {
          resolutionSelect.value = resolutionInfo.selected;
        } else if (resolutionSelect.options.length > 0) {
          resolutionSelect.selectedIndex = 0;
        }

        let status = message;
        const initialStatusLower = typeof status === "string" ? status.toLowerCase() : "";
        const selectedCamera = typeof camera.selected === "string" ? camera.selected : "";
        const activeCamera = typeof camera.active === "string" ? camera.active : "";
        if (
          !initialStatusLower.startsWith("error") &&
          activeCamera &&
          selectedCamera &&
          activeCamera !== selectedCamera
        ) {
          const activeLabel = cameraLabels.get(activeCamera) || activeCamera;
          status += ` (active: ${activeLabel})`;
        }
        if (
          resolutionInfo &&
          typeof resolutionInfo.active === "string" &&
          typeof resolutionInfo.selected === "string" &&
          resolutionInfo.active &&
          resolutionInfo.selected &&
          resolutionInfo.active !== resolutionInfo.selected
        ) {
          const activeLabel =
            resolutionLabels.get(resolutionInfo.active) ||
            resolutionInfo.active.replace(/x/gi, "×");
          status += ` (active resolution: ${activeLabel})`;
        }
        const statusLower = typeof status === "string" ? status.toLowerCase() : "";
        const errorMessages = describeCameraErrors(camera).filter((detail) => {
          if (!statusLower) {
            return true;
          }
          const detailLower = detail.toLowerCase();
          if (statusLower.includes(detailLower)) {
            return false;
          }
          const colonIndex = detail.indexOf(":");
          if (colonIndex !== -1) {
            const tail = detail
              .slice(colonIndex + 1)
              .trim()
              .toLowerCase();
            if (tail && statusLower.includes(tail)) {
              return false;
            }
          }
          return true;
        });
        if (camera.stream) {
          const streamDetail = camera.stream.error ? String(camera.stream.error).trim() : "";
          if (streamDetail) {
            const streamMessage = `Streaming disabled: ${streamDetail}`;
            const streamLower = streamMessage.toLowerCase();
            const alreadyIncluded =
              statusLower.includes(streamLower) ||
              errorMessages.some((detail) => detail.toLowerCase() === streamLower);
            if (!alreadyIncluded) {
              errorMessages.push(streamMessage);
            }
          } else if (camera.stream.enabled === false) {
            const disabledMessage = "Streaming disabled";
            const disabledLower = disabledMessage.toLowerCase();
            const alreadyIncluded =
              statusLower.includes(disabledLower) ||
              errorMessages.some((detail) => detail.toLowerCase() === disabledLower);
            if (!alreadyIncluded) {
              errorMessages.push(disabledMessage);
            }
          }
        }
        if (errorMessages.length) {
          status += ` • ${errorMessages.join(" • ")}`;
        }
        statusLabel.textContent = status;
      }

      if (copyStreamButton && streamUrlElement) {
        copyStreamButton.addEventListener("click", async () => {
          const url = streamUrlElement.textContent ? streamUrlElement.textContent.trim() : "";
          if (!url) {
            return;
          }
          try {
            await navigator.clipboard.writeText(url);
            copyStreamButton.textContent = "Copied!";
            if (copyResetTimer) {
              clearTimeout(copyResetTimer);
            }
            copyResetTimer = setTimeout(resetCopyFeedback, 2000);
          } catch (err) {
            console.error(err);
            copyStreamButton.textContent = "Copy failed";
            copyStreamButton.disabled = true;
            if (copyResetTimer) {
              clearTimeout(copyResetTimer);
            }
            copyResetTimer = setTimeout(() => {
              if (copyStreamButton) {
                copyStreamButton.disabled = false;
                resetCopyFeedback();
              }
            }, 2500);
          }
        });
      }

      if (wifiRefreshButton) {
        wifiRefreshButton.addEventListener("click", () => {
          refreshWifiStatus().catch((err) => console.error(err));
        });
      }

      if (wifiScanButton) {
        wifiScanButton.addEventListener("click", () => {
          scanWifiNetworks().catch((err) => console.error(err));
        });
      }

      if (wifiCancelConnect) {
        wifiCancelConnect.addEventListener("click", () => {
          hideWifiConnectForm();
        });
      }

      if (wifiConnectForm) {
        wifiConnectForm.addEventListener("submit", (event) => {
          event.preventDefault();
          connectToWifi().catch((err) => console.error(err));
        });
      }

      if (wifiEnableHotspot) {
        wifiEnableHotspot.addEventListener("click", () => {
          toggleHotspot(true).catch((err) => console.error(err));
        });
      }

      if (wifiDisableHotspot) {
        wifiDisableHotspot.addEventListener("click", () => {
          toggleHotspot(false).catch((err) => console.error(err));
        });
      }

      async function fetchSettings() {
        const [orientationResponse, cameraResponse] = await Promise.all([
          fetch("/api/orientation"),
          fetch("/api/camera"),
        ]);
        if (!orientationResponse.ok) {
          throw new Error("Unable to fetch current orientation");
        }
        if (!cameraResponse.ok) {
          throw new Error("Unable to fetch camera configuration");
        }
        const [orientationData, cameraData] = await Promise.all([
          orientationResponse.json(),
          cameraResponse.json(),
        ]);
        return { orientation: orientationData, camera: cameraData };
      }

      async function loadSettings() {
        const data = await fetchSettings();
        applySettings(data.orientation, data.camera);
      }

      form.addEventListener("submit", async (event) => {
        event.preventDefault();
        statusLabel.textContent = "Saving…";
        const payload = {
          rotation: parseInt(form.rotation.value, 10),
          flip_horizontal: form.flip_horizontal.checked,
          flip_vertical: form.flip_vertical.checked,
        };
        const orientationResponse = await fetch("/api/orientation", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        if (!orientationResponse.ok) {
          let errorDetail = "Unable to save orientation";
          try {
            const error = await orientationResponse.json();
            errorDetail = error.detail || errorDetail;
          } catch (err) {
            console.error(err);
          }
          statusLabel.textContent = "Error: " + errorDetail;
          return;
        }
        const cameraSelect = form.elements.namedItem("camera");
        if (!(cameraSelect instanceof HTMLSelectElement)) {
          statusLabel.textContent = "Error: camera selector missing";
          return;
        }
        const resolutionSelect = form.elements.namedItem("resolution");
        if (!(resolutionSelect instanceof HTMLSelectElement)) {
          statusLabel.textContent = "Error: resolution selector missing";
          return;
        }
        const cameraResponse = await fetch("/api/camera", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            source: cameraSelect.value,
            resolution: resolutionSelect.value,
          }),
        });
        if (!cameraResponse.ok) {
          let errorDetail = "Unable to update camera";
          try {
            const error = await cameraResponse.json();
            errorDetail = error.detail || errorDetail;
          } catch (err) {
            console.error(err);
          }
          statusLabel.textContent = "Error: " + errorDetail;
          try {
            const data = await fetchSettings();
            applySettings(data.orientation, data.camera, statusLabel.textContent);
          } catch (err) {
            console.error(err);
          }
          return;
        }
        try {
          const data = await fetchSettings();
          applySettings(data.orientation, data.camera, "Settings saved");
        } catch (err) {
          console.error(err);
          statusLabel.textContent = "Settings saved";
        }
      });

      loadSettings().catch((err) => {
        console.error(err);
        statusLabel.textContent = err.message;
      });

      refreshWifiStatus().catch((err) => {
        console.error(err);
        if (wifiSummary) {
          const message = err instanceof Error ? err.message : "Wi-Fi status unavailable.";
          wifiSummary.textContent = message;
        }
      });

      if (wifiNetworkList) {
        scanWifiNetworks().catch((err) => console.error(err));
      }
    </script>
  </body>
</html>
