<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>RevCam Surveillance</title>
    <link rel="icon" type="image/svg+xml" href="images/favicon.svg" />
    <style>
      :root {
        color-scheme: dark;
        --font-family: "Inter", "Manrope", "Segoe UI", system-ui, -apple-system,
          BlinkMacSystemFont, sans-serif;
        --line-height: 1.6;
        --transition: 200ms ease;
        --surface-0: rgba(14, 16, 22, 0.9);
        --surface-1: rgba(26, 28, 36, 0.85);
        --surface-soft: rgba(255, 255, 255, 0.06);
        --border-subtle: rgba(255, 255, 255, 0.08);
        --border-muted: rgba(255, 255, 255, 0.14);
        --text-primary: #f5f7fb;
        --text-muted: rgba(245, 247, 250, 0.7);
        --accent: #0a84ff;
        --accent-hover: #2f95ff;
        --accent-active: #55adff;
        --accent-soft: rgba(10, 132, 255, 0.15);
        --accent-ring: rgba(10, 132, 255, 0.45);
        --accent-shadow: rgba(10, 132, 255, 0.35);
        --success: #34c759;
        --danger: #ff453a;
        --warning: #ffd60a;
        --radius-md: 0.85rem;
        --radius-lg: 1.2rem;
        --radius-pill: 999px;
        --space-sm: 0.5rem;
        --space-md: 0.9rem;
        --space-lg: 1.4rem;
        --space-xl: 2.1rem;
        --shadow-sm: 0 12px 24px rgba(0, 0, 0, 0.28);
        --shadow-md: 0 26px 46px rgba(0, 0, 0, 0.4);
        --page-gradient: radial-gradient(115% 140% at top, #1b1e26 0%, #0b0d13 60%, #050609 100%);
      }
      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: var(--font-family);
        line-height: var(--line-height);
        background: var(--page-gradient);
        color: var(--text-primary);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }
      header,
      footer {
        padding: var(--space-md) var(--space-xl);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: var(--space-lg);
        background: var(--surface-0);
        border-bottom: 1px solid var(--border-subtle);
        backdrop-filter: blur(18px) saturate(130%);
        -webkit-backdrop-filter: blur(18px) saturate(130%);
        box-shadow: var(--shadow-md);
      }
      footer {
        border-top: 1px solid var(--border-subtle);
        border-bottom: none;
        margin-top: auto;
        justify-content: center;
      }
      .brand-area {
        display: flex;
        align-items: center;
        gap: var(--space-lg);
        flex-wrap: wrap;
      }
      strong.brand {
        font-size: 1.3rem;
        letter-spacing: 0.05em;
        color: var(--success);
      }
      .mode-toggle {
        display: inline-flex;
        align-items: center;
        gap: var(--space-sm);
        padding: calc(var(--space-sm) * 0.8);
        border-radius: var(--radius-pill);
        background: var(--surface-1);
        border: 1px solid var(--border-muted);
        box-shadow: var(--shadow-sm);
      }
      .mode-toggle-button {
        appearance: none;
        border: none;
        background: transparent;
        color: var(--text-muted);
        font-weight: 600;
        padding: 0.4rem var(--space-lg);
        border-radius: var(--radius-pill);
        cursor: pointer;
        transition: background var(--transition), color var(--transition), box-shadow var(--transition);
      }
      .mode-toggle-button[aria-pressed="true"] {
        background: var(--accent);
        color: #fff;
        box-shadow: 0 0 0 1px var(--accent-ring) inset, 0 10px 24px var(--accent-shadow);
      }
      .mode-toggle-button:not([aria-pressed="true"]):hover,
      .mode-toggle-button:not([aria-pressed="true"]):focus-visible {
        background: var(--surface-soft);
        color: var(--text-primary);
      }
      .mode-toggle-button:focus-visible {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }
      .mode-toggle-button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .status-message {
        font-weight: 600;
        color: var(--text-muted);
        min-width: 0;
      }
      .status-message[data-tone="busy"] {
        color: var(--accent);
      }
      .status-message[data-tone="error"] {
        color: var(--danger);
      }
      .status-message[data-tone="monitor"] {
        color: var(--warning);
        text-shadow: 0 0 12px rgba(255, 214, 10, 0.35);
      }
      .status-message[data-tone="alert"] {
        color: var(--danger);
        text-shadow: 0 0 16px rgba(255, 69, 58, 0.45);
      }
      main {
        padding: var(--space-xl);
        display: grid;
        grid-template-columns: minmax(280px, 1fr) minmax(260px, 320px);
        gap: var(--space-xl);
      }
      .preview-card {
        background: var(--surface-1);
        border-radius: var(--radius-lg);
        border: 1px solid var(--border-subtle);
        padding: var(--space-lg);
        box-shadow: var(--shadow-md);
        display: flex;
        flex-direction: column;
        gap: var(--space-md);
        transition: border-color var(--transition), box-shadow var(--transition);
      }
      .preview-card.motion-monitoring {
        border-color: rgba(255, 214, 10, 0.5);
        box-shadow: 0 20px 40px rgba(255, 214, 10, 0.16);
      }
      .preview-card.motion-alert,
      .preview-card.recording-active {
        border-color: rgba(255, 69, 58, 0.6);
        box-shadow: 0 22px 46px rgba(255, 69, 58, 0.25);
      }
      .preview-card img {
        width: 100%;
        border-radius: var(--radius-md);
        border: 1px solid var(--border-subtle);
        background: #000;
        display: block;
      }
      .controls {
        display: flex;
        align-items: center;
        gap: var(--space-sm);
        flex-wrap: wrap;
      }
      .recording-timer {
        display: inline-flex;
        align-items: center;
        gap: 0.45rem;
        padding: 0.4rem 1rem;
        border-radius: var(--radius-pill);
        background: rgba(10, 132, 255, 0.12);
        border: 1px solid rgba(10, 132, 255, 0.35);
        font-weight: 600;
        font-variant-numeric: tabular-nums;
        color: var(--accent);
        box-shadow: 0 10px 28px rgba(10, 132, 255, 0.18);
      }
      .recording-timer .recording-timer-icon {
        font-size: 0.95rem;
      }
      .recording-timer .recording-timer-label {
        text-transform: uppercase;
        font-size: 0.7rem;
        letter-spacing: 0.08em;
        color: var(--text-muted);
      }
      .recording-timer .recording-timer-value {
        color: var(--text-primary);
        font-size: 0.95rem;
        min-width: 3.5ch;
        text-align: right;
      }
      button.action {
        background: linear-gradient(135deg, var(--accent), var(--accent-hover));
        color: #fff;
        border: none;
        padding: 0.65rem 1.5rem;
        border-radius: var(--radius-pill);
        font-weight: 600;
        cursor: pointer;
        transition: background var(--transition), box-shadow var(--transition), transform var(--transition);
      }
      button.action:not(:disabled):hover {
        background: linear-gradient(135deg, var(--accent-hover), var(--accent-active));
        transform: translateY(-1px);
        box-shadow: 0 12px 24px var(--accent-shadow);
      }
      @keyframes motionAlertPulse {
        0% {
          box-shadow: 0 0 0 0 rgba(255, 69, 58, 0.35);
          transform: translateY(0);
        }
        50% {
          box-shadow: 0 0 0 12px rgba(255, 69, 58, 0);
          transform: translateY(-1px);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(255, 69, 58, 0.35);
          transform: translateY(0);
        }
      }
      button.action.motion-monitoring {
        background: linear-gradient(135deg, rgba(255, 214, 10, 0.1), rgba(255, 214, 10, 0.45));
        color: var(--warning);
        box-shadow: 0 0 0 1px rgba(255, 214, 10, 0.35) inset, 0 10px 26px rgba(255, 214, 10, 0.25);
      }
      button.action.motion-alert,
      button.action.recording-active {
        background: linear-gradient(135deg, rgba(255, 69, 58, 0.9), rgba(255, 105, 97, 0.95));
        color: #fff;
        box-shadow: 0 0 0 1px rgba(255, 69, 58, 0.45) inset, 0 12px 28px rgba(255, 69, 58, 0.45);
        animation: motionAlertPulse 1.4s ease-in-out infinite;
      }
      button.action:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .recordings-card {
        background: var(--surface-1);
        border-radius: var(--radius-lg);
        border: 1px solid var(--border-subtle);
        padding: var(--space-lg);
        box-shadow: var(--shadow-md);
        display: flex;
        flex-direction: column;
        gap: var(--space-md);
        max-height: 70vh;
        overflow: hidden;
      }
      .recordings-header {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: var(--space-sm);
      }
      .recordings-actions {
        display: inline-flex;
        align-items: center;
        gap: var(--space-sm);
        flex-wrap: wrap;
      }
      .recordings-list {
        list-style: none;
        margin: 0;
        padding: 0;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: var(--space-sm);
      }
      .recording-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: var(--space-sm);
        background: var(--surface-soft);
        border-radius: var(--radius-md);
        padding: var(--space-sm) var(--space-md);
        border: 1px solid var(--border-subtle);
      }
      .recording-meta {
        display: flex;
        flex-direction: column;
        gap: 0.2rem;
      }
      .recording-name {
        font-weight: 600;
      }
      .recording-details {
        color: var(--text-muted);
        font-size: 0.85rem;
      }
      .recording-chunks {
        font-size: 0.78rem;
        color: var(--text-muted);
        margin-top: 0.2rem;
      }
      .recording-actions {
        display: flex;
        align-items: center;
        gap: var(--space-sm);
      }
      .open-recording {
        background: transparent;
        border: 1px solid var(--border-muted);
        color: var(--text-primary);
        border-radius: var(--radius-pill);
        padding: 0.35rem 1rem;
        cursor: pointer;
        transition: border-color var(--transition), color var(--transition);
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        text-decoration: none;
      }
      .open-recording:hover,
      .open-recording:focus-visible {
        border-color: var(--accent);
        color: var(--accent);
        outline: none;
      }
      .delete-recording {
        background: transparent;
        border: 1px solid rgba(255, 69, 58, 0.5);
        color: var(--danger);
        border-radius: var(--radius-pill);
        padding: 0.35rem 0.9rem;
        cursor: pointer;
        transition: border-color var(--transition), color var(--transition);
      }
      .delete-recording:hover,
      .delete-recording:focus-visible {
        border-color: var(--danger);
        color: #ff6b61;
        outline: none;
      }
      .storage-status {
        margin: 0;
        font-size: 0.9rem;
      }
      .storage-status.is-low {
        color: var(--danger);
        font-weight: 600;
      }
      .muted {
        color: var(--text-muted);
      }
      a.link {
        color: var(--accent);
        text-decoration: none;
        font-weight: 600;
      }
      a.link:hover,
      a.link:focus-visible {
        text-decoration: underline;
      }
      @media (max-width: 960px) {
        main {
          grid-template-columns: 1fr;
        }
        .recordings-card {
          max-height: none;
        }
      }
      @media (max-width: 640px) {
        header,
        footer {
          flex-direction: column;
          align-items: stretch;
          text-align: center;
        }
        .brand-area {
          justify-content: center;
        }
        main {
          padding: var(--space-lg);
        }
        .controls {
          justify-content: center;
        }
        .recording-timer {
          width: 100%;
          justify-content: center;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <div class="brand-area">
        <strong class="brand">RevCam</strong>
        <div class="mode-toggle" data-mode-toggle role="group" aria-label="Viewing mode">
          <button class="mode-toggle-button" type="button" data-mode="revcam" aria-pressed="false">
            RevCam
          </button>
          <button class="mode-toggle-button" type="button" data-mode="surveillance" aria-pressed="true">
            Surveillance
          </button>
        </div>
      </div>
      <div class="status-message" id="status-message" data-tone="busy">Initialising…</div>
    </header>
    <main>
      <section class="preview-card">
        <h1>Surveillance preview</h1>
        <img id="surveillance-preview" alt="Surveillance preview" hidden />
        <p class="muted" id="preview-message">Preparing surveillance stream…</p>
        <div class="controls">
          <button class="action" type="button" id="record-button" aria-pressed="false">
            Start manual recording
          </button>
          <button class="action" type="button" id="motion-record-button" aria-pressed="false">
            Start motion detection
          </button>
          <div class="recording-timer" id="recording-timer" aria-live="polite" hidden>
            <span class="recording-timer-icon" aria-hidden="true">⏱</span>
            <span class="recording-timer-label">Elapsed</span>
            <span class="recording-timer-value" data-timer-value>00:00</span>
          </div>
        </div>
        <p class="muted storage-status" id="storage-status">Storage: —</p>
      </section>
      <section class="recordings-card">
        <div class="recordings-header">
          <h2>Recordings</h2>
          <div class="recordings-actions">
            <a class="open-recording" href="/surveillance/timeline" role="button"
              >Timeline view</a
            >
            <button class="open-recording" type="button" id="refresh-recordings">
              Refresh
            </button>
          </div>
        </div>
        <p class="muted" id="recordings-empty">No recordings available yet.</p>
        <ul class="recordings-list" id="recordings-list" aria-live="polite"></ul>
      </section>
    </main>
    <footer>
      <a class="link" href="/surveillance/settings">Surveillance settings</a>
      <a class="link" href="/">Back to live view</a>
    </footer>
    <script>
      const statusMessage = document.getElementById("status-message");
      const previewCard = document.querySelector(".preview-card");
      const previewImage = document.getElementById("surveillance-preview");
      const previewMessage = document.getElementById("preview-message");
      const recordButton = document.getElementById("record-button");
      const motionRecordButton = document.getElementById("motion-record-button");
      const recordingTimer = document.getElementById("recording-timer");
      const recordingTimerValue = recordingTimer
        ? recordingTimer.querySelector("[data-timer-value]")
        : null;
      const recordingsList = document.getElementById("recordings-list");
      const recordingsEmpty = document.getElementById("recordings-empty");
      const refreshButton = document.getElementById("refresh-recordings");
      const storageStatus = document.getElementById("storage-status");
      const modeToggle = document.querySelector("[data-mode-toggle]");
      const modeButtons = modeToggle
        ? Array.from(modeToggle.querySelectorAll(".mode-toggle-button"))
        : [];
      let currentMode = "surveillance";
      let sessionState = "idle";
      let pendingManualResume = null;
      let previewUrl = null;
      let recordingTimerStartMs = null;
      let recordingTimerInterval = null;
      let recordingTimerSource = null;
      const STATUS_REFRESH_ACTIVE_MS = 2000;
      const STATUS_REFRESH_IDLE_MS = 5000;
      let statusRefreshHandle = null;
      let statusRequestSequence = 0;
      let latestAppliedStatusSequence = 0;
      let pageVisible = true;

      function setStatus(message, tone = "info") {
        if (!statusMessage) {
          return;
        }
        statusMessage.textContent = message;
        statusMessage.dataset.tone = tone;
      }

      function clearScheduledStatusRefresh() {
        if (statusRefreshHandle !== null) {
          window.clearTimeout(statusRefreshHandle);
          statusRefreshHandle = null;
        }
      }

      function scheduleStatusRefresh() {
        if (!pageVisible) {
          return;
        }
        const activeSession =
          sessionState === "manual" ||
          sessionState === "motion-monitoring" ||
          sessionState === "motion-recording";
        const interval = activeSession ? STATUS_REFRESH_ACTIVE_MS : STATUS_REFRESH_IDLE_MS;
        clearScheduledStatusRefresh();
        statusRefreshHandle = window.setTimeout(() => {
          statusRefreshHandle = null;
          loadStatus({ showLoading: false, suppressError: true }).catch((error) => {
            console.error("Scheduled surveillance status refresh failed", error);
          });
        }, interval);
      }

      function renderRecordingTimer() {
        if (!recordingTimer || !recordingTimerValue) {
          return;
        }
        if (recordingTimerStartMs === null) {
          recordingTimerValue.textContent = "00:00";
          recordingTimer.hidden = true;
          return;
        }
        const elapsedSeconds = Math.max(0, Math.floor((Date.now() - recordingTimerStartMs) / 1000));
        const hours = Math.floor(elapsedSeconds / 3600);
        const minutes = Math.floor((elapsedSeconds % 3600) / 60);
        const seconds = elapsedSeconds % 60;
        const minutesPart = hours > 0 ? String(minutes).padStart(2, "0") : String(minutes);
        const secondsPart = String(seconds).padStart(2, "0");
        const prefix = hours > 0 ? `${hours}:${minutesPart}` : minutesPart.padStart(2, "0");
        const display = `${prefix}:${secondsPart}`;
        recordingTimerValue.textContent = display;
        recordingTimer.hidden = false;
      }

      function stopRecordingTimer() {
        if (recordingTimerInterval !== null) {
          window.clearInterval(recordingTimerInterval);
          recordingTimerInterval = null;
        }
        recordingTimerStartMs = null;
        recordingTimerSource = null;
        if (recordingTimerValue) {
          recordingTimerValue.textContent = "00:00";
        }
        if (recordingTimer) {
          recordingTimer.hidden = true;
        }
      }

      function startRecordingTimer(startIso) {
        if (!recordingTimer || !recordingTimerValue) {
          return;
        }
        if (typeof startIso !== "string" || startIso.length === 0) {
          return;
        }
        const parsed = Date.parse(startIso);
        if (Number.isNaN(parsed)) {
          return;
        }
        if (recordingTimerInterval !== null) {
          window.clearInterval(recordingTimerInterval);
          recordingTimerInterval = null;
        }
        recordingTimerStartMs = parsed;
        recordingTimerSource = startIso;
        renderRecordingTimer();
        recordingTimerInterval = window.setInterval(renderRecordingTimer, 1000);
      }

      function syncRecordingTimer(startIso, currentSession) {
        if (!recordingTimer) {
          return;
        }
        const hasStart = typeof startIso === "string" && startIso.length > 0;
        const shouldRun =
          hasStart && (currentSession === "manual" || currentSession === "motion-recording");
        if (!shouldRun) {
          stopRecordingTimer();
          return;
        }
        if (recordingTimerSource === startIso && recordingTimerStartMs !== null) {
          renderRecordingTimer();
          return;
        }
        startRecordingTimer(startIso);
      }

      function updateModeButtons(mode) {
        modeButtons.forEach((button) => {
          const target = button.dataset.mode || "";
          button.setAttribute("aria-pressed", String(target === mode));
        });
      }

      async function changeMode(target) {
        const desired = target === "revcam" ? "revcam" : "surveillance";
        if (desired === currentMode) {
          if (desired === "revcam") {
            window.location.href = "/";
          }
          return;
        }
        modeButtons.forEach((button) => {
          button.disabled = true;
        });
        updateModeButtons(desired);
        try {
          const response = await fetch("/api/surveillance/mode", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ mode: desired }),
          });
          if (!response.ok) {
            throw new Error(`Mode update failed with ${response.status}`);
          }
          if (desired === "revcam") {
            window.location.href = "/";
            return;
          }
          currentMode = desired;
          setStatus("Surveillance mode ready", "busy");
          await loadStatus({ showLoading: true });
        } catch (error) {
          console.error("Viewing mode toggle error", error);
          updateModeButtons(currentMode);
          setStatus("Unable to update viewing mode", "error");
        } finally {
          modeButtons.forEach((button) => {
            button.disabled = false;
          });
        }
      }

      function updatePreview(preview) {
        if (!preview || !preview.endpoint) {
          if (previewImage) {
            previewImage.hidden = true;
            previewImage.removeAttribute("src");
          }
          previewUrl = null;
          previewMessage.textContent = "Preview unavailable.";
          return;
        }
        const nextUrl = `${preview.endpoint}?v=${Date.now()}`;
        if (previewUrl !== nextUrl && previewImage) {
          previewUrl = nextUrl;
          previewImage.src = nextUrl;
          previewImage.hidden = false;
        }
        previewMessage.textContent = "Live surveillance preview.";
      }

      function isMotionRecordingActive(snapshot) {
        if (!snapshot || typeof snapshot !== "object") {
          return false;
        }
        const sessionState = snapshot.session_state;
        if (sessionState === "recording") {
          return true;
        }
        const sessionRecording = snapshot.session_recording === true;
        const eventActive = snapshot.event_active === true;
        return sessionRecording || eventActive;
      }

      function determineSessionState(serverRecording, serverMode, motionSnapshot) {
        if (serverRecording && serverMode === "continuous") {
          return "manual";
        }
        if (serverRecording && serverMode === "motion") {
          return isMotionRecordingActive(motionSnapshot)
            ? "motion-recording"
            : "motion-monitoring";
        }
        return "idle";
      }

      function updateStatusForSession(currentSession, options = {}) {
        const { processingActive = false, processingRecord = null } = options;
        const manualProcessing = processingActive && isManualProcessingRecord(processingRecord);
        if (currentSession === "manual") {
          setStatus("Manual recording in progress…", "alert");
          return;
        }
        if (currentSession === "motion-recording") {
          setStatus("Motion detected — recording…", "alert");
          return;
        }
        if (currentSession === "motion-monitoring") {
          setStatus("Motion detection active.", "monitor");
          return;
        }
        if (manualProcessing) {
          setStatus("Finalising manual recording…", "busy");
          return;
        }
        if (processingActive) {
          setStatus("Finalising motion recording…", "busy");
          return;
        }
        setStatus("Idle. Ready to record.", "info");
      }

      function applySessionVisuals(currentSession, options = {}) {
        const { processingActive = false, processingRecord = null } = options;
        sessionState = currentSession;
        if (recordButton) {
          const manualActive = currentSession === "manual";
          recordButton.textContent = manualActive ? "Stop recording" : "Start manual recording";
          recordButton.setAttribute("aria-pressed", String(manualActive));
          recordButton.disabled =
            currentSession === "motion-monitoring" || currentSession === "motion-recording";
          recordButton.classList.toggle("recording-active", manualActive);
        }
        if (motionRecordButton) {
          const motionSession =
            currentSession === "motion-monitoring" || currentSession === "motion-recording";
          const motionRecording = currentSession === "motion-recording";
          motionRecordButton.textContent = motionSession
            ? "Stop motion detection"
            : "Start motion detection";
          motionRecordButton.setAttribute("aria-pressed", String(motionSession));
          motionRecordButton.disabled = currentSession === "manual";
          motionRecordButton.classList.remove("motion-monitoring", "motion-alert", "recording-active");
          if (motionRecording) {
            motionRecordButton.classList.add("motion-alert", "recording-active");
          } else if (motionSession) {
            motionRecordButton.classList.add("motion-monitoring");
          }
        }
        if (previewCard) {
          previewCard.classList.remove("motion-monitoring", "motion-alert", "recording-active");
          if (currentSession === "manual") {
            previewCard.classList.add("recording-active");
          } else if (currentSession === "motion-recording") {
            previewCard.classList.add("motion-alert", "recording-active");
          } else if (currentSession === "motion-monitoring") {
            previewCard.classList.add("motion-monitoring");
          }
        }
        updateStatusForSession(currentSession, { processingActive, processingRecord });
      }

      function formatBytes(bytes) {
        if (typeof bytes !== "number" || !Number.isFinite(bytes) || bytes < 0) {
          return null;
        }
        if (bytes === 0) {
          return "0 B";
        }
        const units = ["B", "KB", "MB", "GB", "TB"];
        const exponent = Math.min(
          units.length - 1,
          Math.floor(Math.log(bytes) / Math.log(1024)),
        );
        const value = bytes / 1024 ** exponent;
        return `${value.toFixed(value >= 10 ? 1 : 2)} ${units[exponent]}`;
      }

      function updateStorage(storage) {
        if (!storageStatus) {
          return;
        }
        storageStatus.classList.remove("is-low");
        if (!storage || typeof storage.free_percent !== "number") {
          storageStatus.textContent = "Storage: —";
          return;
        }
        const freePercent = Number(storage.free_percent) || 0;
        const freeText = formatBytes(storage.free_bytes);
        const totalText = formatBytes(storage.total_bytes);
        const parts = [];
        if (freeText) {
          parts.push(`${freeText} free`);
        }
        parts.push(`(${freePercent.toFixed(1)}%)`);
        if (totalText) {
          parts.push(`of ${totalText}`);
        }
        storageStatus.textContent = `Storage: ${parts.join(" ")}`;
        const threshold = Number(storage.threshold_percent ?? 0);
        if (Number.isFinite(threshold) && threshold > 0 && freePercent <= threshold) {
          storageStatus.classList.add("is-low");
        }
      }

      function isManualProcessingRecord(record) {
        if (!record || typeof record !== "object") {
          return false;
        }
        const motionInfo = record.motion_detection;
        if (!motionInfo || typeof motionInfo !== "object") {
          return false;
        }
        if (motionInfo.enabled === false) {
          return true;
        }
        return motionInfo.session_override === true && motionInfo.enabled !== true;
      }

      function createActionButton(label, className) {
        const button = document.createElement("button");
        button.type = "button";
        button.className = className;
        button.textContent = label;
        return button;
      }

      async function deleteRecording(name) {
        if (!name) {
          return;
        }
        const confirmed = window.confirm(`Delete recording ${name}?`);
        if (!confirmed) {
          return;
        }
        try {
          const response = await fetch(`/api/surveillance/recordings/${encodeURIComponent(name)}`, {
            method: "DELETE",
            headers: { "Content-Type": "application/json" },
          });
          if (!response.ok) {
            throw new Error(`Delete failed with ${response.status}`);
          }
          await loadStatus({ showLoading: true });
          setStatus(`Deleted recording ${name}.`, "info");
        } catch (error) {
          console.error("Failed to delete recording", error);
          setStatus("Unable to delete recording", "error");
        }
      }

      function renderRecordings(records) {
        recordingsList.innerHTML = "";
        if (!Array.isArray(records) || records.length === 0) {
          recordingsEmpty.hidden = false;
          return;
        }
        recordingsEmpty.hidden = true;
        records.forEach((record) => {
          const item = document.createElement("li");
          item.className = "recording-item";
          const meta = document.createElement("div");
          meta.className = "recording-meta";
          const name = document.createElement("span");
          name.className = "recording-name";
          name.textContent = record.name || "Recording";
          const details = document.createElement("span");
          details.className = "recording-details";
          const started = record.started_at ? new Date(record.started_at) : null;
          const durationSeconds =
            typeof record.duration_seconds === "number" ? record.duration_seconds : null;
          const sizeBytes = typeof record.size_bytes === "number" ? record.size_bytes : null;
          const chunkCount = typeof record.chunk_count === "number" ? record.chunk_count : null;
          const isProcessingRecord = Boolean(record.processing);
          const processingError =
            typeof record.processing_error === "string" && record.processing_error.length > 0;
          let summaryText;
          if (isProcessingRecord) {
            summaryText = "Processing clip…";
          } else if (processingError) {
            summaryText = "Processing failed";
            details.title = record.processing_error;
          } else {
            const formatted = [
              started ? started.toLocaleString() : null,
              durationSeconds != null ? `${durationSeconds.toFixed(1)}s` : null,
              sizeBytes != null ? formatBytes(sizeBytes) : null,
              chunkCount && chunkCount > 1 ? `${chunkCount} chunks` : null,
              record.stop_reason === "storage_low"
                ? "Stopped due to low storage"
                : typeof record.stop_reason === "string"
                ? `Stopped: ${record.stop_reason}`
                : null,
            ].filter(Boolean);
            summaryText = formatted.join(" • ") || "Pending metadata";
          }
          details.textContent = summaryText;
          meta.appendChild(name);
          meta.appendChild(details);
          if (Array.isArray(record.chunks) && record.chunks.length > 0) {
            const chunkSummaries = record.chunks
              .map((chunk, idx) => {
                if (!chunk || typeof chunk !== "object") {
                  return null;
                }
                const label = idx + 1;
                const chunkSize =
                  typeof chunk.size_bytes === "number" && Number.isFinite(chunk.size_bytes)
                    ? formatBytes(chunk.size_bytes)
                    : null;
                if (!chunkSize) {
                  return null;
                }
                return `Chunk ${label} (${chunkSize})`;
              })
              .filter(Boolean);
            if (chunkSummaries.length) {
              const chunkLine = document.createElement("div");
              chunkLine.className = "recording-chunks";
              chunkLine.textContent = chunkSummaries.join(", ");
              meta.appendChild(chunkLine);
            }
          }
          const actions = document.createElement("div");
          actions.className = "recording-actions";
          const open = createActionButton("Open", "open-recording");
          if (isProcessingRecord) {
            open.disabled = true;
            open.title = "Processing clip…";
          }
          open.addEventListener("click", () => {
            const href = `/surveillance/player?name=${encodeURIComponent(record.name)}`;
            window.location.href = href;
          });
          actions.appendChild(open);
          const removeButton = createActionButton("Delete", "delete-recording");
          if (isProcessingRecord) {
            removeButton.disabled = true;
            removeButton.title = "Processing clip…";
          }
          removeButton.addEventListener("click", () => {
            deleteRecording(record.name).catch((error) => {
              console.error("Delete recording error", error);
            });
          });
          actions.appendChild(removeButton);
          item.appendChild(meta);
          item.appendChild(actions);
          recordingsList.appendChild(item);
        });
      }

      async function loadStatus(options = {}) {
        const { showLoading = false, suppressError = false } = options;
        const requestSequence = ++statusRequestSequence;
        if (showLoading) {
          setStatus("Loading surveillance status…", "busy");
        }
        clearScheduledStatusRefresh();
        try {
          const response = await fetch("/api/surveillance/status", { cache: "no-store" });
          if (!response.ok) {
            throw new Error(`Status request failed with ${response.status}`);
          }
          const payload = await response.json();
          if (requestSequence < latestAppliedStatusSequence) {
            scheduleStatusRefresh();
            return;
          }
          latestAppliedStatusSequence = requestSequence;
          if (payload && typeof payload.mode === "string") {
            currentMode = payload.mode === "surveillance" ? "surveillance" : "revcam";
            updateModeButtons(currentMode);
            if (currentMode !== "surveillance") {
              window.location.replace("/");
              return;
            }
          }
          const processingRecord = payload ? payload.processing_recording : null;
          const isProcessing = Boolean(payload && payload.processing);
          const motionSnapshot = payload ? payload.motion : null;
          const serverRecording = Boolean(payload && payload.recording);
          let serverModeHint = "idle";
          if (payload && typeof payload.recording_mode === "string") {
            const candidate = payload.recording_mode;
            if (candidate === "motion" || candidate === "continuous") {
              serverModeHint = candidate;
            }
          }
          const derivedSession = determineSessionState(
            serverRecording,
            serverModeHint,
            motionSnapshot,
          );
          const previousSession = sessionState;
          applySessionVisuals(derivedSession, {
            processingActive: isProcessing,
            processingRecord,
          });
          updatePreview(payload ? payload.preview : null);
          renderRecordings(payload && Array.isArray(payload.recordings) ? payload.recordings : []);
          const storage = payload ? payload.storage : null;
          updateStorage(storage);
          const startedAtIso =
            payload && typeof payload.recording_started_at === "string"
              ? payload.recording_started_at
              : null;
          syncRecordingTimer(startedAtIso, sessionState);
          const processingError =
            processingRecord &&
            typeof processingRecord.processing_error === "string" &&
            processingRecord.processing_error.length > 0;
          if (processingError) {
            setStatus("Recording processing failed", "error");
          }
          if (
            storage &&
            typeof storage.free_percent === "number" &&
            typeof storage.threshold_percent === "number" &&
            storage.threshold_percent > 0 &&
            storage.free_percent <= storage.threshold_percent
          ) {
            setStatus("Low storage — recordings will pause automatically", "error");
          }
          if (previousSession === "manual" && sessionState !== "manual") {
            const resumeTarget = pendingManualResume;
            pendingManualResume = null;
            if (resumeTarget === "motion") {
              window.setTimeout(() => {
                resumeMotionAfterManual().catch((error) => {
                  console.error("Failed to resume motion detection", error);
                  setStatus("Unable to restart motion detection", "error");
                  loadStatus({ showLoading: false, suppressError: true }).catch((loadError) => {
                    console.error("Follow-up status refresh after resume failure failed", loadError);
                  });
                });
              }, 0);
            }
          } else if (sessionState !== "manual") {
            pendingManualResume = null;
          }
          scheduleStatusRefresh();
        } catch (error) {
          if (error && error.name === "AbortError") {
            return;
          }
          console.error("Failed to load surveillance status", error);
          if (requestSequence >= latestAppliedStatusSequence) {
            setStatus("Unable to load surveillance status", "error");
            scheduleStatusRefresh();
          }
          if (!suppressError) {
            throw error;
          }
        }
      }

      async function postRecordingCommand(endpoint, options = {}) {
        const { allowConflict = false } = options;
        const response = await fetch(endpoint, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
        });
        if (!response.ok) {
          if (allowConflict && response.status === 409) {
            return null;
          }
          let detail = null;
          try {
            const payload = await response.json();
            if (payload && typeof payload.detail === "string") {
              detail = payload.detail;
            }
          } catch (parseError) {
            // Ignore parse errors and fall back to status text.
          }
          const error = new Error(detail || `Request failed with ${response.status}`);
          error.status = response.status;
          throw error;
        }
        return response;
      }

      async function resumeMotionAfterManual() {
        await postRecordingCommand("/api/surveillance/recordings/start-motion");
        await loadStatus({ showLoading: true, suppressError: true });
      }

      if (recordButton) {
        recordButton.addEventListener("click", async () => {
          const buttons = [recordButton, motionRecordButton].filter(Boolean);
          buttons.forEach((button) => {
            button.disabled = true;
          });
          try {
            const currentSession = sessionState;
            const stoppingManual = currentSession === "manual";
            if (stoppingManual) {
              await postRecordingCommand("/api/surveillance/recordings/stop", {
                allowConflict: true,
              });
            } else {
              const wasMotionSession =
                currentSession === "motion-monitoring" || currentSession === "motion-recording";
              pendingManualResume = wasMotionSession ? "motion" : null;
              if (wasMotionSession) {
                await postRecordingCommand("/api/surveillance/recordings/stop", {
                  allowConflict: true,
                });
              }
              try {
                await postRecordingCommand("/api/surveillance/recordings/start");
                applySessionVisuals("manual");
                startRecordingTimer(new Date().toISOString());
              } catch (startError) {
                if (pendingManualResume === "motion") {
                  pendingManualResume = null;
                  try {
                    await postRecordingCommand("/api/surveillance/recordings/start-motion");
                  } catch (resumeError) {
                    console.error(
                      "Failed to restore motion detection after manual start failure",
                      resumeError,
                    );
                  }
                }
                throw startError;
              }
            }
          } catch (error) {
            console.error("Manual recording control error", error);
            if (!stoppingManual) {
              pendingManualResume = null;
            }
            const message =
              error && typeof error.message === "string"
                ? error.message
                : "Recording request failed";
            setStatus(message, "error");
            buttons.forEach((button) => {
              button.disabled = false;
            });
            return;
          }
          try {
            await loadStatus({ showLoading: true });
          } catch (error) {
            console.error("Recording status refresh error", error);
            applySessionVisuals(sessionState);
            scheduleStatusRefresh();
          }
        });
      }

      if (motionRecordButton) {
        motionRecordButton.addEventListener("click", async () => {
          const buttons = [recordButton, motionRecordButton].filter(Boolean);
          buttons.forEach((button) => {
            button.disabled = true;
          });
          try {
            const motionActive =
              sessionState === "motion-monitoring" || sessionState === "motion-recording";
            if (motionActive) {
              await postRecordingCommand("/api/surveillance/recordings/stop", {
                allowConflict: true,
              });
            } else {
              pendingManualResume = null;
              await postRecordingCommand("/api/surveillance/recordings/start-motion");
            }
          } catch (error) {
            console.error("Motion detection control error", error);
            const message =
              error && typeof error.message === "string"
                ? error.message
                : "Recording request failed";
            setStatus(message, "error");
            buttons.forEach((button) => {
              button.disabled = false;
            });
            return;
          }
          try {
            await loadStatus({ showLoading: true });
          } catch (error) {
            console.error("Motion detection status refresh error", error);
            applySessionVisuals(sessionState);
            scheduleStatusRefresh();
          }
        });
      }

      if (refreshButton) {
        refreshButton.addEventListener("click", () => {
          loadStatus({ showLoading: true, suppressError: true });
        });
      }

      modeButtons.forEach((button) => {
        button.addEventListener("click", () => {
          const target = button.dataset.mode || "revcam";
          changeMode(target).catch((error) =>
            console.error("Viewing mode change failure", error),
          );
        });
      });

      window.addEventListener("pagehide", () => {
        pageVisible = false;
        clearScheduledStatusRefresh();
        stopRecordingTimer();
      });

      window.addEventListener("pageshow", () => {
        const wasHidden = !pageVisible;
        pageVisible = true;
        if (wasHidden) {
          loadStatus({ showLoading: false, suppressError: true }).catch((error) => {
            console.error("Surveillance status refresh on pageshow failed", error);
          });
        }
      });

      document.addEventListener("visibilitychange", () => {
        if (document.visibilityState === "hidden") {
          pageVisible = false;
          clearScheduledStatusRefresh();
        } else if (document.visibilityState === "visible") {
          pageVisible = true;
          loadStatus({ showLoading: false, suppressError: true }).catch((error) => {
            console.error("Surveillance status refresh on visibility change failed", error);
          });
        }
      });

      loadStatus({ showLoading: true }).catch((error) => {
        console.error("Initial surveillance status load failed", error);
      });
    </script>
  </body>
</html>
