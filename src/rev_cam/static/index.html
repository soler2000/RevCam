<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>RevCam Live View</title>
    <link rel="icon" type="image/svg+xml" href="images/favicon.svg" />
    <style>
      :root {
        color-scheme: dark;
        --font-family: "Inter", "Manrope", "Segoe UI", system-ui, -apple-system,
          BlinkMacSystemFont, sans-serif;
        --line-height: 1.65;
        --transition: 200ms ease;
        --surface-0: rgba(14, 16, 22, 0.8);
        --surface-1: rgba(26, 28, 36, 0.75);
        --surface-muted: rgba(255, 255, 255, 0.08);
        --surface-soft: rgba(255, 255, 255, 0.04);
        --border-subtle: rgba(255, 255, 255, 0.08);
        --border-muted: rgba(255, 255, 255, 0.12);
        --text-primary: #f5f7fb;
        --text-muted: rgba(245, 247, 250, 0.72);
        --text-on-accent: #ffffff;
        --accent: #0a84ff;
        --accent-hover: #2f95ff;
        --accent-active: #55adff;
        --accent-soft: rgba(10, 132, 255, 0.16);
        --accent-ring: rgba(10, 132, 255, 0.45);
        --accent-shadow: rgba(10, 132, 255, 0.35);
        --success: #4ade80;
        --success-soft: rgba(74, 222, 128, 0.16);
        --caution: #facc15;
        --caution-soft: rgba(250, 204, 21, 0.18);
        --warning: #ff9f0a;
        --warning-soft: rgba(255, 159, 10, 0.18);
        --danger: #ff453a;
        --danger-soft: rgba(255, 69, 58, 0.2);
        --info: #38bdf8;
        --info-soft: rgba(56, 189, 248, 0.18);
        --radius-sm: 0.5rem;
        --radius-md: 0.75rem;
        --radius-lg: 1rem;
        --radius-pill: 999px;
        --space-xs: 0.25rem;
        --space-sm: 0.5rem;
        --space-md: 0.75rem;
        --space-lg: 1.25rem;
        --space-xl: 1.75rem;
        --space-2xl: 2.5rem;
        --control-padding-y: 0.6rem;
        --control-padding-x: 1.25rem;
        --card-padding: 1.5rem;
        --shadow-sm: 0 12px 26px rgba(0, 0, 0, 0.35);
        --shadow-md: 0 18px 40px rgba(0, 0, 0, 0.45);
        --shadow-lg: 0 40px 90px rgba(0, 0, 0, 0.6);
        --shadow-top-md: 0 -18px 40px rgba(0, 0, 0, 0.45);
        --glow-success: 0 24px 48px rgba(48, 209, 88, 0.3);
        --glow-danger: 0 20px 44px rgba(255, 69, 58, 0.32);
        --page-gradient: radial-gradient(120% 140% at top, #1b1e26 0%, #10131a 60%, #050609 100%);
      }
      body {
        margin: 0;
        font-family: var(--font-family);
        line-height: var(--line-height);
        background: var(--page-gradient);
        color: var(--text-primary);
        display: flex;
        flex-direction: column;
        min-height: 100vh;
      }
      header,
      footer {
        padding: calc(var(--space-sm) + 0.35rem) var(--space-xl);
        background: var(--surface-0);
        backdrop-filter: blur(18px) saturate(125%);
        -webkit-backdrop-filter: blur(18px) saturate(125%);
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: var(--space-md);
        box-shadow: var(--shadow-md);
      }
      header {
        border-bottom: 1px solid var(--border-subtle);
      }
      .header-panels {
        display: flex;
        flex: 1 1 auto;
        flex-wrap: wrap;
        justify-content: flex-start;
        align-items: stretch;
        gap: var(--space-md);
        margin-left: auto;
      }
      footer {
        border-top: 1px solid var(--border-subtle);
        box-shadow: var(--shadow-top-md);
      }
      .footer-links {
        display: flex;
        gap: var(--space-sm);
        flex-wrap: wrap;
      }
      strong.brand {
        font-size: 1.25rem;
        letter-spacing: 0.04em;
        color: var(--success);
      }
      .pill {
        display: inline-flex;
        align-items: center;
        gap: var(--space-md);
        padding: calc(var(--space-sm) * 0.35) var(--space-lg);
        border-radius: var(--radius-pill);
        background: var(--surface-1);
        border: 1px solid var(--border-muted);
        box-shadow: var(--shadow-sm);
        backdrop-filter: blur(22px);
        -webkit-backdrop-filter: blur(22px);
        min-width: 0;
        transition: box-shadow var(--transition), border-color var(--transition);
      }
      .pill.mode-toggle {
        align-items: center;
        gap: var(--space-sm);
      }
      .mode-toggle .mode-label {
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--text-muted);
      }
      .mode-toggle .mode-buttons {
        display: inline-flex;
        gap: var(--space-xs);
        background: var(--surface-soft);
        border-radius: var(--radius-pill);
        padding: var(--space-xs);
      }
      .mode-toggle .mode-option {
        background: transparent;
        background-image: none;
        color: var(--text-muted);
        border: none;
        border-radius: var(--radius-pill);
        padding: calc(var(--space-xs) + 0.1rem) var(--space-md);
        font-size: 0.9rem;
        font-weight: 600;
        box-shadow: none;
        transform: none;
        transition: background var(--transition), color var(--transition);
      }
      .mode-toggle .mode-option:not(:disabled):hover,
      .mode-toggle .mode-option:not(:disabled):focus-visible {
        outline: none;
        background: var(--surface-muted);
        color: var(--text-primary);
      }
      .mode-toggle .mode-option.is-active {
        background: var(--accent);
        color: var(--text-on-accent);
      }
      .mode-toggle .mode-option:disabled {
        opacity: 0.6;
        cursor: wait;
      }
      .mode-toggle .mode-status {
        font-size: 0.85rem;
        color: var(--text-muted);
        min-width: 6ch;
      }
      .pill.has-success-glow {
        border-color: rgba(74, 222, 128, 0.45);
        box-shadow: var(--shadow-sm), var(--glow-success);
      }
      .pill.has-danger-glow {
        border-color: rgba(255, 69, 58, 0.35);
        box-shadow: var(--shadow-sm), var(--glow-danger);
      }
      main {
        flex: 1 1 auto;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: clamp(var(--space-lg), 4vw, var(--space-2xl));
      }
      .stream-wrapper {
        width: min(100%, max(320px, calc(100vh - 6rem)));
        max-width: min(1100px, max(360px, calc(100vh - 3rem)));
        margin: 0;
      }
      .stream-display {
        display: block;
        width: 100%;
        background: linear-gradient(160deg, var(--surface-0), var(--surface-1));
        border-radius: var(--radius-lg);
        border: 1px solid var(--border-subtle);
        box-shadow: var(--shadow-lg);
        transition: box-shadow var(--transition);
      }
      .stream-display[hidden] {
        display: none;
      }
      video.stream-display {
        background-color: black;
        object-fit: contain;
      }
      button {
        background: linear-gradient(135deg, var(--accent), var(--accent-hover));
        color: var(--text-on-accent);
        border: none;
        padding: var(--control-padding-y) var(--control-padding-x);
        border-radius: var(--radius-pill);
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: background var(--transition), box-shadow var(--transition),
          transform var(--transition);
      }
      button:not(:disabled):hover {
        background: linear-gradient(135deg, var(--accent-hover), var(--accent-active));
        box-shadow: 0 12px 26px var(--accent-shadow);
        transform: translateY(-1px);
      }
      button:not(:disabled):focus-visible {
        background: linear-gradient(135deg, var(--accent-hover), var(--accent-active));
        box-shadow: 0 12px 26px var(--accent-shadow),
          0 0 0 1px var(--accent-active), 0 0 0 4px var(--accent-soft);
        transform: translateY(-1px);
      }
      button:focus-visible {
        outline: none;
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        box-shadow: none;
        transform: none;
      }
      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
      .control-group {
        display: flex;
        gap: var(--space-sm);
        flex-wrap: wrap;
      }
      .control-group button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: var(--space-xs);
        background: var(--surface-1);
        border: 1px solid var(--border-muted);
        color: var(--text-primary);
        padding: calc(var(--control-padding-y) - 0.1rem)
          calc(var(--control-padding-x) + 0.25rem);
        border-radius: var(--radius-pill);
        font-weight: 600;
        box-shadow: var(--shadow-sm);
        backdrop-filter: blur(18px);
        -webkit-backdrop-filter: blur(18px);
        transition: transform var(--transition), box-shadow var(--transition),
          border-color var(--transition), background var(--transition),
          color var(--transition);
      }
      .control-group button:not(:disabled):hover {
        background: var(--surface-0);
        border-color: var(--accent-active);
        box-shadow: 0 16px 36px rgba(0, 0, 0, 0.45);
        transform: translateY(-1px);
        color: var(--accent-active);
      }
      .control-group button:not(:disabled):focus-visible {
        background: var(--surface-0);
        border-color: var(--accent-active);
        color: var(--accent-active);
        box-shadow: 0 16px 36px rgba(0, 0, 0, 0.45),
          0 0 0 1px var(--accent-active), 0 0 0 4px var(--accent-soft);
        transform: translateY(-1px);
      }
      .control-group button:disabled {
        opacity: 0.6;
        box-shadow: none;
        transform: none;
      }
      a.settings-link {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: var(--space-xs);
        padding: calc(var(--control-padding-y) - 0.1rem)
          calc(var(--control-padding-x) + 0.25rem);
        border-radius: var(--radius-pill);
        background: var(--surface-1);
        border: 1px solid var(--border-muted);
        color: var(--text-primary);
        font-weight: 600;
        text-decoration: none;
        box-shadow: var(--shadow-sm);
        backdrop-filter: blur(18px);
        -webkit-backdrop-filter: blur(18px);
        cursor: pointer;
        transition: transform var(--transition), box-shadow var(--transition),
          border-color var(--transition), background var(--transition),
          color var(--transition);
        white-space: nowrap;
      }
      a.settings-link:hover,
      a.settings-link:focus-visible {
        background: var(--surface-0);
        border-color: var(--accent-active);
        box-shadow: 0 16px 36px rgba(0, 0, 0, 0.45);
        transform: translateY(-1px);
        color: var(--accent-active);
      }
      a.settings-link:focus-visible {
        outline: none;
        box-shadow: 0 16px 36px rgba(0, 0, 0, 0.45),
          0 0 0 1px var(--accent-active), 0 0 0 4px var(--accent-soft);
      }
      .status-pill {
        color: var(--text-muted);
        gap: var(--space-md);
        font-weight: 600;
        transition: color var(--transition), box-shadow var(--transition);
        flex: 1 1 clamp(6.25rem, 9vw, 8.6rem);
      }
      .header-panels > .pill {
        min-height: 1.15rem;
      }
      .illumination-pill {
        display: inline-flex;
        flex: 1 1 clamp(20.8rem, 29.9vw, 28.6rem);
        flex-wrap: wrap;
        align-items: center;
        gap: var(--space-md);
        color: var(--text-primary);
        transition: color var(--transition), box-shadow var(--transition),
          border-color var(--transition);
      }
      .illumination-pill.unavailable {
        opacity: 0.6;
      }
      .illumination-pill.is-active {
        color: var(--success);
      }
      .illumination-pill button {
        flex: 0 0 auto;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 1.375rem;
        height: 1.375rem;
        padding: 0;
        border-radius: 50%;
        background: var(--surface-1);
        border: 1px solid transparent;
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.35);
        transition: transform var(--transition), box-shadow var(--transition),
          border-color var(--transition), background var(--transition);
        color: inherit;
      }
      .illumination-pill button:not(:disabled):hover,
      .illumination-pill button:not(:disabled):focus-visible {
        background: rgba(255, 255, 255, 0.12);
        border-color: rgba(255, 255, 255, 0.18);
        box-shadow: 0 14px 32px rgba(0, 0, 0, 0.4);
        transform: translateY(-1px);
      }
      .illumination-pill button:not(:disabled):focus-visible {
        outline: none;
        box-shadow: 0 14px 32px rgba(0, 0, 0, 0.4),
          0 0 0 1px rgba(255, 255, 255, 0.25), 0 0 0 4px rgba(255, 255, 255, 0.08);
      }
      .illumination-pill.is-active button {
        background: rgba(74, 222, 128, 0.12);
        border-color: rgba(74, 222, 128, 0.45);
        box-shadow: var(--glow-success);
      }
      .illumination-pill.is-active button:not(:disabled):hover,
      .illumination-pill.is-active button:not(:disabled):focus-visible {
        background: rgba(74, 222, 128, 0.16);
        border-color: rgba(74, 222, 128, 0.5);
        box-shadow: var(--glow-success), 0 0 0 1px rgba(74, 222, 128, 0.55),
          0 0 0 4px rgba(74, 222, 128, 0.2);
      }
      .illumination-toggle-icon {
        width: 0.9rem;
        height: 0.9rem;
      }
      .illumination-toggle-icon .bulb-glass {
        fill: rgba(255, 255, 255, 0.12);
        stroke: currentColor;
        stroke-width: 1.2;
      }
      .illumination-toggle-icon .bulb-base {
        fill: currentColor;
        opacity: 0.85;
      }
      .illumination-toggle-icon .bulb-filament {
        stroke: currentColor;
        stroke-width: 1.5;
        stroke-linecap: round;
      }
      .illumination-toggle-icon .bulb-rays {
        stroke: currentColor;
        stroke-width: 1.4;
        stroke-linecap: round;
        opacity: 0;
        transition: opacity var(--transition);
      }
      .illumination-pill.is-active .illumination-toggle-icon .bulb-glass {
        fill: rgba(74, 222, 128, 0.3);
      }
      .illumination-pill.is-active .illumination-toggle-icon .bulb-rays {
        opacity: 1;
      }
      .illumination-pill.is-active .illumination-toggle-icon .bulb-filament {
        stroke-width: 1.8;
      }
      .illumination-pill.is-active .illumination-slider input[type="range"] {
        background: linear-gradient(
          90deg,
          rgba(74, 222, 128, 0.45),
          rgba(74, 222, 128, 0.2)
        );
        box-shadow: inset 0 0 0 1px rgba(74, 222, 128, 0.4);
      }
      .illumination-pill.is-active .illumination-slider input[type="range"]::-webkit-slider-thumb {
        background: var(--success);
        box-shadow: 0 0 0 2px rgba(74, 222, 128, 0.45);
      }
      .illumination-pill.is-active .illumination-slider input[type="range"]::-moz-range-thumb {
        background: var(--success);
        box-shadow: 0 0 0 2px rgba(74, 222, 128, 0.45);
      }
      .illumination-slider,
      .illumination-colour {
        display: flex;
        align-items: center;
        gap: var(--space-xs);
        font-size: 0.9rem;
        color: var(--text-muted);
      }
      .illumination-pill.is-active .illumination-slider,
      .illumination-pill.is-active .illumination-colour {
        color: inherit;
      }
      .illumination-slider input[type="range"] {
        appearance: none;
        width: 8rem;
        height: 0.4rem;
        border-radius: var(--radius-pill);
        background: var(--surface-soft);
        box-shadow: inset 0 0 0 1px var(--border-subtle);
        cursor: pointer;
      }
      .illumination-slider input[type="range"]::-webkit-slider-thumb {
        appearance: none;
        width: 1rem;
        height: 1rem;
        border-radius: 50%;
        background: var(--accent);
        box-shadow: 0 0 0 2px rgba(10, 132, 255, 0.45);
        cursor: pointer;
        border: none;
      }
      .illumination-slider input[type="range"]::-moz-range-thumb {
        width: 1rem;
        height: 1rem;
        border-radius: 50%;
        background: var(--accent);
        border: none;
        box-shadow: 0 0 0 2px rgba(10, 132, 255, 0.45);
        cursor: pointer;
      }
      .illumination-slider-value {
        min-width: 2.5rem;
        text-align: right;
        font-variant-numeric: tabular-nums;
      }
      .illumination-colour input[type="color"] {
        width: 2.25rem;
        height: 2.25rem;
        border-radius: var(--radius-pill);
        border: 1px solid var(--border-muted);
        padding: 0;
        background: none;
        cursor: pointer;
      }
      .illumination-status-box {
        display: none;
        margin: var(--space-xl) auto var(--space-lg);
        width: min(720px, calc(100% - (2 * var(--space-xl))));
        padding: var(--space-md) var(--space-lg);
        border-radius: var(--radius-lg);
        background: var(--surface-1);
        border: 1px solid var(--border-muted);
        box-shadow: var(--shadow-sm);
        color: var(--text-muted);
        text-align: center;
        line-height: 1.45;
      }
      .illumination-status-box.is-visible {
        display: block;
      }
      .illumination-status-box.is-success {
        color: var(--success);
      }
      .illumination-status-box.is-error {
        color: var(--danger);
      }
      .status-icon {
        width: 1.6rem;
        height: 1.6rem;
        flex: 0 0 auto;
      }
      .status-icon .icon {
        opacity: 0;
        transition: opacity var(--transition);
      }
      .status-pill.is-busy .icon-busy circle:first-of-type {
        animation: status-busy-track 1.4s linear infinite;
        transform-origin: center;
      }
      .status-pill.is-busy .icon-busy circle:last-of-type {
        animation: status-busy-pulse 1.4s ease-in-out infinite;
        transform-origin: center;
      }
      .status-pill.is-live .icon-live,
      .status-pill.is-paused .icon-paused,
      .status-pill.is-error .icon-error,
      .status-pill.is-busy .icon-busy {
        opacity: 1;
      }
      .status-pill.is-live {
        color: var(--success);
      }
      .status-pill.is-paused {
        color: var(--caution);
      }
      .status-pill.is-error {
        color: var(--danger);
      }
      .status-pill.is-busy {
        color: var(--info);
      }
      .status-copy {
        display: flex;
        flex-direction: column;
        line-height: 1.1;
        gap: 0.15rem;
        min-width: 0;
      }
      #status {
        font-size: 0.95rem;
        font-weight: 600;
        white-space: nowrap;
        transition: color var(--transition), opacity var(--transition);
      }
      #status-subtext {
        display: inline-flex;
        align-items: center;
        gap: var(--space-xs);
        font-size: 0.75rem;
        font-weight: 500;
        letter-spacing: 0.02em;
        color: var(--text-muted);
        white-space: nowrap;
        transition: color var(--transition), opacity var(--transition);
      }
      #status-subtext:empty {
        display: none;
      }
      #status,
      #status-subtext:not(:empty) {
        animation: status-reveal var(--transition) ease;
      }
      #battery-indicator {
        align-items: center;
      }
      .battery-pill {
        font-weight: 600;
        color: var(--text-primary);
        flex: 1 1 clamp(8.95rem, 12.9vw, 12.3rem);
      }
      .battery-pill.low {
        color: var(--danger);
      }
      .battery-pill.charging {
        color: var(--success);
      }
      .battery-pill.unavailable {
        color: var(--text-muted);
        box-shadow: none;
      }
      .battery-icon {
        width: 3.9rem;
        height: 2.25rem;
        flex: 0 0 auto;
      }
      .battery-outline {
        fill: none;
        stroke: currentColor;
        stroke-width: 2;
        opacity: 0.85;
      }
      .battery-terminal {
        fill: currentColor;
        opacity: 0.85;
      }
      .battery-fill {
        fill: currentColor;
        opacity: 0.9;
        transition: width 0.35s ease;
      }
      .battery-bolt {
        fill: currentColor;
        opacity: 0;
        transition: opacity var(--transition);
      }
      .battery-pill.charging .battery-bolt {
        opacity: 1;
      }
      .battery-copy {
        display: flex;
        flex-direction: column;
        line-height: 1.1;
        gap: 0.15rem;
        align-items: flex-start;
        min-width: 0;
      }
      #battery-text {
        font-size: 0.95rem;
      }
      #battery-details {
        font-size: 0.72rem;
        color: var(--text-muted);
        white-space: nowrap;
      }
      .battery-pill.charging #battery-details::before {
        content: "⚡";
        display: inline-block;
        margin-right: 0.35rem;
        font-size: 0.75rem;
        vertical-align: middle;
      }
      @keyframes status-busy-track {
        0% {
          stroke-dashoffset: 8;
          transform: rotate(0deg);
        }
        100% {
          stroke-dashoffset: -24;
          transform: rotate(360deg);
        }
      }
      @keyframes status-busy-pulse {
        0%,
        100% {
          opacity: 0.4;
          transform: scale(0.9);
        }
        50% {
          opacity: 1;
          transform: scale(1);
        }
      }
      @keyframes status-reveal {
        from {
          opacity: 0;
          transform: translateY(0.3rem);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      @media (max-width: 960px) {
        .stream-display {
          border-radius: calc(var(--radius-lg) - 0.25rem);
          box-shadow: 0 28px 70px rgba(0, 0, 0, 0.55);
        }
      }
      @media (max-width: 640px) {
        header,
        footer {
          align-items: stretch;
        }
        .header-panels {
          width: 100%;
          justify-content: center;
          margin-left: 0;
        }
        .header-panels > .pill {
          width: 100%;
        }
        #status,
        #status-subtext,
        #battery-details {
          white-space: normal;
        }
        .control-group {
          width: 100%;
          justify-content: center;
        }
        footer {
          justify-content: center;
          text-align: center;
        }
        .illumination-status-box {
          width: calc(100% - (2 * var(--space-lg)));
          margin: var(--space-lg) auto var(--space-lg);
        }
      }
    </style>
  </head>
  <body>
    <header>
      <strong class="brand">RevCam</strong>
      <div class="header-panels">
        <div class="pill mode-toggle" id="mode-toggle" role="group" aria-label="Operating mode">
          <span class="mode-label">Mode</span>
          <div class="mode-buttons" role="group">
            <button type="button" class="mode-option" data-mode-option="reversing" aria-pressed="false">
              Reversing
            </button>
            <button type="button" class="mode-option" data-mode-option="surveillance" aria-pressed="false">
              Surveillance
            </button>
          </div>
          <span class="mode-status" id="mode-status">Loading…</span>
        </div>
        <div class="pill status-pill is-busy" id="status-pill" role="status" aria-live="polite">
          <svg class="status-icon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <g class="icon icon-live">
              <path
                d="M4 10a8 8 0 0 1 16 0"
                fill="none"
                stroke="currentColor"
                stroke-width="1.8"
                stroke-linecap="round"
              ></path>
              <path
                d="M7.5 13a4.5 4.5 0 0 1 9 0"
                fill="none"
                stroke="currentColor"
                stroke-width="1.8"
                stroke-linecap="round"
              ></path>
              <circle cx="12" cy="16" r="2.2" fill="currentColor"></circle>
            </g>
            <g class="icon icon-paused">
              <rect x="7" y="6.5" width="3.5" height="11" rx="1" fill="currentColor"></rect>
              <rect x="13.5" y="6.5" width="3.5" height="11" rx="1" fill="currentColor"></rect>
            </g>
            <g class="icon icon-busy">
              <circle
                cx="12"
                cy="12"
                r="7"
                fill="none"
                stroke="currentColor"
                stroke-width="1.8"
                stroke-linecap="round"
                stroke-dasharray="32"
                stroke-dashoffset="8"
              ></circle>
              <circle cx="12" cy="4.5" r="1.6" fill="currentColor"></circle>
            </g>
            <g class="icon icon-error">
              <path d="M12 5l7 12H5z" fill="currentColor"></path>
            </g>
          </svg>
          <div class="status-copy">
            <span id="status">Initialising…</span>
            <span id="status-subtext"></span>
          </div>
        </div>
        <div
          id="battery-indicator"
          class="pill battery-pill unavailable"
          aria-live="polite"
          aria-label="Battery unavailable"
        >
          <svg
            class="battery-icon"
            id="battery-icon"
            viewBox="0 0 52 28"
            aria-hidden="true"
            focusable="false"
          >
            <rect class="battery-outline" x="2" y="6" width="36" height="16" rx="4" ry="4"></rect>
            <rect class="battery-fill" id="battery-level" x="4" y="8" width="0" height="12" rx="3" ry="3"></rect>
            <rect class="battery-terminal" x="38" y="11" width="8" height="6" rx="1.5" ry="1.5"></rect>
            <path class="battery-bolt" d="M27 9l-4 6h3l-1 6 4-7h-3l1-5z"></path>
          </svg>
          <div class="battery-copy">
            <span id="battery-text">—%</span>
            <span id="battery-details">Battery unavailable</span>
          </div>
        </div>
        <div class="pill illumination-pill" id="illumination-controls" aria-live="polite">
          <button
            id="toggle-illumination"
            type="button"
            aria-pressed="false"
            aria-label="Enable illumination"
            title="Enable illumination"
          >
            <svg
              class="illumination-toggle-icon"
              viewBox="0 0 24 24"
              aria-hidden="true"
              focusable="false"
            >
              <path
                class="bulb-glass"
                d="M12 3.2a6.3 6.3 0 0 0-3.85 11.32c.18.14.28.36.28.59V17a1 1 0 0 0 1 1h5.14a1 1 0 0 0 1-1v-1.89c0-.23.1-.45.28-.59A6.3 6.3 0 0 0 12 3.2Z"
              ></path>
              <path
                class="bulb-filament"
                d="M10 13.25h4"
              ></path>
              <path
                class="bulb-base"
                d="M9.75 17h4.5v1.75a1.25 1.25 0 0 1-1.25 1.25h-2a1.25 1.25 0 0 1-1.25-1.25Z"
              ></path>
              <g class="bulb-rays">
                <path d="M12 2v1.4"></path>
                <path d="M6.6 4.6l1 1"></path>
                <path d="M4.5 10.2h1.4"></path>
                <path d="M17.4 5.6l-1 1"></path>
                <path d="M18.1 10.2h1.4"></path>
              </g>
            </svg>
          </button>
          <label class="illumination-slider" for="illumination-intensity">
            <span>Intensity</span>
            <input
              id="illumination-intensity"
              type="range"
              min="0"
              max="100"
              step="1"
              value="100"
            />
            <span class="illumination-slider-value" id="illumination-intensity-display">100%</span>
          </label>
          <label class="illumination-colour" for="illumination-colour">
            <span>Colour</span>
            <input id="illumination-colour" type="color" value="#FFFFFF" />
          </label>
        </div>
      </div>
    </header>
    <main>
      <figure class="stream-wrapper" aria-labelledby="stream-caption">
        <video
          id="stream-video"
          class="stream-display"
          autoplay
          playsinline
          muted
          hidden
        ></video>
        <img id="stream-fallback" class="stream-display" alt="Camera feed" hidden />
        <figcaption id="stream-caption" class="sr-only">Live camera feed</figcaption>
      </figure>
    </main>
    <div
      class="illumination-status-box"
      id="illumination-status"
      role="status"
      aria-live="polite"
      aria-hidden="true"
    ></div>
    <footer>
      <div class="control-group">
        <button id="toggle-stream" type="button" aria-pressed="false">Pause stream</button>
        <button id="toggle-fullscreen" type="button" aria-pressed="false">
          Enter full screen
        </button>
        <button id="reconnect" type="button">Reconnect</button>
        <button id="save-snapshot" type="button">Save snapshot</button>
      </div>
      <div class="footer-links">
        <a class="settings-link" href="/surveillance">Surveillance</a>
        <a class="settings-link" href="/settings">Settings</a>
      </div>
    </footer>
    <script>
      const statusLabel = document.getElementById("status");
      const reconnectButton = document.getElementById("reconnect");
      const streamVideo = document.getElementById("stream-video");
      const streamImage = document.getElementById("stream-fallback");
      const toggleButton = document.getElementById("toggle-stream");
      const fullscreenButton = document.getElementById("toggle-fullscreen");
      const snapshotButton = document.getElementById("save-snapshot");
      const batteryIndicator = document.getElementById("battery-indicator");
      const batteryIcon = document.getElementById("battery-icon");
      const batteryLevel = document.getElementById("battery-level");
      const batteryText = document.getElementById("battery-text");
      const batteryDetails = document.getElementById("battery-details");
      const statusPill = document.getElementById("status-pill");
      const statusSubtext = document.getElementById("status-subtext");
      const illuminationControls = document.getElementById("illumination-controls");
      const illuminationToggle = document.getElementById("toggle-illumination");
      const illuminationIntensityInput = document.getElementById("illumination-intensity");
      const illuminationIntensityDisplay = document.getElementById("illumination-intensity-display");
      const illuminationColourInput = document.getElementById("illumination-colour");
      const illuminationStatusBox = document.getElementById("illumination-status");
      const modeToggle = document.getElementById("mode-toggle");
      const modeStatus = document.getElementById("mode-status");
      const modeButtons = modeToggle
        ? Array.from(modeToggle.querySelectorAll(".mode-option"))
        : [];
      const BATTERY_LEVEL_MAX = 32;
      let activeMode = null;
      let modeSwitching = false;
      const isFullscreenSupported = () => {
        if (document.fullscreenEnabled || document.webkitFullscreenEnabled) {
          return true;
        }
        if (typeof streamVideo.webkitSupportsFullscreen === "boolean") {
          return streamVideo.webkitSupportsFullscreen;
        }
        return typeof streamVideo.webkitEnterFullscreen === "function";
      };

      const isVideoFullscreen = () =>
        document.fullscreenElement === streamVideo ||
        document.webkitFullscreenElement === streamVideo ||
        Boolean(streamVideo.webkitDisplayingFullscreen);

      const updateFullscreenButtonState = () => {
        if (!fullscreenButton) return;
        const active = isVideoFullscreen();
        fullscreenButton.setAttribute("aria-pressed", String(active));
        fullscreenButton.textContent = active ? "Exit full screen" : "Enter full screen";
      };

      const updateFullscreenAvailability = () => {
        if (!fullscreenButton) return;
        const supported = isFullscreenSupported();
        fullscreenButton.disabled = !supported;
        if (supported) {
          fullscreenButton.removeAttribute("aria-disabled");
        } else {
          fullscreenButton.setAttribute("aria-disabled", "true");
          fullscreenButton.setAttribute("aria-pressed", "false");
        }
      };

      const requestVideoFullscreen = async () => {
        if (!isFullscreenSupported()) {
          return;
        }

        try {
          if (streamVideo.requestFullscreen) {
            await streamVideo.requestFullscreen();
          } else if (streamVideo.webkitRequestFullscreen) {
            streamVideo.webkitRequestFullscreen();
          } else if (streamVideo.webkitEnterFullscreen) {
            streamVideo.webkitEnterFullscreen();
          } else if (streamVideo.parentElement && streamVideo.parentElement.requestFullscreen) {
            await streamVideo.parentElement.requestFullscreen();
          }
        } catch (error) {
          console.error("Unable to enter full screen", error);
        }
      };

      const exitVideoFullscreen = async () => {
        if (document.fullscreenElement === streamVideo || document.webkitFullscreenElement === streamVideo) {
          if (document.exitFullscreen) {
            await document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          }
        } else if (streamVideo.webkitDisplayingFullscreen && streamVideo.webkitExitFullscreen) {
          streamVideo.webkitExitFullscreen();
        }
      };

      if (fullscreenButton) {
        updateFullscreenAvailability();

        fullscreenButton.addEventListener("click", async () => {
          if (fullscreenButton.disabled) {
            return;
          }
          if (isVideoFullscreen()) {
            await exitVideoFullscreen();
          } else {
            await requestVideoFullscreen();
          }
          updateFullscreenButtonState();
        });

        const fullscreenEvents = [
          "fullscreenchange",
          "webkitfullscreenchange",
          "webkitbeginfullscreen",
          "webkitendfullscreen",
        ];

        fullscreenEvents.forEach((eventName) => {
          const target =
            eventName === "webkitbeginfullscreen" || eventName === "webkitendfullscreen"
              ? streamVideo
              : document;
          target.addEventListener(eventName, () => {
            updateFullscreenButtonState();
            updateFullscreenAvailability();
          });
        });

        const availabilityEvents = [
          "loadedmetadata",
          "loadeddata",
          "canplay",
          "canplaythrough",
        ];
        availabilityEvents.forEach((eventName) => {
          streamVideo.addEventListener(eventName, updateFullscreenAvailability, {
            once: eventName === "loadedmetadata",
          });
        });

        updateFullscreenButtonState();
      }
      const STATUS_CLASSES = ["is-live", "is-paused", "is-error", "is-busy"];
      function applyStatusState(reference) {
        if (!statusPill) {
          return;
        }
        const descriptor = typeof reference === "string" ? reference.toLowerCase() : "";
        statusPill.classList.remove(...STATUS_CLASSES);
        statusPill.classList.remove("has-success-glow", "has-danger-glow");
        let targetClass = "is-busy";
        if (descriptor.includes("error") || descriptor.includes("fail") || descriptor.includes("lost")) {
          targetClass = "is-error";
        } else if (descriptor.includes("pause") || descriptor.includes("stop")) {
          targetClass = "is-paused";
        } else if (descriptor.includes("stream") || descriptor.includes("live") || descriptor.includes("play")) {
          targetClass = "is-live";
        }
        statusPill.classList.add(targetClass);
        if (targetClass === "is-live") {
          statusPill.classList.add("has-success-glow");
        } else if (targetClass === "is-error") {
          statusPill.classList.add("has-danger-glow");
        }
      }

      let statusModeText = "";

      function renderStatusSubtext() {
        if (!statusSubtext) {
          return;
        }
        statusSubtext.textContent = statusModeText;
      }

      function setStatus(message, stateHint) {
        if (statusLabel) {
          statusLabel.textContent = message;
        }
        applyStatusState(stateHint || message);
      }

      function formatModeLabel(mode) {
        if (!mode) return "Unknown";
        return mode.charAt(0).toUpperCase() + mode.slice(1);
      }

      function updateModeToggle(mode, { busy = false, message } = {}) {
        if (!modeToggle) {
          return;
        }
        for (const button of modeButtons) {
          const target = button.dataset.modeOption;
          const isActive = target === mode;
          button.classList.toggle("is-active", isActive);
          button.setAttribute("aria-pressed", String(isActive));
          button.disabled = busy;
        }
        if (modeStatus) {
          if (message) {
            modeStatus.textContent = message;
          } else if (mode) {
            modeStatus.textContent = formatModeLabel(mode);
          } else {
            modeStatus.textContent = "Unknown";
          }
        }
      }

      async function fetchMode() {
        if (!modeToggle) {
          return;
        }
        updateModeToggle(activeMode, { busy: true, message: "Loading…" });
        try {
          const response = await fetch("/api/mode");
          if (!response.ok) {
            throw new Error("Unable to determine mode");
          }
          const payload = await response.json();
          activeMode = payload.mode;
          updateModeToggle(activeMode);
        } catch (error) {
          console.error(error);
          updateModeToggle(activeMode, { message: error.message || "Unavailable" });
        }
      }

      function navigateToMode(mode) {
        if (!mode) {
          return;
        }
        const currentPath = window.location.pathname.replace(/\/+$/, "") || "/";
        if (mode === "surveillance") {
          if (currentPath !== "/surveillance") {
            window.location.href = "/surveillance";
          }
        } else if (mode === "reversing") {
          if (currentPath !== "/" && currentPath !== "/index.html") {
            window.location.href = "/";
          }
        }
      }

      async function changeMode(requested) {
        if (!modeToggle || !requested || modeSwitching || requested === activeMode) {
          return;
        }
        modeSwitching = true;
        updateModeToggle(activeMode, { busy: true, message: "Switching…" });
        try {
          const response = await fetch("/api/mode", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ mode: requested }),
          });
          if (!response.ok) {
            let detail = `Failed (${response.status})`;
            try {
              const errorPayload = await response.json();
              if (errorPayload?.detail) {
                detail = errorPayload.detail;
              }
            } catch (parseError) {
              console.error(parseError);
            }
            throw new Error(detail);
          }
          const payload = await response.json();
          activeMode = payload.mode;
          updateModeToggle(activeMode);
          setStatus(`Mode: ${formatModeLabel(activeMode)}`, "live");
          navigateToMode(activeMode);
        } catch (error) {
          console.error(error);
          updateModeToggle(activeMode, { message: error.message || "Switch failed" });
          setStatus("Mode switch failed", "error");
        } finally {
          modeSwitching = false;
        }
      }

      function setStreamModeLabel(mode) {
        if (mode === "webrtc") {
          statusModeText = "WebRTC stream";
        } else if (mode === "mjpeg") {
          statusModeText = "MJPEG stream";
        } else {
          statusModeText = "";
        }
        renderStatusSubtext();
      }

      function setChargingState() {
        if (statusPill) {
          statusPill.classList.remove("is-charging");
        }
      }

      let reconnectTimer = null;
      let batteryTimer = null;
      let shouldStream = false;
      let peerConnection = null;
      let activeStreamMode = null;
      const webrtcSupported = typeof window.RTCPeerConnection === "function";
      let streamCapabilities = null;

      function extractWebRTCErrorMessage(error) {
        if (!error) {
          return "Unknown error";
        }
        if (typeof error === "string") {
          return error;
        }
        if (error instanceof Error) {
          return error.message || error.name || "Unknown error";
        }
        if (typeof error === "object") {
          const possible = [error.message, error.error, error.reason, error.name];
          for (const value of possible) {
            if (typeof value === "string" && value.trim()) {
              return value;
            }
          }
          try {
            return JSON.stringify(error);
          } catch (jsonError) {
            console.debug("Failed to serialise WebRTC error", jsonError);
          }
        }
        return String(error);
      }

      function summariseWebRTCError(error) {
        const raw = extractWebRTCErrorMessage(error).trim() || "Unknown error";
        if (raw.length <= 160) {
          return raw;
        }
        return `${raw.slice(0, 157)}…`;
      }

      function reportWebRTCFailure(error) {
        try {
          const payload = {
            message: summariseWebRTCError(error),
          };
          if (error && typeof error === "object") {
            if (typeof error.name === "string" && error.name.trim()) {
              payload.name = error.name.trim().slice(0, 128);
            }
            if (typeof error.stack === "string" && error.stack.trim()) {
              payload.stack = error.stack.trim().slice(0, 4096);
            }
          }
          const body = JSON.stringify(payload);
          if (navigator.sendBeacon) {
            const blob = new Blob([body], { type: "application/json" });
            if (navigator.sendBeacon("/api/log/webrtc-error", blob)) {
              return;
            }
          }
          fetch("/api/log/webrtc-error", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            keepalive: true,
            body,
          }).catch((reportError) =>
            console.debug("Failed to report WebRTC error", reportError),
          );
        } catch (loggingError) {
          console.debug("Failed to prepare WebRTC error report", loggingError);
        }
      }

      function getWebRTCCapabilities() {
        if (!streamCapabilities || typeof streamCapabilities !== "object") {
          return null;
        }
        const { webrtc } = streamCapabilities;
        if (!webrtc || typeof webrtc !== "object") {
          return null;
        }
        return webrtc;
      }

      function getWebRTCErrorMessage() {
        const details = getWebRTCCapabilities();
        if (!details) {
          return "";
        }
        if (typeof details.error === "string" && details.error.trim()) {
          return details.error.trim();
        }
        return "";
      }

      function isServerWebRTCReady() {
        const details = getWebRTCCapabilities();
        if (!details) {
          return false;
        }
        if (details.enabled !== true) {
          return false;
        }
        if (typeof details.error === "string" && details.error.trim()) {
          return false;
        }
        return true;
      }

      function isStreamingServiceAvailable() {
        if (!streamCapabilities || typeof streamCapabilities !== "object") {
          return true;
        }
        return streamCapabilities.enabled !== false;
      }

      async function refreshStreamCapabilities() {
        try {
          const response = await fetch("/api/stream", { cache: "no-store" });
          if (!response.ok) {
            throw new Error(`Stream info request failed with ${response.status}`);
          }
          const payload = await response.json();
          streamCapabilities =
            payload && typeof payload === "object" ? payload : null;
        } catch (error) {
          console.error("Stream info error", error);
          streamCapabilities = null;
          return null;
        }
        return streamCapabilities;
      }

      async function waitForIceGatheringComplete(peerConnection, timeout = 4000) {
        if (!peerConnection) {
          throw new Error("Missing peer connection");
        }
        if (peerConnection.iceGatheringState === "complete") {
          return;
        }

        await new Promise((resolve) => {
          let finished = false;
          const timer = window.setTimeout(() => {
            finished = true;
            peerConnection.removeEventListener(
              "icegatheringstatechange",
              handleStateChange,
            );
            resolve();
          }, timeout);

          function cleanup() {
            if (finished) {
              return;
            }
            finished = true;
            window.clearTimeout(timer);
            peerConnection.removeEventListener(
              "icegatheringstatechange",
              handleStateChange,
            );
            resolve();
          }

          function handleStateChange() {
            if (peerConnection.iceGatheringState === "complete") {
              cleanup();
            }
          }

          peerConnection.addEventListener(
            "icegatheringstatechange",
            handleStateChange,
          );
          handleStateChange();
        });
      }
      let illuminationState = null;
      let illuminationPreviousPattern = null;
      let illuminationBusy = false;
      let illuminationLoading = false;
      let illuminationStatusTimer = null;
      setStatus(statusLabel ? statusLabel.textContent : "Initialising…", "busy");

      function updateBatteryUI(data) {
        if (
          !batteryIndicator ||
          !batteryIcon ||
          !batteryLevel ||
          !batteryText ||
          !batteryDetails
        ) {
          return;
        }
        batteryIndicator.classList.remove(
          "low",
          "charging",
          "unavailable",
          "has-success-glow",
          "has-danger-glow",
        );
        batteryIcon.classList.remove("low", "charging", "unavailable");

        if (!data || data.available !== true || typeof data.percentage !== "number") {
          batteryIndicator.classList.add("unavailable");
          batteryIcon.classList.add("unavailable");
          batteryLevel.setAttribute("width", "0");
          batteryText.textContent = "—%";
          const fallback =
            data && typeof data.error === "string" && data.error.trim()
              ? data.error.trim()
              : "Battery unavailable";
          batteryDetails.textContent = fallback;
          batteryIndicator.setAttribute("aria-label", fallback);
          setChargingState();
          return;
        }

        const rawPercentage = Number(data.percentage);
        if (!Number.isFinite(rawPercentage)) {
          batteryIndicator.classList.add("unavailable");
          batteryIcon.classList.add("unavailable");
          batteryLevel.setAttribute("width", "0");
          batteryText.textContent = "—%";
          batteryDetails.textContent = "Battery unavailable";
          batteryIndicator.setAttribute("aria-label", "Battery unavailable");
          setChargingState();
          return;
        }

        const percentage = Math.max(0, Math.min(100, rawPercentage));
        const fillWidth = Math.round((percentage / 100) * BATTERY_LEVEL_MAX);
        const clampedWidth = Math.max(0, Math.min(BATTERY_LEVEL_MAX, fillWidth));
        const visibleWidth = clampedWidth > 0 ? Math.max(3, clampedWidth) : 0;
        batteryLevel.setAttribute("width", String(visibleWidth));
        const rounded = Math.round(percentage);
        batteryText.textContent = `${rounded}%`;

        if (data.charging === true) {
          batteryIndicator.classList.add("charging", "has-success-glow");
          batteryIcon.classList.add("charging");
        } else if (percentage <= 20) {
          batteryIndicator.classList.add("low", "has-danger-glow");
          batteryIcon.classList.add("low");
        }

        const detailParts = [];
        if (typeof data.voltage === "number" && Number.isFinite(data.voltage)) {
          detailParts.push(`${data.voltage.toFixed(2)} V`);
        }
        if (typeof data.current_ma === "number" && Number.isFinite(data.current_ma)) {
          const magnitude = Math.abs(data.current_ma);
          const decimals = magnitude >= 100 ? 0 : magnitude >= 10 ? 1 : 2;
          const formatted = magnitude.toFixed(decimals);
          const suffix = data.charging === true ? "" : " draw";
          detailParts.push(`${formatted} mA${suffix}`.trim());
        }
        const detailText = detailParts.join(" · ") || "Battery OK";
        batteryDetails.textContent = detailText;
        const detailDescription = detailParts.join(", ") || "status";
        const ariaParts = [`Battery ${rounded}%`, detailDescription];
        if (data.charging === true) {
          ariaParts.push("charging");
        }
        batteryIndicator.setAttribute("aria-label", ariaParts.join(", "));
        setChargingState();
      }

      async function refreshBattery() {
        if (!batteryIcon || !batteryLevel) {
          return;
        }
        try {
          const response = await fetch("/api/battery", { cache: "no-store" });
          if (!response.ok) {
            throw new Error(`Battery request failed with ${response.status}`);
          }
          const payload = await response.json();
          updateBatteryUI(payload);
        } catch (error) {
          console.error("Battery status error", error);
          updateBatteryUI({ available: false, error: "Battery offline" });
        }
      }

      function scheduleBatteryUpdates(interval = 15000) {
        if (!batteryIcon || !batteryLevel || !batteryText || !batteryDetails) {
          return;
        }
        if (batteryTimer) {
          clearInterval(batteryTimer);
        }
        refreshBattery();
        batteryTimer = setInterval(refreshBattery, interval);
      }

      function setIlluminationStatus(message, options = {}) {
        if (!illuminationStatusBox) {
          return;
        }
        if (illuminationStatusTimer) {
          window.clearTimeout(illuminationStatusTimer);
          illuminationStatusTimer = null;
        }
        const text =
          typeof message === "string" && message.trim() ? message.trim() : "";
        illuminationStatusBox.classList.remove(
          "is-visible",
          "is-success",
          "is-error",
        );
        illuminationStatusBox.textContent = text;
        if (text) {
          let tone = options.tone;
          if (!tone) {
            const descriptor = text.toLowerCase();
            if (
              descriptor.includes("error") ||
              descriptor.includes("fail") ||
              descriptor.includes("unavailable") ||
              descriptor.includes("denied") ||
              descriptor.includes("requires")
            ) {
              tone = "error";
            } else if (
              descriptor.includes("enabled") ||
              descriptor.includes("disabled") ||
              descriptor.includes("updated") ||
              descriptor.includes("saved")
            ) {
              tone = "success";
            }
          }
          if (tone === "success") {
            illuminationStatusBox.classList.add("is-success");
          } else if (tone === "error") {
            illuminationStatusBox.classList.add("is-error");
          }
          illuminationStatusBox.classList.add("is-visible");
          illuminationStatusBox.setAttribute("aria-hidden", "false");
        } else {
          illuminationStatusBox.setAttribute("aria-hidden", "true");
        }
        if (text && options.persistent !== true) {
          illuminationStatusTimer = window.setTimeout(() => {
            if (
              illuminationStatusBox &&
              illuminationStatusBox.textContent === text
            ) {
              illuminationStatusBox.textContent = "";
              illuminationStatusBox.classList.remove(
                "is-visible",
                "is-success",
                "is-error",
              );
              illuminationStatusBox.setAttribute("aria-hidden", "true");
            }
            illuminationStatusTimer = null;
          }, 4000);
        }
      }

      function applyIlluminationState(state) {
        if (state && typeof state === "object") {
          const illuminationDetails =
            state.illumination && typeof state.illumination === "object"
              ? state.illumination
              : {};
          const rawIntensity = Number.isFinite(illuminationDetails.intensity)
            ? Number(illuminationDetails.intensity)
            : 100;
          const clampedIntensity = Math.max(0, Math.min(100, rawIntensity));
          const colourValue =
            typeof illuminationDetails.color === "string" && illuminationDetails.color.trim()
              ? illuminationDetails.color.trim()
              : "#FFFFFF";
          illuminationState = {
            pattern: typeof state.pattern === "string" ? state.pattern : "",
            active_pattern:
              typeof state.active_pattern === "string" ? state.active_pattern : "",
            error: state.error === true,
            available: state.available !== false,
            message:
              typeof state.message === "string" && state.message.trim()
                ? state.message.trim()
                : "",
            illumination: {
              intensity: clampedIntensity,
              color: colourValue,
            },
          };
        } else {
          illuminationState = null;
        }

        const available = illuminationState ? illuminationState.available : false;
        const active = illuminationState ? illuminationState.pattern === "illumination" : false;
        const message = illuminationState && illuminationState.message ? illuminationState.message : "";
        const intensity =
          illuminationState && illuminationState.illumination
            ? illuminationState.illumination.intensity
            : 100;
        const colour =
          illuminationState && illuminationState.illumination
            ? illuminationState.illumination.color
            : "#FFFFFF";

        if (illuminationControls) {
          illuminationControls.classList.toggle("unavailable", !available);
          illuminationControls.classList.toggle(
            "is-active",
            available && active,
          );
          illuminationControls.classList.toggle(
            "has-success-glow",
            available && active,
          );
        }

        if (illuminationToggle instanceof HTMLButtonElement) {
          const toggleLabel = active ? "Disable illumination" : "Enable illumination";
          illuminationToggle.disabled = !available;
          illuminationToggle.setAttribute("aria-label", toggleLabel);
          illuminationToggle.title = toggleLabel;
          illuminationToggle.setAttribute("aria-pressed", active ? "true" : "false");
          illuminationToggle.classList.toggle("is-active", available && active);
        }

        if (illuminationIntensityInput instanceof HTMLInputElement) {
          if (illuminationIntensityInput.dataset.userEdited !== "true" || !illuminationBusy) {
            illuminationIntensityInput.value = String(Math.round(intensity));
            delete illuminationIntensityInput.dataset.userEdited;
          }
          illuminationIntensityInput.disabled = !available;
          const displayValue =
            illuminationIntensityInput.dataset.userEdited === "true"
              ? Number(illuminationIntensityInput.value)
              : intensity;
          if (illuminationIntensityDisplay) {
            illuminationIntensityDisplay.textContent = `${Math.round(displayValue)}%`;
          }
        } else if (illuminationIntensityDisplay) {
          illuminationIntensityDisplay.textContent = `${Math.round(intensity)}%`;
        }

        if (illuminationColourInput instanceof HTMLInputElement) {
          if (illuminationColourInput.dataset.userEdited !== "true" || !illuminationBusy) {
            illuminationColourInput.value = colour;
            delete illuminationColourInput.dataset.userEdited;
          }
          illuminationColourInput.disabled = !available;
        }

        if (!available) {
          setIlluminationStatus(message || "LED driver unavailable", {
            persistent: true,
            tone: "error",
          });
        } else if (message) {
          setIlluminationStatus(message, { persistent: true });
        } else {
          setIlluminationStatus("");
        }

        if (
          illuminationState &&
          illuminationState.pattern &&
          illuminationState.pattern !== "illumination"
        ) {
          illuminationPreviousPattern = illuminationState.pattern;
        }
      }

      async function refreshIlluminationState({ showLoading = false } = {}) {
        if (illuminationLoading) {
          return illuminationState;
        }
        illuminationLoading = true;
        if (showLoading) {
          setIlluminationStatus("Loading illumination status…");
        }
        try {
          const response = await fetch("/api/led", { cache: "no-store" });
          if (!response.ok) {
            let detail = `LED status request failed with ${response.status}`;
            try {
              const problem = await response.json();
              if (problem && typeof problem.detail === "string" && problem.detail.trim()) {
                detail = problem.detail.trim();
              }
            } catch (err) {
              console.error(err);
            }
            throw new Error(detail);
          }
          const payload = await response.json();
          applyIlluminationState(payload);
          return payload;
        } catch (error) {
          console.error("LED status error", error);
          applyIlluminationState(null);
          const message =
            error instanceof Error && error.message
              ? error.message
              : "Unable to load illumination status.";
          setIlluminationStatus(message, { persistent: true, tone: "error" });
          return null;
        } finally {
          illuminationLoading = false;
        }
      }

      async function sendIlluminationUpdate(payload, options = {}) {
        if (!payload || typeof payload !== "object") {
          return null;
        }
        illuminationBusy = true;
        try {
          const response = await fetch("/api/led", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          if (!response.ok) {
            let detail = `LED update failed with ${response.status}`;
            try {
              const problem = await response.json();
              if (problem && typeof problem.detail === "string" && problem.detail.trim()) {
                detail = problem.detail.trim();
              }
            } catch (err) {
              console.error(err);
            }
            throw new Error(detail);
          }
          const result = await response.json();
          applyIlluminationState(result);
          if (options.successMessage) {
            setIlluminationStatus(options.successMessage, { tone: "success" });
          } else {
            setIlluminationStatus("");
          }
          return result;
        } catch (error) {
          console.error("LED update error", error);
          const message =
            error instanceof Error && error.message
              ? error.message
              : "Failed to update illumination.";
          setIlluminationStatus(message, { persistent: true, tone: "error" });
          return null;
        } finally {
          illuminationBusy = false;
          if (illuminationIntensityInput instanceof HTMLInputElement) {
            delete illuminationIntensityInput.dataset.userEdited;
          }
          if (illuminationColourInput instanceof HTMLInputElement) {
            delete illuminationColourInput.dataset.userEdited;
          }
        }
      }

      function clearReconnectTimer() {
        if (reconnectTimer) {
          clearTimeout(reconnectTimer);
          reconnectTimer = null;
        }
      }

      function teardownPeerConnection() {
        if (peerConnection) {
          try {
            peerConnection.close();
          } catch (error) {
            console.warn("Peer connection close error", error);
          }
          peerConnection = null;
        }
        if (streamVideo instanceof HTMLVideoElement) {
          try {
            streamVideo.pause();
          } catch (error) {
            console.warn("Video pause error", error);
          }
          streamVideo.srcObject = null;
          streamVideo.hidden = true;
        }
      }

      function startMjpegStream() {
        if (!(streamImage instanceof HTMLImageElement)) {
          throw new Error("MJPEG stream element unavailable");
        }
        activeStreamMode = "mjpeg";
        setStreamModeLabel("mjpeg");
        teardownPeerConnection();
        const cacheBuster = Date.now();
        streamImage.hidden = false;
        streamImage.src = `/stream/mjpeg?cb=${cacheBuster}`;
        if (streamVideo instanceof HTMLVideoElement) {
          streamVideo.hidden = true;
          streamVideo.srcObject = null;
        }
      }

      async function startWebRTCStream() {
        if (!webrtcSupported || !(streamVideo instanceof HTMLVideoElement)) {
          throw new Error("WebRTC streaming unsupported in this browser");
        }
        activeStreamMode = "webrtc";
        setStreamModeLabel("webrtc");
        if (streamImage instanceof HTMLImageElement) {
          streamImage.hidden = true;
          streamImage.removeAttribute("src");
        }
        teardownPeerConnection();

        const pc = new RTCPeerConnection();
        peerConnection = pc;
        pc.addTransceiver("video", { direction: "recvonly" });

        pc.addEventListener("connectionstatechange", () => {
          if (!shouldStream || activeStreamMode !== "webrtc") {
            return;
          }
          const state = pc.connectionState;
          if (state === "connected") {
            setStatus("Streaming", "live");
          } else if (state === "failed" || state === "disconnected") {
            setStatus("Connection lost – retrying…", "error");
            reportWebRTCFailure(new Error(`Peer connection state ${state}`));
            scheduleReconnect();
          }
        });

        pc.addEventListener("track", (event) => {
          if (!shouldStream || activeStreamMode !== "webrtc") {
            return;
          }
          const [remoteStream] = event.streams;
          if (remoteStream && streamVideo.srcObject !== remoteStream) {
            streamVideo.srcObject = remoteStream;
            streamVideo.hidden = false;
            streamVideo
              .play()
              .catch((error) => console.warn("Video playback failed", error));
          }
        });

        try {
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          await waitForIceGatheringComplete(pc);
          const localDescription = pc.localDescription;
          if (!localDescription) {
            throw new Error("Missing local description");
          }
          const response = await fetch("/stream/webrtc", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ sdp: localDescription.sdp, type: localDescription.type }),
          });
          if (!response.ok) {
            throw new Error(`WebRTC negotiation failed with ${response.status}`);
          }
          const answer = await response.json();
          if (!answer || typeof answer.sdp !== "string" || typeof answer.type !== "string") {
            throw new Error("Invalid WebRTC response");
          }
          if (!shouldStream || activeStreamMode !== "webrtc") {
            return;
          }
          await pc.setRemoteDescription(answer);
        } catch (error) {
          try {
            pc.close();
          } catch (closeError) {
            console.warn("Peer connection close error", closeError);
          }
          if (peerConnection === pc) {
            peerConnection = null;
          }
          throw error;
        }
      }

      function scheduleReconnect(delay = 1000) {
        if (!shouldStream) {
          return;
        }
        clearReconnectTimer();
        reconnectTimer = setTimeout(() => {
          startStream({ message: "Reconnecting…", refreshCapabilities: true }).catch((error) =>
            console.error("Reconnect attempt failed", error),
          );
        }, delay);
      }

      async function startStream(messageOrOptions = "Connecting to camera…", maybeOptions) {
        let message = "Connecting to camera…";
        let options = {};
        if (
          messageOrOptions &&
          typeof messageOrOptions === "object" &&
          !Array.isArray(messageOrOptions)
        ) {
          options = messageOrOptions;
          if (typeof options.message === "string" && options.message.trim()) {
            message = options.message.trim();
          }
        } else {
          if (typeof messageOrOptions === "string" && messageOrOptions.trim()) {
            message = messageOrOptions.trim();
          }
          if (maybeOptions && typeof maybeOptions === "object") {
            options = maybeOptions;
          }
        }

        const refreshCapabilities = options.refreshCapabilities === true;

        shouldStream = true;
        clearReconnectTimer();
        activeStreamMode = null;
        setStreamModeLabel(null);
        toggleButton.textContent = "Pause stream";
        toggleButton.setAttribute("aria-pressed", "true");
        setStatus(message, "busy");
        teardownPeerConnection();
        if (streamImage instanceof HTMLImageElement) {
          streamImage.hidden = true;
          streamImage.removeAttribute("src");
        }
        if (streamVideo instanceof HTMLVideoElement) {
          streamVideo.hidden = true;
          streamVideo.srcObject = null;
        }

        if (refreshCapabilities || !streamCapabilities) {
          await refreshStreamCapabilities();
        }

        if (!isStreamingServiceAvailable()) {
          const issue =
            streamCapabilities &&
            typeof streamCapabilities.error === "string" &&
            streamCapabilities.error.trim()
              ? streamCapabilities.error.trim()
              : "Streaming unavailable";
          setStatus(issue, "error");
          toggleButton.textContent = "Start stream";
          toggleButton.setAttribute("aria-pressed", "false");
          shouldStream = false;
          return;
        }

        const canUseWebRTC = webrtcSupported && isServerWebRTCReady();

        if (canUseWebRTC) {
          try {
            await startWebRTCStream();
            return;
          } catch (error) {
            const summary = summariseWebRTCError(error);
            console.error("WebRTC stream error", error);
            setStatus(`WebRTC failed: ${summary}`, "error");
            reportWebRTCFailure(error);
          }
        } else if (webrtcSupported) {
          const capabilityError = getWebRTCErrorMessage();
          if (capabilityError) {
            setStatus(`Streaming issue: ${capabilityError}`, "error");
          }
        }

        if (!shouldStream) {
          return;
        }

        setStatus("Falling back to MJPEG…", "busy");
        try {
          startMjpegStream();
        } catch (error) {
          console.error("MJPEG stream error", error);
          setStatus("Streaming unavailable", "error");
          toggleButton.textContent = "Start stream";
          toggleButton.setAttribute("aria-pressed", "false");
        }
      }

      function stopStream(message = "Streaming paused") {
        shouldStream = false;
        activeStreamMode = null;
        setStreamModeLabel(null);
        clearReconnectTimer();
        teardownPeerConnection();
        if (streamImage instanceof HTMLImageElement) {
          streamImage.hidden = true;
          streamImage.src = "";
          streamImage.removeAttribute("src");
        }
        setStatus(message, "paused");
        toggleButton.textContent = "Start stream";
        toggleButton.setAttribute("aria-pressed", "false");
      }

      async function saveSnapshot() {
        if (!snapshotButton) {
          return;
        }
        const previousStatus = statusLabel ? statusLabel.textContent : "";
        const originalLabel = snapshotButton.textContent;
        snapshotButton.disabled = true;
        snapshotButton.textContent = "Saving…";
        setStatus("Capturing snapshot…", "busy");

        try {
          const response = await fetch("/api/camera/snapshot", { cache: "no-store" });
          if (!response.ok) {
            throw new Error(`Snapshot request failed with ${response.status}`);
          }
          const blob = await response.blob();
          const url = URL.createObjectURL(blob);
          const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
          const anchor = document.createElement("a");
          anchor.href = url;
          anchor.download = `revcam-${timestamp}.jpg`;
          anchor.style.display = "none";
          document.body.appendChild(anchor);
          anchor.click();
          document.body.removeChild(anchor);
          setTimeout(() => URL.revokeObjectURL(url), 1000);
          setStatus("Snapshot saved", "live");
          setTimeout(() => {
            if (statusLabel && statusLabel.textContent === "Snapshot saved") {
              const fallback = previousStatus || (shouldStream ? "Streaming" : "Streaming paused");
              setStatus(fallback);
            }
          }, 2000);
        } catch (error) {
          console.error("Snapshot error", error);
          setStatus("Snapshot failed", "error");
          setTimeout(() => {
            if (statusLabel && statusLabel.textContent === "Snapshot failed") {
              const fallback = previousStatus || (shouldStream ? "Streaming" : "Streaming paused");
              setStatus(fallback);
            }
          }, 2500);
        } finally {
          snapshotButton.disabled = false;
          snapshotButton.textContent = originalLabel;
        }
      }

      if (illuminationToggle instanceof HTMLButtonElement) {
        illuminationToggle.addEventListener("click", () => {
          if (!illuminationState || illuminationState.available === false) {
            setIlluminationStatus("LED driver unavailable", {
              persistent: true,
              tone: "error",
            });
            refreshIlluminationState({ showLoading: true });
            return;
          }
          const active = illuminationState.pattern === "illumination";
          if (!active && illuminationState.pattern && illuminationState.pattern !== "illumination") {
            illuminationPreviousPattern = illuminationState.pattern;
          }
          const targetPattern = active
            ? illuminationPreviousPattern && illuminationPreviousPattern !== "illumination"
              ? illuminationPreviousPattern
              : "ready"
            : "illumination";
          const successMessage = active ? "Illumination disabled" : "Illumination enabled";
          sendIlluminationUpdate({ pattern: targetPattern }, { successMessage }).catch((error) =>
            console.error("LED toggle error", error),
          );
        });
      }

      if (illuminationIntensityInput instanceof HTMLInputElement) {
        const updateDisplayFromInput = () => {
          if (!illuminationIntensityDisplay) {
            return;
          }
          const value = Number(illuminationIntensityInput.value);
          illuminationIntensityDisplay.textContent = `${Math.round(value)}%`;
        };
        illuminationIntensityInput.addEventListener("input", () => {
          illuminationIntensityInput.dataset.userEdited = "true";
          updateDisplayFromInput();
        });
        illuminationIntensityInput.addEventListener("change", () => {
          if (!illuminationState || illuminationState.available === false) {
            setIlluminationStatus("LED driver unavailable", {
              persistent: true,
              tone: "error",
            });
            refreshIlluminationState({ showLoading: true });
            return;
          }
          illuminationIntensityInput.dataset.userEdited = "true";
          updateDisplayFromInput();
          const value = Math.max(0, Math.min(100, Math.round(Number(illuminationIntensityInput.value))));
          sendIlluminationUpdate(
            { illumination_intensity: value },
            { successMessage: "Illumination updated" },
          ).catch((error) => console.error("LED intensity error", error));
        });
      }

      if (illuminationColourInput instanceof HTMLInputElement) {
        illuminationColourInput.addEventListener("input", () => {
          illuminationColourInput.dataset.userEdited = "true";
        });
        illuminationColourInput.addEventListener("change", () => {
          if (!illuminationState || illuminationState.available === false) {
            setIlluminationStatus("LED driver unavailable", {
              persistent: true,
              tone: "error",
            });
            refreshIlluminationState({ showLoading: true });
            return;
          }
          illuminationColourInput.dataset.userEdited = "true";
          const value = illuminationColourInput.value || "#FFFFFF";
          sendIlluminationUpdate(
            { illumination_color: value },
            { successMessage: "Illumination colour updated" },
          ).catch((error) => console.error("LED colour error", error));
        });
      }

      if (streamImage instanceof HTMLImageElement) {
        streamImage.addEventListener("load", () => {
          if (!shouldStream || activeStreamMode !== "mjpeg") {
            return;
          }
          setStatus("Streaming", "live");
        });

        streamImage.addEventListener("error", (event) => {
          if (!shouldStream || activeStreamMode !== "mjpeg") {
            return;
          }
          console.error("MJPEG stream error", event);
          setStatus("Connection lost – retrying…", "error");
          scheduleReconnect();
        });
      }

      if (streamVideo instanceof HTMLVideoElement) {
        streamVideo.addEventListener("playing", () => {
          if (!shouldStream || activeStreamMode !== "webrtc") {
            return;
          }
          setStatus("Streaming", "live");
        });

        streamVideo.addEventListener("error", (event) => {
          if (!shouldStream || activeStreamMode !== "webrtc") {
            return;
          }
          console.error("WebRTC video error", event);
          setStatus("Connection lost – retrying…", "error");
          scheduleReconnect();
        });
      }

      if (reconnectButton instanceof HTMLButtonElement) {
        reconnectButton.addEventListener("click", () => {
          const message = shouldStream ? "Reconnecting…" : "Connecting to camera…";
          startStream({ message, refreshCapabilities: true }).catch((error) =>
            console.error("Reconnect button error", error),
          );
        });
      }

      if (toggleButton instanceof HTMLButtonElement) {
        toggleButton.addEventListener("click", () => {
          if (shouldStream) {
            stopStream();
          } else {
            startStream({ refreshCapabilities: true }).catch((error) =>
              console.error("Stream toggle error", error),
            );
          }
        });
      }

      if (snapshotButton) {
        snapshotButton.addEventListener("click", () => {
          saveSnapshot().catch((error) => console.error("Snapshot handler error", error));
        });
      }

      window.addEventListener("beforeunload", () => {
        clearReconnectTimer();
        if (batteryTimer) {
          clearInterval(batteryTimer);
        }
        teardownPeerConnection();
      });

      document.addEventListener("visibilitychange", () => {
        if (document.visibilityState === "visible") {
          refreshBattery();
          refreshIlluminationState();
        }
      });

      if (modeToggle) {
        fetchMode();
        for (const button of modeButtons) {
          button.addEventListener("click", () => {
            changeMode(button.dataset.modeOption);
          });
        }
      }

      refreshIlluminationState({ showLoading: true });
      scheduleBatteryUpdates();
      startStream({ refreshCapabilities: true }).catch((error) =>
        console.error("Initial stream error", error),
      );
    </script>
  </body>
</html>
