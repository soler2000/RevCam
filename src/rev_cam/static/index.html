<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>RevCam Live View</title>
    <style>
      :root {
        color-scheme: dark;
        --font-family: "Inter", "Manrope", "Segoe UI", system-ui, -apple-system,
          BlinkMacSystemFont, sans-serif;
        --line-height: 1.65;
        --transition: 200ms ease;
        --surface-0: rgba(14, 16, 22, 0.8);
        --surface-1: rgba(26, 28, 36, 0.75);
        --surface-muted: rgba(255, 255, 255, 0.08);
        --surface-soft: rgba(255, 255, 255, 0.04);
        --border-subtle: rgba(255, 255, 255, 0.08);
        --border-muted: rgba(255, 255, 255, 0.12);
        --text-primary: #f5f7fb;
        --text-muted: rgba(245, 247, 250, 0.72);
        --text-on-accent: #ffffff;
        --accent: #0a84ff;
        --accent-hover: #2f95ff;
        --accent-active: #55adff;
        --accent-soft: rgba(10, 132, 255, 0.16);
        --accent-ring: rgba(10, 132, 255, 0.45);
        --accent-shadow: rgba(10, 132, 255, 0.35);
        --success: #4ade80;
        --success-soft: rgba(74, 222, 128, 0.16);
        --caution: #facc15;
        --caution-soft: rgba(250, 204, 21, 0.18);
        --warning: #ff9f0a;
        --warning-soft: rgba(255, 159, 10, 0.18);
        --danger: #ff453a;
        --danger-soft: rgba(255, 69, 58, 0.2);
        --info: #38bdf8;
        --info-soft: rgba(56, 189, 248, 0.18);
        --radius-sm: 0.5rem;
        --radius-md: 0.75rem;
        --radius-lg: 1rem;
        --radius-pill: 999px;
        --space-xs: 0.25rem;
        --space-sm: 0.5rem;
        --space-md: 0.75rem;
        --space-lg: 1.25rem;
        --space-xl: 1.75rem;
        --space-2xl: 2.5rem;
        --control-padding-y: 0.6rem;
        --control-padding-x: 1.25rem;
        --card-padding: 1.5rem;
        --shadow-sm: 0 12px 26px rgba(0, 0, 0, 0.35);
        --shadow-md: 0 18px 40px rgba(0, 0, 0, 0.45);
        --shadow-lg: 0 40px 90px rgba(0, 0, 0, 0.6);
        --shadow-top-md: 0 -18px 40px rgba(0, 0, 0, 0.45);
        --glow-success: 0 24px 48px rgba(48, 209, 88, 0.3);
        --glow-danger: 0 20px 44px rgba(255, 69, 58, 0.32);
        --page-gradient: radial-gradient(120% 140% at top, #1b1e26 0%, #10131a 60%, #050609 100%);
      }
      body {
        margin: 0;
        font-family: var(--font-family);
        line-height: var(--line-height);
        background: var(--page-gradient);
        color: var(--text-primary);
        display: flex;
        flex-direction: column;
        min-height: 100vh;
      }
      header,
      footer {
        padding: calc(var(--space-sm) + 0.35rem) var(--space-xl);
        background: var(--surface-0);
        backdrop-filter: blur(18px) saturate(125%);
        -webkit-backdrop-filter: blur(18px) saturate(125%);
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: var(--space-md);
        box-shadow: var(--shadow-md);
      }
      header {
        border-bottom: 1px solid var(--border-subtle);
      }
      footer {
        border-top: 1px solid var(--border-subtle);
        box-shadow: var(--shadow-top-md);
      }
      strong.brand {
        font-size: 1.25rem;
        letter-spacing: 0.04em;
      }
      .pill {
        display: inline-flex;
        align-items: center;
        gap: var(--space-md);
        padding: var(--space-sm) var(--space-lg);
        border-radius: var(--radius-pill);
        background: var(--surface-1);
        border: 1px solid var(--border-muted);
        box-shadow: var(--shadow-sm);
        backdrop-filter: blur(22px);
        -webkit-backdrop-filter: blur(22px);
        min-width: 0;
      }
      main {
        flex: 1 1 auto;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: clamp(var(--space-lg), 4vw, var(--space-2xl));
      }
      .stream-wrapper {
        width: min(100%, max(320px, calc(100vh - 6rem)));
        max-width: min(1100px, max(360px, calc(100vh - 3rem)));
      }
      .stream-display {
        display: block;
        width: 100%;
        background: linear-gradient(160deg, var(--surface-0), var(--surface-1));
        border-radius: var(--radius-lg);
        border: 1px solid var(--border-subtle);
        box-shadow: var(--shadow-lg);
        transition: box-shadow var(--transition);
      }
      .stream-display[hidden] {
        display: none;
      }
      video.stream-display {
        background-color: black;
        object-fit: contain;
      }
      button {
        background: linear-gradient(135deg, var(--accent), var(--accent-hover));
        color: var(--text-on-accent);
        border: none;
        padding: var(--control-padding-y) var(--control-padding-x);
        border-radius: var(--radius-pill);
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: background var(--transition), box-shadow var(--transition),
          transform var(--transition);
      }
      button:not(:disabled):hover {
        background: linear-gradient(135deg, var(--accent-hover), var(--accent-active));
        box-shadow: 0 12px 26px var(--accent-shadow);
        transform: translateY(-1px);
      }
      button:not(:disabled):focus-visible {
        background: linear-gradient(135deg, var(--accent-hover), var(--accent-active));
        box-shadow: 0 12px 26px var(--accent-shadow),
          0 0 0 1px var(--accent-active), 0 0 0 4px var(--accent-soft);
        transform: translateY(-1px);
      }
      button:focus-visible {
        outline: none;
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        box-shadow: none;
        transform: none;
      }
      .control-group {
        display: flex;
        gap: var(--space-sm);
        flex-wrap: wrap;
      }
      .control-group button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: var(--space-xs);
        background: var(--surface-1);
        border: 1px solid var(--border-muted);
        color: var(--text-primary);
        padding: calc(var(--control-padding-y) - 0.1rem)
          calc(var(--control-padding-x) + 0.25rem);
        border-radius: var(--radius-pill);
        font-weight: 600;
        box-shadow: var(--shadow-sm);
        backdrop-filter: blur(18px);
        -webkit-backdrop-filter: blur(18px);
        transition: transform var(--transition), box-shadow var(--transition),
          border-color var(--transition), background var(--transition),
          color var(--transition);
      }
      .control-group button:not(:disabled):hover {
        background: var(--surface-0);
        border-color: var(--accent-active);
        box-shadow: 0 16px 36px rgba(0, 0, 0, 0.45);
        transform: translateY(-1px);
        color: var(--accent-active);
      }
      .control-group button:not(:disabled):focus-visible {
        background: var(--surface-0);
        border-color: var(--accent-active);
        color: var(--accent-active);
        box-shadow: 0 16px 36px rgba(0, 0, 0, 0.45),
          0 0 0 1px var(--accent-active), 0 0 0 4px var(--accent-soft);
        transform: translateY(-1px);
      }
      .control-group button:disabled {
        opacity: 0.6;
        box-shadow: none;
        transform: none;
      }
      a.settings-link {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: var(--space-xs);
        padding: calc(var(--control-padding-y) - 0.1rem)
          calc(var(--control-padding-x) + 0.25rem);
        border-radius: var(--radius-pill);
        background: var(--surface-1);
        border: 1px solid var(--border-muted);
        color: var(--text-primary);
        font-weight: 600;
        text-decoration: none;
        box-shadow: var(--shadow-sm);
        backdrop-filter: blur(18px);
        -webkit-backdrop-filter: blur(18px);
        cursor: pointer;
        transition: transform var(--transition), box-shadow var(--transition),
          border-color var(--transition), background var(--transition),
          color var(--transition);
        white-space: nowrap;
      }
      a.settings-link:hover,
      a.settings-link:focus-visible {
        background: var(--surface-0);
        border-color: var(--accent-active);
        box-shadow: 0 16px 36px rgba(0, 0, 0, 0.45);
        transform: translateY(-1px);
        color: var(--accent-active);
      }
      a.settings-link:focus-visible {
        outline: none;
        box-shadow: 0 16px 36px rgba(0, 0, 0, 0.45),
          0 0 0 1px var(--accent-active), 0 0 0 4px var(--accent-soft);
      }
      .status-pill {
        color: var(--text-muted);
        gap: var(--space-md);
        font-weight: 600;
        transition: color var(--transition), box-shadow var(--transition);
      }
      .illumination-pill {
        display: inline-flex;
        flex-wrap: wrap;
        align-items: center;
        gap: var(--space-md);
        padding: var(--space-sm) var(--space-lg);
        border-radius: var(--radius-pill);
        background: var(--surface-1);
        border: 1px solid var(--border-muted);
        box-shadow: var(--shadow-sm);
        backdrop-filter: blur(22px);
        -webkit-backdrop-filter: blur(22px);
      }
      .illumination-pill.unavailable {
        opacity: 0.6;
      }
      .illumination-pill button {
        flex: 0 0 auto;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 2.75rem;
        height: 2.75rem;
        padding: 0;
        border-radius: 50%;
      }
      .illumination-toggle-icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 1.4rem;
        line-height: 1;
      }
      .illumination-slider,
      .illumination-colour {
        display: flex;
        align-items: center;
        gap: var(--space-xs);
        font-size: 0.9rem;
        color: var(--text-muted);
      }
      .illumination-slider input[type="range"] {
        appearance: none;
        width: 8rem;
        height: 0.4rem;
        border-radius: var(--radius-pill);
        background: var(--surface-soft);
        box-shadow: inset 0 0 0 1px var(--border-subtle);
        cursor: pointer;
      }
      .illumination-slider input[type="range"]::-webkit-slider-thumb {
        appearance: none;
        width: 1rem;
        height: 1rem;
        border-radius: 50%;
        background: var(--accent);
        box-shadow: 0 0 0 2px rgba(10, 132, 255, 0.45);
        cursor: pointer;
        border: none;
      }
      .illumination-slider input[type="range"]::-moz-range-thumb {
        width: 1rem;
        height: 1rem;
        border-radius: 50%;
        background: var(--accent);
        border: none;
        box-shadow: 0 0 0 2px rgba(10, 132, 255, 0.45);
        cursor: pointer;
      }
      .illumination-slider-value {
        min-width: 2.5rem;
        text-align: right;
        font-variant-numeric: tabular-nums;
      }
      .illumination-colour input[type="color"] {
        width: 2.25rem;
        height: 2.25rem;
        border-radius: var(--radius-pill);
        border: 1px solid var(--border-muted);
        padding: 0;
        background: none;
        cursor: pointer;
      }
      .illumination-status-box {
        display: none;
        margin: var(--space-xl) auto var(--space-lg);
        width: min(720px, calc(100% - (2 * var(--space-xl))));
        padding: var(--space-md) var(--space-lg);
        border-radius: var(--radius-lg);
        background: var(--surface-1);
        border: 1px solid var(--border-muted);
        box-shadow: var(--shadow-sm);
        color: var(--text-muted);
        text-align: center;
        line-height: 1.45;
      }
      .illumination-status-box.is-visible {
        display: block;
      }
      .illumination-status-box.is-success {
        color: var(--success);
      }
      .illumination-status-box.is-error {
        color: var(--danger);
      }
      .status-icon {
        width: 1.6rem;
        height: 1.6rem;
        flex: 0 0 auto;
      }
      .status-icon .icon {
        opacity: 0;
        transition: opacity var(--transition);
      }
      .status-pill.is-busy .icon-busy circle:first-of-type {
        animation: status-busy-track 1.4s linear infinite;
        transform-origin: center;
      }
      .status-pill.is-busy .icon-busy circle:last-of-type {
        animation: status-busy-pulse 1.4s ease-in-out infinite;
        transform-origin: center;
      }
      .status-pill.is-live .icon-live,
      .status-pill.is-paused .icon-paused,
      .status-pill.is-error .icon-error,
      .status-pill.is-busy .icon-busy {
        opacity: 1;
      }
      .status-pill.is-live {
        color: var(--success);
      }
      .status-pill.is-paused {
        color: var(--caution);
      }
      .status-pill.is-error {
        color: var(--danger);
      }
      .status-pill.is-busy {
        color: var(--info);
      }
      .status-pill.is-charging {
        box-shadow: var(--glow-success);
      }
      .status-copy {
        display: flex;
        flex-direction: column;
        line-height: 1.1;
        gap: 0.15rem;
        min-width: 0;
      }
      #status {
        font-size: 0.95rem;
        font-weight: 600;
        white-space: nowrap;
        transition: color var(--transition), opacity var(--transition);
      }
      #status-subtext {
        display: inline-flex;
        align-items: center;
        gap: var(--space-xs);
        font-size: 0.75rem;
        font-weight: 500;
        letter-spacing: 0.02em;
        color: var(--text-muted);
        white-space: nowrap;
        transition: color var(--transition), opacity var(--transition);
      }
      #status-subtext:empty {
        display: none;
      }
      #status,
      #status-subtext:not(:empty) {
        animation: status-reveal var(--transition) ease;
      }
      #status-subtext::before {
        content: "⚡";
        font-size: 0.8rem;
      }
      #battery-indicator {
        align-items: center;
      }
      .battery-pill {
        font-weight: 600;
        color: var(--text-primary);
      }
      .battery-pill.low {
        color: var(--danger);
        box-shadow: var(--glow-danger);
      }
      .battery-pill.charging {
        color: var(--success);
        box-shadow: var(--glow-success);
      }
      .battery-pill.unavailable {
        color: var(--text-muted);
        box-shadow: none;
      }
      .battery-icon {
        width: 2.6rem;
        height: 1.5rem;
        flex: 0 0 auto;
      }
      .battery-outline {
        fill: none;
        stroke: currentColor;
        stroke-width: 2;
        opacity: 0.85;
      }
      .battery-terminal {
        fill: currentColor;
        opacity: 0.85;
      }
      .battery-fill {
        fill: currentColor;
        opacity: 0.9;
        transition: width 0.35s ease;
      }
      .battery-bolt {
        fill: currentColor;
        opacity: 0;
        transition: opacity var(--transition);
      }
      .battery-pill.charging .battery-bolt {
        opacity: 1;
      }
      .battery-copy {
        display: flex;
        flex-direction: column;
        line-height: 1.1;
        gap: 0.15rem;
        align-items: flex-start;
        min-width: 0;
      }
      #battery-text {
        font-size: 0.95rem;
      }
      #battery-details {
        font-size: 0.72rem;
        color: var(--text-muted);
        white-space: nowrap;
      }
      @keyframes status-busy-track {
        0% {
          stroke-dashoffset: 8;
          transform: rotate(0deg);
        }
        100% {
          stroke-dashoffset: -24;
          transform: rotate(360deg);
        }
      }
      @keyframes status-busy-pulse {
        0%,
        100% {
          opacity: 0.4;
          transform: scale(0.9);
        }
        50% {
          opacity: 1;
          transform: scale(1);
        }
      }
      @keyframes status-reveal {
        from {
          opacity: 0;
          transform: translateY(0.3rem);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      @media (max-width: 960px) {
        .stream-display {
          border-radius: calc(var(--radius-lg) - 0.25rem);
          box-shadow: 0 28px 70px rgba(0, 0, 0, 0.55);
        }
      }
      @media (max-width: 640px) {
        header,
        footer {
          align-items: stretch;
        }
        .status-pill,
        .battery-pill {
          width: 100%;
        }
        #status,
        #status-subtext,
        #battery-details {
          white-space: normal;
        }
        .control-group {
          width: 100%;
          justify-content: center;
        }
        footer {
          justify-content: center;
          text-align: center;
        }
        .illumination-status-box {
          width: calc(100% - (2 * var(--space-lg)));
          margin: var(--space-lg) auto var(--space-lg);
        }
      }
    </style>
  </head>
  <body>
    <header>
      <strong class="brand">RevCam</strong>
      <div class="pill status-pill is-busy" id="status-pill" role="status" aria-live="polite">
        <svg class="status-icon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
          <g class="icon icon-live">
            <path
              d="M4 10a8 8 0 0 1 16 0"
              fill="none"
              stroke="currentColor"
              stroke-width="1.8"
              stroke-linecap="round"
            ></path>
            <path
              d="M7.5 13a4.5 4.5 0 0 1 9 0"
              fill="none"
              stroke="currentColor"
              stroke-width="1.8"
              stroke-linecap="round"
            ></path>
            <circle cx="12" cy="16" r="2.2" fill="currentColor"></circle>
          </g>
          <g class="icon icon-paused">
            <rect x="7" y="6.5" width="3.5" height="11" rx="1" fill="currentColor"></rect>
            <rect x="13.5" y="6.5" width="3.5" height="11" rx="1" fill="currentColor"></rect>
          </g>
          <g class="icon icon-busy">
            <circle
              cx="12"
              cy="12"
              r="7"
              fill="none"
              stroke="currentColor"
              stroke-width="1.8"
              stroke-linecap="round"
              stroke-dasharray="32"
              stroke-dashoffset="8"
            ></circle>
            <circle cx="12" cy="4.5" r="1.6" fill="currentColor"></circle>
          </g>
          <g class="icon icon-error">
            <path d="M12 5l7 12H5z" fill="currentColor"></path>
          </g>
        </svg>
        <div class="status-copy">
          <span id="status">Initialising…</span>
          <span id="status-subtext"></span>
        </div>
      </div>
      <div
        id="battery-indicator"
        class="pill battery-pill unavailable"
        aria-live="polite"
        aria-label="Battery unavailable"
      >
        <svg
          class="battery-icon"
          id="battery-icon"
          viewBox="0 0 52 28"
          aria-hidden="true"
          focusable="false"
        >
          <rect class="battery-outline" x="2" y="6" width="36" height="16" rx="4" ry="4"></rect>
          <rect class="battery-fill" id="battery-level" x="4" y="8" width="0" height="12" rx="3" ry="3"></rect>
          <rect class="battery-terminal" x="38" y="11" width="8" height="6" rx="1.5" ry="1.5"></rect>
          <path class="battery-bolt" d="M27 9l-4 6h3l-1 6 4-7h-3l1-5z"></path>
        </svg>
        <div class="battery-copy">
          <span id="battery-text">—%</span>
          <span id="battery-details">Battery unavailable</span>
        </div>
      </div>
      <div class="illumination-pill" id="illumination-controls" aria-live="polite">
        <button
          id="toggle-illumination"
          type="button"
          aria-pressed="false"
          aria-label="Enable illumination"
          title="Enable illumination"
        >
          <span class="illumination-toggle-icon" aria-hidden="true">💡</span>
        </button>
        <label class="illumination-slider" for="illumination-intensity">
          <span>Intensity</span>
          <input
            id="illumination-intensity"
            type="range"
            min="0"
            max="100"
            step="1"
            value="100"
          />
          <span class="illumination-slider-value" id="illumination-intensity-display">100%</span>
        </label>
        <label class="illumination-colour" for="illumination-colour">
          <span>Colour</span>
          <input id="illumination-colour" type="color" value="#FFFFFF" />
        </label>
      </div>
    </header>
    <main>
      <div class="stream-wrapper">
        <video
          id="stream-video"
          class="stream-display"
          autoplay
          playsinline
          muted
          hidden
        ></video>
        <img id="stream-fallback" class="stream-display" alt="Camera feed" hidden />
      </div>
    </main>
    <div
      class="illumination-status-box"
      id="illumination-status"
      role="status"
      aria-live="polite"
      aria-hidden="true"
    ></div>
    <footer>
      <div class="control-group">
        <button id="toggle-stream" type="button" aria-pressed="false">Pause stream</button>
        <button id="reconnect" type="button">Reconnect</button>
        <button id="save-snapshot" type="button">Save snapshot</button>
      </div>
      <a class="settings-link" href="/settings">Settings</a>
    </footer>
    <script>
      const statusLabel = document.getElementById("status");
      const reconnectButton = document.getElementById("reconnect");
      const streamVideo = document.getElementById("stream-video");
      const streamImage = document.getElementById("stream-fallback");
      const toggleButton = document.getElementById("toggle-stream");
      const snapshotButton = document.getElementById("save-snapshot");
      const batteryIndicator = document.getElementById("battery-indicator");
      const batteryIcon = document.getElementById("battery-icon");
      const batteryLevel = document.getElementById("battery-level");
      const batteryText = document.getElementById("battery-text");
      const batteryDetails = document.getElementById("battery-details");
      const statusPill = document.getElementById("status-pill");
      const statusSubtext = document.getElementById("status-subtext");
      const illuminationControls = document.getElementById("illumination-controls");
      const illuminationToggle = document.getElementById("toggle-illumination");
      const illuminationIntensityInput = document.getElementById("illumination-intensity");
      const illuminationIntensityDisplay = document.getElementById("illumination-intensity-display");
      const illuminationColourInput = document.getElementById("illumination-colour");
      const illuminationStatusBox = document.getElementById("illumination-status");
      const BATTERY_LEVEL_MAX = 32;
      const STATUS_CLASSES = ["is-live", "is-paused", "is-error", "is-busy"];
      function applyStatusState(reference) {
        if (!statusPill) {
          return;
        }
        const descriptor = typeof reference === "string" ? reference.toLowerCase() : "";
        statusPill.classList.remove(...STATUS_CLASSES);
        let targetClass = "is-busy";
        if (descriptor.includes("error") || descriptor.includes("fail") || descriptor.includes("lost")) {
          targetClass = "is-error";
        } else if (descriptor.includes("pause") || descriptor.includes("stop")) {
          targetClass = "is-paused";
        } else if (descriptor.includes("stream") || descriptor.includes("live") || descriptor.includes("play")) {
          targetClass = "is-live";
        }
        statusPill.classList.add(targetClass);
      }

      function setStatus(message, stateHint) {
        if (statusLabel) {
          statusLabel.textContent = message;
        }
        applyStatusState(stateHint || message);
      }

      function setChargingState(isCharging) {
        const charging = Boolean(isCharging);
        if (statusPill) {
          statusPill.classList.toggle("is-charging", charging);
        }
        if (statusSubtext) {
          statusSubtext.textContent = charging ? "Charging" : "";
        }
      }

      let reconnectTimer = null;
      let batteryTimer = null;
      let shouldStream = false;
      let peerConnection = null;
      let activeStreamMode = null;
      const webrtcSupported = typeof window.RTCPeerConnection === "function";

      async function waitForIceGatheringComplete(peerConnection, timeout = 4000) {
        if (!peerConnection) {
          throw new Error("Missing peer connection");
        }
        if (peerConnection.iceGatheringState === "complete") {
          return;
        }

        await new Promise((resolve) => {
          let finished = false;
          const timer = window.setTimeout(() => {
            finished = true;
            peerConnection.removeEventListener(
              "icegatheringstatechange",
              handleStateChange,
            );
            resolve();
          }, timeout);

          function cleanup() {
            if (finished) {
              return;
            }
            finished = true;
            window.clearTimeout(timer);
            peerConnection.removeEventListener(
              "icegatheringstatechange",
              handleStateChange,
            );
            resolve();
          }

          function handleStateChange() {
            if (peerConnection.iceGatheringState === "complete") {
              cleanup();
            }
          }

          peerConnection.addEventListener(
            "icegatheringstatechange",
            handleStateChange,
          );
          handleStateChange();
        });
      }
      let illuminationState = null;
      let illuminationPreviousPattern = null;
      let illuminationBusy = false;
      let illuminationLoading = false;
      let illuminationStatusTimer = null;
      setStatus(statusLabel ? statusLabel.textContent : "Initialising…", "busy");

      function updateBatteryUI(data) {
        if (
          !batteryIndicator ||
          !batteryIcon ||
          !batteryLevel ||
          !batteryText ||
          !batteryDetails
        ) {
          return;
        }
        batteryIndicator.classList.remove("low", "charging", "unavailable");
        batteryIcon.classList.remove("low", "charging", "unavailable");

        if (!data || data.available !== true || typeof data.percentage !== "number") {
          batteryIndicator.classList.add("unavailable");
          batteryIcon.classList.add("unavailable");
          batteryLevel.setAttribute("width", "0");
          batteryText.textContent = "—%";
          const fallback =
            data && typeof data.error === "string" && data.error.trim()
              ? data.error.trim()
              : "Battery unavailable";
          batteryDetails.textContent = fallback;
          batteryIndicator.setAttribute("aria-label", fallback);
          setChargingState(false);
          return;
        }

        const rawPercentage = Number(data.percentage);
        if (!Number.isFinite(rawPercentage)) {
          batteryIndicator.classList.add("unavailable");
          batteryIcon.classList.add("unavailable");
          batteryLevel.setAttribute("width", "0");
          batteryText.textContent = "—%";
          batteryDetails.textContent = "Battery unavailable";
          batteryIndicator.setAttribute("aria-label", "Battery unavailable");
          setChargingState(false);
          return;
        }

        const percentage = Math.max(0, Math.min(100, rawPercentage));
        const fillWidth = Math.round((percentage / 100) * BATTERY_LEVEL_MAX);
        const clampedWidth = Math.max(0, Math.min(BATTERY_LEVEL_MAX, fillWidth));
        const visibleWidth = clampedWidth > 0 ? Math.max(3, clampedWidth) : 0;
        batteryLevel.setAttribute("width", String(visibleWidth));
        const rounded = Math.round(percentage);
        batteryText.textContent = `${rounded}%`;

        if (data.charging === true) {
          batteryIndicator.classList.add("charging");
          batteryIcon.classList.add("charging");
        } else if (percentage <= 20) {
          batteryIndicator.classList.add("low");
          batteryIcon.classList.add("low");
        }

        const detailParts = [];
        if (typeof data.voltage === "number" && Number.isFinite(data.voltage)) {
          detailParts.push(`${data.voltage.toFixed(2)} V`);
        }
        if (typeof data.current_ma === "number" && Number.isFinite(data.current_ma)) {
          const magnitude = Math.abs(data.current_ma);
          const decimals = magnitude >= 100 ? 0 : magnitude >= 10 ? 1 : 2;
          const formatted = magnitude.toFixed(decimals);
          const suffix = data.charging === true ? "charging" : "draw";
          detailParts.push(`${formatted} mA ${suffix}`);
        } else if (data.charging === true) {
          detailParts.push("Charging");
        }
        const detailText = detailParts.join(" · ") || "Battery OK";
        batteryDetails.textContent = detailText;
        batteryIndicator.setAttribute(
          "aria-label",
          `Battery ${rounded}%, ${detailParts.join(", ") || "status"}`,
        );
        setChargingState(data.charging === true);
      }

      async function refreshBattery() {
        if (!batteryIcon || !batteryLevel) {
          return;
        }
        try {
          const response = await fetch("/api/battery", { cache: "no-store" });
          if (!response.ok) {
            throw new Error(`Battery request failed with ${response.status}`);
          }
          const payload = await response.json();
          updateBatteryUI(payload);
        } catch (error) {
          console.error("Battery status error", error);
          updateBatteryUI({ available: false, error: "Battery offline" });
        }
      }

      function scheduleBatteryUpdates(interval = 15000) {
        if (!batteryIcon || !batteryLevel || !batteryText || !batteryDetails) {
          return;
        }
        if (batteryTimer) {
          clearInterval(batteryTimer);
        }
        refreshBattery();
        batteryTimer = setInterval(refreshBattery, interval);
      }

      function setIlluminationStatus(message, options = {}) {
        if (!illuminationStatusBox) {
          return;
        }
        if (illuminationStatusTimer) {
          window.clearTimeout(illuminationStatusTimer);
          illuminationStatusTimer = null;
        }
        const text =
          typeof message === "string" && message.trim() ? message.trim() : "";
        illuminationStatusBox.classList.remove(
          "is-visible",
          "is-success",
          "is-error",
        );
        illuminationStatusBox.textContent = text;
        if (text) {
          let tone = options.tone;
          if (!tone) {
            const descriptor = text.toLowerCase();
            if (
              descriptor.includes("error") ||
              descriptor.includes("fail") ||
              descriptor.includes("unavailable") ||
              descriptor.includes("denied") ||
              descriptor.includes("requires")
            ) {
              tone = "error";
            } else if (
              descriptor.includes("enabled") ||
              descriptor.includes("disabled") ||
              descriptor.includes("updated") ||
              descriptor.includes("saved")
            ) {
              tone = "success";
            }
          }
          if (tone === "success") {
            illuminationStatusBox.classList.add("is-success");
          } else if (tone === "error") {
            illuminationStatusBox.classList.add("is-error");
          }
          illuminationStatusBox.classList.add("is-visible");
          illuminationStatusBox.setAttribute("aria-hidden", "false");
        } else {
          illuminationStatusBox.setAttribute("aria-hidden", "true");
        }
        if (text && options.persistent !== true) {
          illuminationStatusTimer = window.setTimeout(() => {
            if (
              illuminationStatusBox &&
              illuminationStatusBox.textContent === text
            ) {
              illuminationStatusBox.textContent = "";
              illuminationStatusBox.classList.remove(
                "is-visible",
                "is-success",
                "is-error",
              );
              illuminationStatusBox.setAttribute("aria-hidden", "true");
            }
            illuminationStatusTimer = null;
          }, 4000);
        }
      }

      function applyIlluminationState(state) {
        if (state && typeof state === "object") {
          const illuminationDetails =
            state.illumination && typeof state.illumination === "object"
              ? state.illumination
              : {};
          const rawIntensity = Number.isFinite(illuminationDetails.intensity)
            ? Number(illuminationDetails.intensity)
            : 100;
          const clampedIntensity = Math.max(0, Math.min(100, rawIntensity));
          const colourValue =
            typeof illuminationDetails.color === "string" && illuminationDetails.color.trim()
              ? illuminationDetails.color.trim()
              : "#FFFFFF";
          illuminationState = {
            pattern: typeof state.pattern === "string" ? state.pattern : "",
            active_pattern:
              typeof state.active_pattern === "string" ? state.active_pattern : "",
            error: state.error === true,
            available: state.available !== false,
            message:
              typeof state.message === "string" && state.message.trim()
                ? state.message.trim()
                : "",
            illumination: {
              intensity: clampedIntensity,
              color: colourValue,
            },
          };
        } else {
          illuminationState = null;
        }

        const available = illuminationState ? illuminationState.available : false;
        const active = illuminationState ? illuminationState.pattern === "illumination" : false;
        const message = illuminationState && illuminationState.message ? illuminationState.message : "";
        const intensity =
          illuminationState && illuminationState.illumination
            ? illuminationState.illumination.intensity
            : 100;
        const colour =
          illuminationState && illuminationState.illumination
            ? illuminationState.illumination.color
            : "#FFFFFF";

        if (illuminationControls) {
          illuminationControls.classList.toggle("unavailable", !available);
        }

        if (illuminationToggle instanceof HTMLButtonElement) {
          const toggleLabel = active ? "Disable illumination" : "Enable illumination";
          illuminationToggle.disabled = !available;
          illuminationToggle.setAttribute("aria-label", toggleLabel);
          illuminationToggle.title = toggleLabel;
          illuminationToggle.setAttribute("aria-pressed", active ? "true" : "false");
        }

        if (illuminationIntensityInput instanceof HTMLInputElement) {
          if (illuminationIntensityInput.dataset.userEdited !== "true" || !illuminationBusy) {
            illuminationIntensityInput.value = String(Math.round(intensity));
            delete illuminationIntensityInput.dataset.userEdited;
          }
          illuminationIntensityInput.disabled = !available;
          const displayValue =
            illuminationIntensityInput.dataset.userEdited === "true"
              ? Number(illuminationIntensityInput.value)
              : intensity;
          if (illuminationIntensityDisplay) {
            illuminationIntensityDisplay.textContent = `${Math.round(displayValue)}%`;
          }
        } else if (illuminationIntensityDisplay) {
          illuminationIntensityDisplay.textContent = `${Math.round(intensity)}%`;
        }

        if (illuminationColourInput instanceof HTMLInputElement) {
          if (illuminationColourInput.dataset.userEdited !== "true" || !illuminationBusy) {
            illuminationColourInput.value = colour;
            delete illuminationColourInput.dataset.userEdited;
          }
          illuminationColourInput.disabled = !available;
        }

        if (!available) {
          setIlluminationStatus(message || "LED driver unavailable", {
            persistent: true,
            tone: "error",
          });
        } else if (message) {
          setIlluminationStatus(message, { persistent: true });
        } else {
          setIlluminationStatus("");
        }

        if (
          illuminationState &&
          illuminationState.pattern &&
          illuminationState.pattern !== "illumination"
        ) {
          illuminationPreviousPattern = illuminationState.pattern;
        }
      }

      async function refreshIlluminationState({ showLoading = false } = {}) {
        if (illuminationLoading) {
          return illuminationState;
        }
        illuminationLoading = true;
        if (showLoading) {
          setIlluminationStatus("Loading illumination status…");
        }
        try {
          const response = await fetch("/api/led", { cache: "no-store" });
          if (!response.ok) {
            let detail = `LED status request failed with ${response.status}`;
            try {
              const problem = await response.json();
              if (problem && typeof problem.detail === "string" && problem.detail.trim()) {
                detail = problem.detail.trim();
              }
            } catch (err) {
              console.error(err);
            }
            throw new Error(detail);
          }
          const payload = await response.json();
          applyIlluminationState(payload);
          return payload;
        } catch (error) {
          console.error("LED status error", error);
          applyIlluminationState(null);
          const message =
            error instanceof Error && error.message
              ? error.message
              : "Unable to load illumination status.";
          setIlluminationStatus(message, { persistent: true, tone: "error" });
          return null;
        } finally {
          illuminationLoading = false;
        }
      }

      async function sendIlluminationUpdate(payload, options = {}) {
        if (!payload || typeof payload !== "object") {
          return null;
        }
        illuminationBusy = true;
        try {
          const response = await fetch("/api/led", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          if (!response.ok) {
            let detail = `LED update failed with ${response.status}`;
            try {
              const problem = await response.json();
              if (problem && typeof problem.detail === "string" && problem.detail.trim()) {
                detail = problem.detail.trim();
              }
            } catch (err) {
              console.error(err);
            }
            throw new Error(detail);
          }
          const result = await response.json();
          applyIlluminationState(result);
          if (options.successMessage) {
            setIlluminationStatus(options.successMessage, { tone: "success" });
          } else {
            setIlluminationStatus("");
          }
          return result;
        } catch (error) {
          console.error("LED update error", error);
          const message =
            error instanceof Error && error.message
              ? error.message
              : "Failed to update illumination.";
          setIlluminationStatus(message, { persistent: true, tone: "error" });
          return null;
        } finally {
          illuminationBusy = false;
          if (illuminationIntensityInput instanceof HTMLInputElement) {
            delete illuminationIntensityInput.dataset.userEdited;
          }
          if (illuminationColourInput instanceof HTMLInputElement) {
            delete illuminationColourInput.dataset.userEdited;
          }
        }
      }

      function clearReconnectTimer() {
        if (reconnectTimer) {
          clearTimeout(reconnectTimer);
          reconnectTimer = null;
        }
      }

      function teardownPeerConnection() {
        if (peerConnection) {
          try {
            peerConnection.close();
          } catch (error) {
            console.warn("Peer connection close error", error);
          }
          peerConnection = null;
        }
        if (streamVideo instanceof HTMLVideoElement) {
          try {
            streamVideo.pause();
          } catch (error) {
            console.warn("Video pause error", error);
          }
          streamVideo.srcObject = null;
          streamVideo.hidden = true;
        }
      }

      function startMjpegStream() {
        if (!(streamImage instanceof HTMLImageElement)) {
          throw new Error("MJPEG stream element unavailable");
        }
        activeStreamMode = "mjpeg";
        teardownPeerConnection();
        const cacheBuster = Date.now();
        streamImage.hidden = false;
        streamImage.src = `/stream/mjpeg?cb=${cacheBuster}`;
        if (streamVideo instanceof HTMLVideoElement) {
          streamVideo.hidden = true;
          streamVideo.srcObject = null;
        }
      }

      async function startWebRTCStream() {
        if (!webrtcSupported || !(streamVideo instanceof HTMLVideoElement)) {
          throw new Error("WebRTC streaming unsupported in this browser");
        }
        activeStreamMode = "webrtc";
        if (streamImage instanceof HTMLImageElement) {
          streamImage.hidden = true;
          streamImage.removeAttribute("src");
        }
        teardownPeerConnection();

        const pc = new RTCPeerConnection();
        peerConnection = pc;
        pc.addTransceiver("video", { direction: "recvonly" });

        pc.addEventListener("connectionstatechange", () => {
          if (!shouldStream || activeStreamMode !== "webrtc") {
            return;
          }
          const state = pc.connectionState;
          if (state === "connected") {
            setStatus("Streaming", "live");
          } else if (state === "failed" || state === "disconnected") {
            setStatus("Connection lost – retrying…", "error");
            scheduleReconnect();
          }
        });

        pc.addEventListener("track", (event) => {
          if (!shouldStream || activeStreamMode !== "webrtc") {
            return;
          }
          const [remoteStream] = event.streams;
          if (remoteStream && streamVideo.srcObject !== remoteStream) {
            streamVideo.srcObject = remoteStream;
            streamVideo.hidden = false;
            streamVideo
              .play()
              .catch((error) => console.warn("Video playback failed", error));
          }
        });

        try {
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          await waitForIceGatheringComplete(pc);
          const localDescription = pc.localDescription;
          if (!localDescription) {
            throw new Error("Missing local description");
          }
          const response = await fetch("/stream/webrtc", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ sdp: localDescription.sdp, type: localDescription.type }),
          });
          if (!response.ok) {
            throw new Error(`WebRTC negotiation failed with ${response.status}`);
          }
          const answer = await response.json();
          if (!answer || typeof answer.sdp !== "string" || typeof answer.type !== "string") {
            throw new Error("Invalid WebRTC response");
          }
          if (!shouldStream || activeStreamMode !== "webrtc") {
            return;
          }
          await pc.setRemoteDescription(answer);
        } catch (error) {
          try {
            pc.close();
          } catch (closeError) {
            console.warn("Peer connection close error", closeError);
          }
          if (peerConnection === pc) {
            peerConnection = null;
          }
          throw error;
        }
      }

      function scheduleReconnect(delay = 1000) {
        if (!shouldStream) {
          return;
        }
        clearReconnectTimer();
        reconnectTimer = setTimeout(() => {
          startStream("Reconnecting…").catch((error) =>
            console.error("Reconnect attempt failed", error),
          );
        }, delay);
      }

      async function startStream(message = "Connecting to camera…") {
        shouldStream = true;
        clearReconnectTimer();
        activeStreamMode = null;
        toggleButton.textContent = "Pause stream";
        toggleButton.setAttribute("aria-pressed", "true");
        setStatus(message, "busy");
        teardownPeerConnection();
        if (streamImage instanceof HTMLImageElement) {
          streamImage.hidden = true;
          streamImage.removeAttribute("src");
        }
        if (streamVideo instanceof HTMLVideoElement) {
          streamVideo.hidden = true;
          streamVideo.srcObject = null;
        }

        if (webrtcSupported) {
          try {
            await startWebRTCStream();
            return;
          } catch (error) {
            console.error("WebRTC stream error", error);
          }
        }

        if (!shouldStream) {
          return;
        }

        setStatus("Falling back to MJPEG…", "busy");
        try {
          startMjpegStream();
        } catch (error) {
          console.error("MJPEG stream error", error);
          setStatus("Streaming unavailable", "error");
          toggleButton.textContent = "Start stream";
          toggleButton.setAttribute("aria-pressed", "false");
        }
      }

      function stopStream(message = "Streaming paused") {
        shouldStream = false;
        activeStreamMode = null;
        clearReconnectTimer();
        teardownPeerConnection();
        if (streamImage instanceof HTMLImageElement) {
          streamImage.hidden = true;
          streamImage.src = "";
          streamImage.removeAttribute("src");
        }
        setStatus(message, "paused");
        toggleButton.textContent = "Start stream";
        toggleButton.setAttribute("aria-pressed", "false");
      }

      async function saveSnapshot() {
        if (!snapshotButton) {
          return;
        }
        const previousStatus = statusLabel ? statusLabel.textContent : "";
        const originalLabel = snapshotButton.textContent;
        snapshotButton.disabled = true;
        snapshotButton.textContent = "Saving…";
        setStatus("Capturing snapshot…", "busy");

        try {
          const response = await fetch("/api/camera/snapshot", { cache: "no-store" });
          if (!response.ok) {
            throw new Error(`Snapshot request failed with ${response.status}`);
          }
          const blob = await response.blob();
          const url = URL.createObjectURL(blob);
          const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
          const anchor = document.createElement("a");
          anchor.href = url;
          anchor.download = `revcam-${timestamp}.jpg`;
          anchor.style.display = "none";
          document.body.appendChild(anchor);
          anchor.click();
          document.body.removeChild(anchor);
          setTimeout(() => URL.revokeObjectURL(url), 1000);
          setStatus("Snapshot saved", "live");
          setTimeout(() => {
            if (statusLabel && statusLabel.textContent === "Snapshot saved") {
              const fallback = previousStatus || (shouldStream ? "Streaming" : "Streaming paused");
              setStatus(fallback);
            }
          }, 2000);
        } catch (error) {
          console.error("Snapshot error", error);
          setStatus("Snapshot failed", "error");
          setTimeout(() => {
            if (statusLabel && statusLabel.textContent === "Snapshot failed") {
              const fallback = previousStatus || (shouldStream ? "Streaming" : "Streaming paused");
              setStatus(fallback);
            }
          }, 2500);
        } finally {
          snapshotButton.disabled = false;
          snapshotButton.textContent = originalLabel;
        }
      }

      if (illuminationToggle instanceof HTMLButtonElement) {
        illuminationToggle.addEventListener("click", () => {
          if (!illuminationState || illuminationState.available === false) {
            setIlluminationStatus("LED driver unavailable", {
              persistent: true,
              tone: "error",
            });
            refreshIlluminationState({ showLoading: true });
            return;
          }
          const active = illuminationState.pattern === "illumination";
          if (!active && illuminationState.pattern && illuminationState.pattern !== "illumination") {
            illuminationPreviousPattern = illuminationState.pattern;
          }
          const targetPattern = active
            ? illuminationPreviousPattern && illuminationPreviousPattern !== "illumination"
              ? illuminationPreviousPattern
              : "ready"
            : "illumination";
          const successMessage = active ? "Illumination disabled" : "Illumination enabled";
          sendIlluminationUpdate({ pattern: targetPattern }, { successMessage }).catch((error) =>
            console.error("LED toggle error", error),
          );
        });
      }

      if (illuminationIntensityInput instanceof HTMLInputElement) {
        const updateDisplayFromInput = () => {
          if (!illuminationIntensityDisplay) {
            return;
          }
          const value = Number(illuminationIntensityInput.value);
          illuminationIntensityDisplay.textContent = `${Math.round(value)}%`;
        };
        illuminationIntensityInput.addEventListener("input", () => {
          illuminationIntensityInput.dataset.userEdited = "true";
          updateDisplayFromInput();
        });
        illuminationIntensityInput.addEventListener("change", () => {
          if (!illuminationState || illuminationState.available === false) {
            setIlluminationStatus("LED driver unavailable", {
              persistent: true,
              tone: "error",
            });
            refreshIlluminationState({ showLoading: true });
            return;
          }
          illuminationIntensityInput.dataset.userEdited = "true";
          updateDisplayFromInput();
          const value = Math.max(0, Math.min(100, Math.round(Number(illuminationIntensityInput.value))));
          sendIlluminationUpdate(
            { illumination_intensity: value },
            { successMessage: "Illumination updated" },
          ).catch((error) => console.error("LED intensity error", error));
        });
      }

      if (illuminationColourInput instanceof HTMLInputElement) {
        illuminationColourInput.addEventListener("input", () => {
          illuminationColourInput.dataset.userEdited = "true";
        });
        illuminationColourInput.addEventListener("change", () => {
          if (!illuminationState || illuminationState.available === false) {
            setIlluminationStatus("LED driver unavailable", {
              persistent: true,
              tone: "error",
            });
            refreshIlluminationState({ showLoading: true });
            return;
          }
          illuminationColourInput.dataset.userEdited = "true";
          const value = illuminationColourInput.value || "#FFFFFF";
          sendIlluminationUpdate(
            { illumination_color: value },
            { successMessage: "Illumination colour updated" },
          ).catch((error) => console.error("LED colour error", error));
        });
      }

      if (streamImage instanceof HTMLImageElement) {
        streamImage.addEventListener("load", () => {
          if (!shouldStream || activeStreamMode !== "mjpeg") {
            return;
          }
          setStatus("Streaming", "live");
        });

        streamImage.addEventListener("error", (event) => {
          if (!shouldStream || activeStreamMode !== "mjpeg") {
            return;
          }
          console.error("MJPEG stream error", event);
          setStatus("Connection lost – retrying…", "error");
          scheduleReconnect();
        });
      }

      if (streamVideo instanceof HTMLVideoElement) {
        streamVideo.addEventListener("playing", () => {
          if (!shouldStream || activeStreamMode !== "webrtc") {
            return;
          }
          setStatus("Streaming", "live");
        });

        streamVideo.addEventListener("error", (event) => {
          if (!shouldStream || activeStreamMode !== "webrtc") {
            return;
          }
          console.error("WebRTC video error", event);
          setStatus("Connection lost – retrying…", "error");
          scheduleReconnect();
        });
      }

      if (reconnectButton instanceof HTMLButtonElement) {
        reconnectButton.addEventListener("click", () => {
          const message = shouldStream ? "Reconnecting…" : "Connecting to camera…";
          startStream(message).catch((error) =>
            console.error("Reconnect button error", error),
          );
        });
      }

      if (toggleButton instanceof HTMLButtonElement) {
        toggleButton.addEventListener("click", () => {
          if (shouldStream) {
            stopStream();
          } else {
            startStream().catch((error) =>
              console.error("Stream toggle error", error),
            );
          }
        });
      }

      if (snapshotButton) {
        snapshotButton.addEventListener("click", () => {
          saveSnapshot().catch((error) => console.error("Snapshot handler error", error));
        });
      }

      window.addEventListener("beforeunload", () => {
        clearReconnectTimer();
        if (batteryTimer) {
          clearInterval(batteryTimer);
        }
        teardownPeerConnection();
      });

      document.addEventListener("visibilitychange", () => {
        if (document.visibilityState === "visible") {
          refreshBattery();
          refreshIlluminationState();
        }
      });

      refreshIlluminationState({ showLoading: true });
      scheduleBatteryUpdates();
      startStream().catch((error) => console.error("Initial stream error", error));
    </script>
  </body>
</html>
