<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Surveillance Recording Playback</title>
    <link rel="icon" type="image/svg+xml" href="images/favicon.svg" />
    <style>
      :root {
        color-scheme: dark;
        --font-family: "Inter", "Manrope", "Segoe UI", system-ui, -apple-system,
          BlinkMacSystemFont, sans-serif;
        --surface-0: rgba(14, 16, 22, 0.9);
        --surface-1: rgba(26, 28, 36, 0.85);
        --border-subtle: rgba(255, 255, 255, 0.12);
        --text-primary: #f5f7fb;
        --text-muted: rgba(245, 247, 250, 0.7);
        --accent: #0a84ff;
        --danger: #ff453a;
        --radius-lg: 1.2rem;
        --space-md: 1rem;
        --space-lg: 1.6rem;
        --page-gradient: radial-gradient(120% 140% at top, #1b1e26 0%, #0b0d13 60%, #050609 100%);
      }
      body {
        margin: 0;
        background: var(--page-gradient);
        font-family: var(--font-family);
        color: var(--text-primary);
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: var(--space-lg);
      }
      .player-card {
        width: min(960px, 100%);
        background: var(--surface-1);
        border-radius: var(--radius-lg);
        border: 1px solid var(--border-subtle);
        box-shadow: 0 24px 48px rgba(0, 0, 0, 0.45);
        padding: var(--space-lg);
        display: flex;
        flex-direction: column;
        gap: var(--space-md);
      }
      .player-card header {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }
      .muted {
        color: var(--text-muted);
      }
      .playback-frame {
        width: 100%;
        border-radius: 0.9rem;
        border: 1px solid var(--border-subtle);
        background: #000;
        min-height: 260px;
      }
      .meta-list {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        color: var(--text-muted);
        font-size: 0.95rem;
      }
      .chunk-summary {
        font-size: 0.85rem;
        color: var(--text-muted);
      }
      .playback-controls {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        padding-inline: 0.4rem;
      }
      .playback-controls[hidden] {
        display: none;
      }
      .time-display {
        display: flex;
        justify-content: space-between;
        font-size: 0.9rem;
        color: var(--text-muted);
        gap: 0.5rem;
      }
      .time-display span {
        white-space: nowrap;
      }
      input[type="range"] {
        width: 100%;
        accent-color: var(--accent);
        cursor: pointer;
      }
      input[type="range"]:disabled {
        cursor: not-allowed;
        opacity: 0.5;
      }
      .transport {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      .transport-buttons {
        display: flex;
        gap: 0.5rem;
        align-items: center;
        justify-content: center;
        flex-wrap: wrap;
      }
      .transport-buttons button {
        min-width: 3rem;
      }
      .playback-options {
        display: flex;
        gap: 0.75rem;
        justify-content: center;
        flex-wrap: wrap;
        align-items: center;
        color: var(--text-muted);
        font-size: 0.85rem;
      }
      .playback-options label {
        display: flex;
        gap: 0.35rem;
        align-items: center;
      }
      button,
      select {
        font: inherit;
      }
      button {
        border: 1px solid var(--border-subtle);
        background: rgba(255, 255, 255, 0.04);
        color: var(--text-primary);
        padding: 0.45rem 0.8rem;
        border-radius: 999px;
        cursor: pointer;
        transition: background 0.15s ease, border-color 0.15s ease;
      }
      button:hover,
      button:focus-visible {
        background: rgba(10, 132, 255, 0.18);
        border-color: rgba(10, 132, 255, 0.55);
        outline: none;
      }
      button:disabled {
        cursor: not-allowed;
        opacity: 0.5;
      }
      select {
        border-radius: 999px;
        border: 1px solid var(--border-subtle);
        background: rgba(255, 255, 255, 0.03);
        color: var(--text-primary);
        padding: 0.35rem 0.75rem;
      }
      select:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
      .play-pause-button[aria-pressed="true"] {
        background: rgba(10, 132, 255, 0.25);
        border-color: rgba(10, 132, 255, 0.7);
      }
      .loop-button[aria-pressed="true"] {
        background: rgba(10, 132, 255, 0.2);
        border-color: rgba(10, 132, 255, 0.6);
      }
      .error {
        color: var(--danger);
        font-weight: 600;
      }
      a.link {
        color: var(--accent);
        text-decoration: none;
      }
      a.link:hover,
      a.link:focus-visible {
        text-decoration: underline;
      }
    </style>
  </head>
  <body>
    <div class="player-card" role="document">
      <header>
        <h1 id="recording-title">Loading recording…</h1>
        <div class="meta-list" id="recording-meta"></div>
        <div class="chunk-summary" id="chunk-summary"></div>
        <p class="muted" id="status-text">Preparing playback…</p>
      </header>
      <img id="playback-frame" class="playback-frame" alt="Recording playback" hidden />
      <div class="playback-controls" id="playback-controls" hidden>
        <div class="time-display" aria-live="polite">
          <span id="current-time" aria-label="Current position">Current 0:00</span>
          <span id="total-time" aria-label="Clip length">Length 0:00</span>
        </div>
        <input
          id="playback-slider"
          type="range"
          min="0"
          max="0"
          value="0"
          step="1"
          aria-label="Scrub through recording"
        />
        <div class="transport" role="group" aria-label="Playback controls">
          <div class="transport-buttons">
            <button type="button" id="jump-start" aria-label="Go to start">
              ⏮
            </button>
            <button type="button" id="frame-back" aria-label="Step back one frame">
              ⏪
            </button>
            <button
              type="button"
              id="play-pause"
              class="play-pause-button"
              aria-pressed="false"
              aria-label="Play or pause recording"
            >
              Play
            </button>
            <button type="button" id="frame-forward" aria-label="Step forward one frame">
              ⏩
            </button>
            <button type="button" id="jump-end" aria-label="Go to end">
              ⏭
            </button>
          </div>
          <div class="playback-options">
            <label for="playback-rate">
              Speed
              <select id="playback-rate" aria-label="Playback speed">
                <option value="0.25">0.25×</option>
                <option value="0.5">0.5×</option>
                <option value="0.75">0.75×</option>
                <option value="1" selected>1×</option>
                <option value="1.5">1.5×</option>
                <option value="2">2×</option>
              </select>
            </label>
            <button
              type="button"
              id="loop-toggle"
              class="loop-button"
              aria-pressed="false"
              aria-label="Toggle looping playback"
            >
              Loop off
            </button>
          </div>
        </div>
      </div>
      <p class="muted">
        <a class="link" href="/surveillance">Back to surveillance</a>
      </p>
    </div>
    <script>
      const params = new URLSearchParams(window.location.search);
      const recordingName = params.get("name");
      const title = document.getElementById("recording-title");
      const metaList = document.getElementById("recording-meta");
      const chunkSummary = document.getElementById("chunk-summary");
      const statusText = document.getElementById("status-text");
      const playbackFrame = document.getElementById("playback-frame");
      const playbackControls = document.getElementById("playback-controls");
      const playbackSlider = document.getElementById("playback-slider");
      const currentTimeLabel = document.getElementById("current-time");
      const totalTimeLabel = document.getElementById("total-time");
      const playPauseButton = document.getElementById("play-pause");
      const frameBackButton = document.getElementById("frame-back");
      const frameForwardButton = document.getElementById("frame-forward");
      const jumpStartButton = document.getElementById("jump-start");
      const jumpEndButton = document.getElementById("jump-end");
      const loopToggleButton = document.getElementById("loop-toggle");
      const playbackRateSelect = document.getElementById("playback-rate");

      const playbackState = {
        frames: [],
        intervals: [],
        frameTimes: [],
        fallbackInterval: 200,
        index: 0,
        timer: null,
        isScrubbing: false,
        totalDuration: 0,
        isPlaying: false,
        isLooping: false,
        playbackRate: 1,
        firstTimestamp: null,
        hasInitialFrame: false,
        autoPlayRequested: true,
        initialised: false,
      };

      function setStatus(message, tone = "info") {
        if (tone === "error") {
          statusText.classList.add("error");
        } else {
          statusText.classList.remove("error");
        }
        statusText.textContent = message;
      }

      function formatBytes(bytes) {
        if (typeof bytes !== "number" || !Number.isFinite(bytes) || bytes < 0) {
          return null;
        }
        const units = ["B", "KB", "MB", "GB", "TB"];
        let value = bytes;
        let index = 0;
        while (value >= 1024 && index < units.length - 1) {
          value /= 1024;
          index += 1;
        }
        const display = value >= 10 || index === 0 ? value.toFixed(0) : value.toFixed(1);
        return `${display.replace(/\.0$/, "")} ${units[index]}`;
      }

      function formatTime(seconds) {
        if (typeof seconds !== "number" || !Number.isFinite(seconds) || seconds < 0) {
          return "0:00";
        }
        const totalSeconds = Math.floor(seconds);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const secs = totalSeconds % 60;
        const pad = (value) => value.toString().padStart(2, "0");
        if (hours > 0) {
          return `${hours}:${pad(minutes)}:${pad(secs)}`;
        }
        return `${minutes}:${pad(secs)}`;
      }

      function updateFallbackFromFps(fps) {
        if (typeof fps === "number" && Number.isFinite(fps) && fps > 0) {
          playbackState.fallbackInterval = Math.max(40, Math.round(1000 / fps));
        } else {
          playbackState.fallbackInterval = 200;
        }
      }

      function resetPlaybackState(fps) {
        updateFallbackFromFps(fps);
        playbackState.frames = [];
        playbackState.intervals = [];
        playbackState.frameTimes = [];
        playbackState.index = 0;
        playbackState.totalDuration = 0;
        playbackState.isPlaying = false;
        playbackState.isLooping = false;
        playbackState.playbackRate = 1;
        playbackState.isScrubbing = false;
        playbackState.firstTimestamp = null;
        playbackState.hasInitialFrame = false;
        playbackState.autoPlayRequested = true;
        playbackState.initialised = true;
        stopPlaybackTimer();
        if (playbackFrame) {
          playbackFrame.hidden = true;
          playbackFrame.removeAttribute("src");
        }
        if (playbackControls) {
          playbackControls.hidden = true;
        }
        if (playbackSlider) {
          playbackSlider.value = "0";
          playbackSlider.max = "0";
          playbackSlider.disabled = true;
        }
        if (playbackRateSelect) {
          playbackRateSelect.value = "1";
        }
        if (loopToggleButton) {
          loopToggleButton.setAttribute("aria-pressed", "false");
          loopToggleButton.textContent = "Loop off";
        }
        updateTimeDisplay(0);
        updateTransportState();
      }

      function normaliseFrames(rawFrames) {
        if (!Array.isArray(rawFrames)) {
          return [];
        }
        return rawFrames
          .map((frame) => ({
            jpeg: frame && typeof frame.jpeg === "string" ? frame.jpeg : null,
            timestamp:
              frame && typeof frame.timestamp === "number" && Number.isFinite(frame.timestamp)
                ? Number(frame.timestamp)
                : null,
          }))
          .filter((frame) => typeof frame.jpeg === "string" && frame.jpeg.length > 0);
      }

      function appendFrames(rawFrames) {
        const playable = normaliseFrames(rawFrames);
        if (!playable.length) {
          return false;
        }
        playable.forEach((frame) => {
          if (
            playbackState.firstTimestamp === null &&
            frame.timestamp !== null &&
            Number.isFinite(frame.timestamp)
          ) {
            playbackState.firstTimestamp = frame.timestamp;
          }
          const existingCount = playbackState.frames.length;
          if (existingCount === 0) {
            playbackState.frames.push(frame);
            playbackState.frameTimes.push(0);
            playbackState.intervals.push(playbackState.fallbackInterval);
            return;
          }
          const previousIndex = existingCount - 1;
          const previousFrame = playbackState.frames[previousIndex];
          const previousTimestamp = previousFrame.timestamp;
          const currentTimestamp = frame.timestamp;
          let interval = playbackState.fallbackInterval;
          if (
            previousTimestamp !== null &&
            Number.isFinite(previousTimestamp) &&
            currentTimestamp !== null &&
            Number.isFinite(currentTimestamp) &&
            currentTimestamp >= previousTimestamp
          ) {
            interval = Math.max(40, Math.round((currentTimestamp - previousTimestamp) * 1000));
          } else if (
            currentTimestamp !== null &&
            Number.isFinite(currentTimestamp) &&
            playbackState.firstTimestamp !== null &&
            Number.isFinite(playbackState.firstTimestamp)
          ) {
            const elapsedCurrent = Math.max(
              0,
              Math.round((currentTimestamp - playbackState.firstTimestamp) * 1000),
            );
            const priorTime = playbackState.frameTimes[previousIndex] ?? 0;
            const priorElapsed = Math.max(0, Math.round(priorTime * 1000));
            if (elapsedCurrent > priorElapsed) {
              interval = Math.max(40, elapsedCurrent - priorElapsed);
            }
          }
          playbackState.intervals[previousIndex] = interval;
          let frameTime = 0;
          if (
            currentTimestamp !== null &&
            Number.isFinite(currentTimestamp) &&
            playbackState.firstTimestamp !== null &&
            Number.isFinite(playbackState.firstTimestamp)
          ) {
            frameTime = Math.max(0, currentTimestamp - playbackState.firstTimestamp);
          } else {
            const priorTime = playbackState.frameTimes[previousIndex] ?? 0;
            frameTime = priorTime + interval / 1000;
          }
          playbackState.frames.push(frame);
          playbackState.frameTimes.push(frameTime);
          playbackState.intervals.push(playbackState.fallbackInterval);
        });
        return true;
      }

      function ensurePlaybackVisible() {
        if (playbackFrame) {
          playbackFrame.hidden = false;
        }
        if (playbackControls) {
          playbackControls.hidden = false;
        }
        setupSliderEvents();
      }

      function refreshControls() {
        const frameCount = playbackState.frames.length;
        const lastIndex = frameCount - 1;
        const lastTime = playbackState.frameTimes[lastIndex];
        const fallbackSeconds =
          frameCount > 1 ? (frameCount - 1) * (playbackState.fallbackInterval / 1000) : 0;
        let totalDuration = 0;
        if (typeof lastTime === "number" && Number.isFinite(lastTime) && lastTime > 0) {
          totalDuration = lastTime;
        } else if (Number.isFinite(fallbackSeconds) && fallbackSeconds > 0) {
          totalDuration = fallbackSeconds;
        }
        playbackState.totalDuration = totalDuration;
        if (playbackSlider && !playbackState.isScrubbing) {
          playbackSlider.max = String(Math.max(lastIndex, 0));
          playbackSlider.disabled = frameCount <= 1;
        }
        const clampedIndex = Math.max(0, Math.min(playbackState.index, lastIndex));
        updateTimeDisplay(clampedIndex);
        updateTransportState();
      }

      function ingestFrames(rawFrames, { fps, silent = false } = {}) {
        if (typeof fps === "number" && Number.isFinite(fps) && fps > 0) {
          updateFallbackFromFps(fps);
        }
        const appended = appendFrames(rawFrames);
        if (!appended) {
          if (!silent && !playbackState.frames.length) {
            setStatus("Recording does not contain any frames.", "error");
            if (playbackFrame) {
              playbackFrame.hidden = true;
            }
          }
          return false;
        }
        ensurePlaybackVisible();
        refreshControls();
        if (!playbackState.hasInitialFrame) {
          showFrame(0);
        }
        if (playbackState.autoPlayRequested && playbackState.frames.length > 1 && !playbackState.isPlaying) {
          startPlayback();
        } else if (playbackState.isPlaying) {
          scheduleNextFrame();
        } else {
          updateTransportState();
        }
        return true;
      }

      function stopPlaybackTimer() {
        if (playbackState.timer) {
          window.clearTimeout(playbackState.timer);
          playbackState.timer = null;
        }
      }

      function updateTimeDisplay(index) {
        if (currentTimeLabel) {
          const seconds = playbackState.frameTimes[index] ?? 0;
          currentTimeLabel.textContent = `Current ${formatTime(seconds)}`;
        }
        if (totalTimeLabel) {
          totalTimeLabel.textContent = `Length ${formatTime(playbackState.totalDuration)}`;
        }
      }

      function updateTransportState() {
        const { frames, index, isPlaying, isLooping } = playbackState;
        const multiFrame = frames.length > 1;
        const lastIndex = Math.max(0, frames.length - 1);

        if (playPauseButton) {
          playPauseButton.disabled = !multiFrame;
          playPauseButton.textContent = isPlaying ? "Pause" : "Play";
          playPauseButton.setAttribute("aria-pressed", isPlaying ? "true" : "false");
          playPauseButton.setAttribute(
            "aria-label",
            isPlaying ? "Pause recording" : "Play recording",
          );
        }
        if (frameBackButton) {
          frameBackButton.disabled = !multiFrame || index <= 0;
        }
        if (frameForwardButton) {
          frameForwardButton.disabled = !multiFrame || index >= lastIndex;
        }
        if (jumpStartButton) {
          jumpStartButton.disabled = !multiFrame || index <= 0;
        }
        if (jumpEndButton) {
          jumpEndButton.disabled = !multiFrame || index >= lastIndex;
        }
        if (loopToggleButton) {
          loopToggleButton.disabled = !multiFrame;
          loopToggleButton.textContent = isLooping ? "Loop on" : "Loop off";
          loopToggleButton.setAttribute("aria-pressed", isLooping ? "true" : "false");
        }
        if (playbackRateSelect) {
          playbackRateSelect.disabled = !multiFrame;
        }
      }

      function getFrameDelay(index) {
        const baseInterval = playbackState.intervals[index] ?? playbackState.fallbackInterval;
        const rate = playbackState.playbackRate > 0 ? playbackState.playbackRate : 1;
        const scaled = baseInterval / rate;
        const minimum = 16;
        if (!Number.isFinite(scaled) || scaled <= 0) {
          return Math.max(minimum, playbackState.fallbackInterval);
        }
        return Math.max(minimum, Math.round(scaled));
      }

      function showFrame(index, { updateSlider = true } = {}) {
        if (!playbackFrame || !playbackState.frames.length) {
          return;
        }
        const normalizedIndex = Math.max(0, Math.min(index, playbackState.frames.length - 1));
        const frame = playbackState.frames[normalizedIndex];
        if (!frame || typeof frame.jpeg !== "string") {
          return;
        }
        playbackState.index = normalizedIndex;
        playbackState.hasInitialFrame = true;
        playbackFrame.src = `data:image/jpeg;base64,${frame.jpeg}`;
        if (
          playbackSlider &&
          updateSlider &&
          !playbackState.isScrubbing &&
          Number.isFinite(normalizedIndex)
        ) {
          playbackSlider.value = String(normalizedIndex);
        }
        updateTimeDisplay(normalizedIndex);
        updateTransportState();
      }

      function scheduleNextFrame() {
        stopPlaybackTimer();
        if (
          !playbackState.isPlaying ||
          playbackState.isScrubbing ||
          playbackState.frames.length <= 1
        ) {
          return;
        }
        const currentIndex = playbackState.index;
        const delay = getFrameDelay(currentIndex);
        playbackState.timer = window.setTimeout(() => {
          playbackState.timer = null;
          if (
            !playbackState.isPlaying ||
            playbackState.isScrubbing ||
            !playbackState.frames.length
          ) {
            return;
          }
          let nextIndex = playbackState.index + 1;
          if (nextIndex >= playbackState.frames.length) {
            if (playbackState.isLooping && playbackState.frames.length) {
              nextIndex = 0;
              showFrame(nextIndex);
              scheduleNextFrame();
            } else {
              playbackState.isPlaying = false;
              updateTransportState();
            }
            return;
          }
          showFrame(nextIndex);
          scheduleNextFrame();
        }, delay);
      }

      function pausePlayback() {
        if (!playbackState.frames.length) {
          return;
        }
        playbackState.isPlaying = false;
        playbackState.autoPlayRequested = false;
        stopPlaybackTimer();
        updateTransportState();
      }

      function startPlayback({ restart = false } = {}) {
        playbackState.autoPlayRequested = true;
        if (!playbackState.frames.length) {
          return;
        }
        if (playbackState.frames.length <= 1) {
          playbackState.isPlaying = false;
          updateTransportState();
          return;
        }
        if (
          restart ||
          (playbackState.index >= playbackState.frames.length - 1 && !playbackState.isLooping)
        ) {
          showFrame(0);
        }
        playbackState.isPlaying = true;
        updateTransportState();
        scheduleNextFrame();
      }

      function togglePlayback() {
        if (playbackState.isPlaying) {
          pausePlayback();
        } else {
          startPlayback();
        }
      }

      function stepFrame(step) {
        if (!playbackState.frames.length || !Number.isFinite(step)) {
          return;
        }
        const target = Math.max(
          0,
          Math.min(playbackState.index + Math.trunc(step), playbackState.frames.length - 1),
        );
        pausePlayback();
        showFrame(target);
      }

      function jumpToStart() {
        if (!playbackState.frames.length) {
          return;
        }
        showFrame(0);
        if (playbackState.isPlaying) {
          scheduleNextFrame();
        }
      }

      function jumpToEnd() {
        if (!playbackState.frames.length) {
          return;
        }
        const lastIndex = playbackState.frames.length - 1;
        showFrame(lastIndex);
        pausePlayback();
      }

      function toggleLooping() {
        if (!playbackState.frames.length) {
          return;
        }
        playbackState.isLooping = !playbackState.isLooping;
        updateTransportState();
        if (playbackState.isPlaying) {
          scheduleNextFrame();
        }
      }

      function setPlaybackRate(rate) {
        if (!Number.isFinite(rate) || rate <= 0) {
          return;
        }
        playbackState.playbackRate = rate;
        updateTransportState();
        if (playbackState.isPlaying) {
          scheduleNextFrame();
        }
      }

      function setupSliderEvents() {
        if (!playbackSlider) {
          return;
        }
        if (playbackSlider.dataset.enhanced === "true") {
          return;
        }
        const beginScrub = () => {
          playbackState.isScrubbing = true;
          stopPlaybackTimer();
        };
        const endScrub = () => {
          if (!playbackState.frames.length) {
            playbackState.isScrubbing = false;
            updateTransportState();
            return;
          }
          playbackState.isScrubbing = false;
          if (playbackState.isPlaying) {
            scheduleNextFrame();
          } else {
            updateTransportState();
          }
        };
        playbackSlider.addEventListener("input", (event) => {
          if (!playbackState.frames.length) {
            return;
          }
          beginScrub();
          const target = event.target;
          const value = Number(target && typeof target.value === "string" ? target.value : playbackSlider.value);
          if (Number.isFinite(value)) {
            showFrame(Math.round(value), { updateSlider: false });
          }
        });
        playbackSlider.addEventListener("change", endScrub);
        playbackSlider.addEventListener("pointerdown", beginScrub);
        playbackSlider.addEventListener("pointerup", endScrub);
        playbackSlider.addEventListener("mousedown", beginScrub);
        playbackSlider.addEventListener("mouseup", endScrub);
        playbackSlider.addEventListener("touchstart", beginScrub, { passive: true });
        playbackSlider.addEventListener("touchend", endScrub, { passive: true });
        playbackSlider.addEventListener("blur", () => {
          if (playbackState.isScrubbing) {
            endScrub();
          }
        });
        playbackSlider.dataset.enhanced = "true";
      }

      if (playPauseButton) {
        playPauseButton.addEventListener("click", () => {
          togglePlayback();
        });
      }
      if (frameBackButton) {
        frameBackButton.addEventListener("click", () => {
          stepFrame(-1);
        });
      }
      if (frameForwardButton) {
        frameForwardButton.addEventListener("click", () => {
          stepFrame(1);
        });
      }
      if (jumpStartButton) {
        jumpStartButton.addEventListener("click", () => {
          jumpToStart();
        });
      }
      if (jumpEndButton) {
        jumpEndButton.addEventListener("click", () => {
          jumpToEnd();
        });
      }
      if (loopToggleButton) {
        loopToggleButton.addEventListener("click", () => {
          toggleLooping();
        });
      }
      if (playbackRateSelect) {
        playbackRateSelect.addEventListener("change", (event) => {
          const value = Number(event.target && event.target.value);
          if (Number.isFinite(value) && value > 0) {
            setPlaybackRate(value);
          }
        });
      }

      updateTransportState();

      function renderMeta(data) {
        metaList.innerHTML = "";
        if (chunkSummary) {
          chunkSummary.textContent = "";
        }
        const entries = [];
        if (data.started_at) {
          entries.push(`Started: ${new Date(data.started_at).toLocaleString()}`);
        }
        if (data.ended_at) {
          entries.push(`Finished: ${new Date(data.ended_at).toLocaleString()}`);
        }
        if (typeof data.duration_seconds === "number") {
          entries.push(`Duration: ${data.duration_seconds.toFixed(1)}s`);
        }
        if (typeof data.frame_count === "number") {
          entries.push(`Frames: ${data.frame_count}`);
        }
        if (typeof data.fps === "number") {
          entries.push(`Recorded at ${data.fps} fps`);
        }
        if (typeof data.size_bytes === "number") {
          const sizeLabel = formatBytes(data.size_bytes);
          if (sizeLabel) {
            entries.push(`Size: ${sizeLabel}`);
          }
        }
        if (!entries.length) {
          metaList.textContent = "No metadata available.";
          return;
        }
        entries.forEach((text) => {
          const span = document.createElement("span");
          span.textContent = text;
          metaList.appendChild(span);
        });
        if (Array.isArray(data.chunks) && data.chunks.length && chunkSummary) {
          const details = data.chunks
            .map((chunk, idx) => {
              if (!chunk || typeof chunk !== "object") {
                return null;
              }
              const label = idx + 1;
              const sizeLabel = formatBytes(chunk.size_bytes);
              return sizeLabel ? `Chunk ${label} — ${sizeLabel}` : null;
            })
            .filter(Boolean);
          if (details.length) {
            chunkSummary.textContent = details.join(" • ");
          }
        }
      }

      async function fetchRecordingPayload(includeFrames) {
        const params = new URLSearchParams();
        params.set("include_frames", includeFrames ? "true" : "false");
        const response = await fetch(
          `/api/surveillance/recordings/${encodeURIComponent(recordingName)}?${params.toString()}`,
          { cache: "no-store" },
        );
        if (!response.ok) {
          throw new Error(`Request failed with ${response.status}`);
        }
        const payload = await response.json();
        if (!payload || typeof payload !== "object") {
          throw new Error("Invalid recording payload");
        }
        return payload;
      }

      async function fetchRecordingChunk(index, total) {
        if (Number.isFinite(total) && total > 0) {
          setStatus(`Loading chunk ${index} of ${total}…`);
        } else {
          setStatus(`Loading chunk ${index}…`);
        }
        const response = await fetch(
          `/api/surveillance/recordings/${encodeURIComponent(recordingName)}/chunks/${index}`,
          { cache: "no-store" },
        );
        if (!response.ok) {
          throw new Error(`Chunk request failed with ${response.status}`);
        }
        const payload = await response.json();
        if (!payload || typeof payload !== "object") {
          throw new Error("Invalid chunk payload");
        }
        return payload;
      }

      async function loadRecording() {
        if (!recordingName) {
          setStatus("Missing recording identifier.", "error");
          return;
        }
        title.textContent = recordingName;
        playbackFrame.hidden = true;
        if (playbackControls) {
          playbackControls.hidden = true;
        }
        stopPlaybackTimer();
        setStatus("Loading recording…");
        try {
          let payload;
          let payloadIncludesFrames = false;
          try {
            payload = await fetchRecordingPayload(false);
          } catch (metaError) {
            console.warn("Falling back to full recording fetch", metaError);
            payload = await fetchRecordingPayload(true);
            payloadIncludesFrames = true;
          }

          renderMeta(payload);

          let fps =
            typeof payload.fps === "number" && Number.isFinite(payload.fps) && payload.fps > 0
              ? payload.fps
              : null;
          resetPlaybackState(fps);
          let framesLoaded = false;

          const ensureFps = (value) => {
            if (typeof value === "number" && Number.isFinite(value) && value > 0) {
              fps = value;
              updateFallbackFromFps(fps);
            }
          };

          ensureFps(payload.fps);

          if (payloadIncludesFrames && Array.isArray(payload.frames)) {
            const appended = ingestFrames(payload.frames, { fps, silent: false });
            if (appended) {
              framesLoaded = true;
              setStatus("Playing recording…");
            }
          } else if (Array.isArray(payload.chunks) && payload.chunks.length > 0) {
            const total = payload.chunks.length;
            for (let idx = 0; idx < total; idx += 1) {
              const chunkNumber = idx + 1;
              setStatus(`Loading chunk ${chunkNumber} of ${total}…`);
              const chunkPayload = await fetchRecordingChunk(chunkNumber, total);
              ensureFps(chunkPayload.fps);
              const appended = ingestFrames(chunkPayload.frames, {
                fps,
                silent: framesLoaded,
              });
              if (appended) {
                framesLoaded = true;
                setStatus(`Playing recording… (chunk ${chunkNumber}/${total})`);
              }
            }
          } else if (Array.isArray(payload.frames)) {
            const appended = ingestFrames(payload.frames, { fps, silent: false });
            if (appended) {
              framesLoaded = true;
              setStatus("Playing recording…");
            }
          }

          if (!framesLoaded) {
            const fallback = await fetchRecordingPayload(true);
            ensureFps(fallback.fps);
            resetPlaybackState(fps);
            const appended = ingestFrames(fallback.frames, { fps, silent: false });
            if (!appended) {
              throw new Error("Recording does not contain any frames.");
            }
            framesLoaded = true;
            if (playbackState.frames.length <= 1) {
              setStatus("Recording contains a single frame.");
            } else {
              setStatus("Playing recording…");
            }
          } else if (playbackState.frames.length <= 1) {
            setStatus("Recording contains a single frame.");
          } else {
            setStatus("Playing recording…");
          }
        } catch (error) {
          console.error("Failed to load recording", error);
          const message = error instanceof Error ? error.message : "Unable to load recording";
          setStatus(message, "error");
        }
      }

      window.addEventListener("beforeunload", () => {
        stopPlaybackTimer();
      });

      loadRecording();
    </script>
  </body>
</html>
