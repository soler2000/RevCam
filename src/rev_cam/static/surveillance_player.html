<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Surveillance Recording Playback</title>
    <link rel="icon" type="image/svg+xml" href="images/favicon.svg" />
    <style>
      :root {
        color-scheme: dark;
        --font-family: "Inter", "Manrope", "Segoe UI", system-ui, -apple-system,
          BlinkMacSystemFont, sans-serif;
        --surface-0: rgba(14, 16, 22, 0.9);
        --surface-1: rgba(26, 28, 36, 0.85);
        --border-subtle: rgba(255, 255, 255, 0.12);
        --text-primary: #f5f7fb;
        --text-muted: rgba(245, 247, 250, 0.7);
        --accent: #0a84ff;
        --danger: #ff453a;
        --radius-lg: 1.2rem;
        --space-md: 1rem;
        --space-lg: 1.6rem;
        --page-gradient: radial-gradient(120% 140% at top, #1b1e26 0%, #0b0d13 60%, #050609 100%);
      }
      body {
        margin: 0;
        background: var(--page-gradient);
        font-family: var(--font-family);
        color: var(--text-primary);
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: var(--space-lg);
      }
      .player-card {
        width: min(960px, 100%);
        background: var(--surface-1);
        border-radius: var(--radius-lg);
        border: 1px solid var(--border-subtle);
        box-shadow: 0 24px 48px rgba(0, 0, 0, 0.45);
        padding: var(--space-lg);
        display: flex;
        flex-direction: column;
        gap: var(--space-md);
      }
      .player-card header {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }
      .muted {
        color: var(--text-muted);
      }
      .playback-frame {
        width: 100%;
        border-radius: 0.9rem;
        border: 1px solid var(--border-subtle);
        background: #000;
        min-height: 260px;
      }
      .meta-list {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        color: var(--text-muted);
        font-size: 0.95rem;
      }
      .chunk-summary {
        font-size: 0.85rem;
        color: var(--text-muted);
      }
      .playback-controls {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        padding-inline: 0.4rem;
      }
      .playback-controls[hidden] {
        display: none;
      }
      .time-display {
        display: flex;
        justify-content: space-between;
        font-size: 0.9rem;
        color: var(--text-muted);
        gap: 0.5rem;
      }
      .time-display span {
        white-space: nowrap;
      }
      input[type="range"] {
        width: 100%;
        accent-color: var(--accent);
        cursor: pointer;
      }
      input[type="range"]:disabled {
        cursor: not-allowed;
        opacity: 0.5;
      }
      .error {
        color: var(--danger);
        font-weight: 600;
      }
      a.link {
        color: var(--accent);
        text-decoration: none;
      }
      a.link:hover,
      a.link:focus-visible {
        text-decoration: underline;
      }
    </style>
  </head>
  <body>
    <div class="player-card" role="document">
      <header>
        <h1 id="recording-title">Loading recording…</h1>
        <div class="meta-list" id="recording-meta"></div>
        <div class="chunk-summary" id="chunk-summary"></div>
        <p class="muted" id="status-text">Preparing playback…</p>
      </header>
      <img id="playback-frame" class="playback-frame" alt="Recording playback" hidden />
      <div class="playback-controls" id="playback-controls" hidden>
        <div class="time-display" aria-live="polite">
          <span id="current-time" aria-label="Current position">Current 0:00</span>
          <span id="total-time" aria-label="Clip length">Length 0:00</span>
        </div>
        <input
          id="playback-slider"
          type="range"
          min="0"
          max="0"
          value="0"
          step="1"
          aria-label="Scrub through recording"
        />
      </div>
      <p class="muted">
        <a class="link" href="/surveillance">Back to surveillance</a>
      </p>
    </div>
    <script>
      const params = new URLSearchParams(window.location.search);
      const recordingName = params.get("name");
      const title = document.getElementById("recording-title");
      const metaList = document.getElementById("recording-meta");
      const chunkSummary = document.getElementById("chunk-summary");
      const statusText = document.getElementById("status-text");
      const playbackFrame = document.getElementById("playback-frame");
      const playbackControls = document.getElementById("playback-controls");
      const playbackSlider = document.getElementById("playback-slider");
      const currentTimeLabel = document.getElementById("current-time");
      const totalTimeLabel = document.getElementById("total-time");

      const playbackState = {
        frames: [],
        intervals: [],
        frameTimes: [],
        fallbackInterval: 200,
        index: 0,
        timer: null,
        isScrubbing: false,
        totalDuration: 0,
      };

      function setStatus(message, tone = "info") {
        if (tone === "error") {
          statusText.classList.add("error");
        } else {
          statusText.classList.remove("error");
        }
        statusText.textContent = message;
      }

      function formatBytes(bytes) {
        if (typeof bytes !== "number" || !Number.isFinite(bytes) || bytes < 0) {
          return null;
        }
        const units = ["B", "KB", "MB", "GB", "TB"];
        let value = bytes;
        let index = 0;
        while (value >= 1024 && index < units.length - 1) {
          value /= 1024;
          index += 1;
        }
        const display = value >= 10 || index === 0 ? value.toFixed(0) : value.toFixed(1);
        return `${display.replace(/\.0$/, "")} ${units[index]}`;
      }

      function formatTime(seconds) {
        if (typeof seconds !== "number" || !Number.isFinite(seconds) || seconds < 0) {
          return "0:00";
        }
        const totalSeconds = Math.floor(seconds);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const secs = totalSeconds % 60;
        const pad = (value) => value.toString().padStart(2, "0");
        if (hours > 0) {
          return `${hours}:${pad(minutes)}:${pad(secs)}`;
        }
        return `${minutes}:${pad(secs)}`;
      }

      function stopPlaybackTimer() {
        if (playbackState.timer) {
          window.clearTimeout(playbackState.timer);
          playbackState.timer = null;
        }
      }

      function updateTimeDisplay(index) {
        if (currentTimeLabel) {
          const seconds = playbackState.frameTimes[index] ?? 0;
          currentTimeLabel.textContent = `Current ${formatTime(seconds)}`;
        }
        if (totalTimeLabel) {
          totalTimeLabel.textContent = `Length ${formatTime(playbackState.totalDuration)}`;
        }
      }

      function showFrame(index, { updateSlider = true } = {}) {
        if (!playbackFrame || !playbackState.frames.length) {
          return;
        }
        const normalizedIndex = Math.max(0, Math.min(index, playbackState.frames.length - 1));
        const frame = playbackState.frames[normalizedIndex];
        if (!frame || typeof frame.jpeg !== "string") {
          return;
        }
        playbackState.index = normalizedIndex;
        playbackFrame.src = `data:image/jpeg;base64,${frame.jpeg}`;
        if (
          playbackSlider &&
          updateSlider &&
          !playbackState.isScrubbing &&
          Number.isFinite(normalizedIndex)
        ) {
          playbackSlider.value = String(normalizedIndex);
        }
        updateTimeDisplay(normalizedIndex);
      }

      function scheduleNextFrame() {
        stopPlaybackTimer();
        if (playbackState.isScrubbing || playbackState.frames.length <= 1) {
          return;
        }
        const currentIndex = playbackState.index;
        const delay = playbackState.intervals[currentIndex] ?? playbackState.fallbackInterval;
        playbackState.timer = window.setTimeout(() => {
          if (playbackState.isScrubbing || !playbackState.frames.length) {
            scheduleNextFrame();
            return;
          }
          const nextIndex = (playbackState.index + 1) % playbackState.frames.length;
          showFrame(nextIndex);
          scheduleNextFrame();
        }, delay);
      }

      function prepareControls(playable, frameTimes, intervals, fallbackInterval, cycleDurationMs) {
        playbackState.frames = playable;
        playbackState.frameTimes = frameTimes;
        playbackState.fallbackInterval = fallbackInterval;
        if (Array.isArray(intervals) && intervals.length === playable.length) {
          playbackState.intervals = [...intervals];
        } else {
          playbackState.intervals = new Array(playable.length).fill(fallbackInterval);
        }
        const lastTime = frameTimes[frameTimes.length - 1];
        const derivedTotal = Number.isFinite(lastTime) ? lastTime : 0;
        const cycleSeconds = Number.isFinite(cycleDurationMs)
          ? Math.max(0, cycleDurationMs / 1000)
          : 0;
        playbackState.totalDuration = derivedTotal > 0 ? derivedTotal : cycleSeconds;
        playbackState.index = 0;
        playbackState.isScrubbing = false;
        stopPlaybackTimer();

        if (playbackControls) {
          playbackControls.hidden = false;
        }
        if (playbackSlider) {
          playbackSlider.max = String(Math.max(playable.length - 1, 0));
          playbackSlider.value = "0";
          playbackSlider.disabled = playable.length <= 1;
        }
        updateTimeDisplay(0);
      }

      function setupSliderEvents() {
        if (!playbackSlider) {
          return;
        }
        if (playbackSlider.dataset.enhanced === "true") {
          return;
        }
        const beginScrub = () => {
          playbackState.isScrubbing = true;
          stopPlaybackTimer();
        };
        const endScrub = () => {
          if (!playbackState.frames.length) {
            return;
          }
          playbackState.isScrubbing = false;
          scheduleNextFrame();
        };
        playbackSlider.addEventListener("input", (event) => {
          if (!playbackState.frames.length) {
            return;
          }
          beginScrub();
          const target = event.target;
          const value = Number(target && typeof target.value === "string" ? target.value : playbackSlider.value);
          if (Number.isFinite(value)) {
            showFrame(Math.round(value), { updateSlider: false });
          }
        });
        playbackSlider.addEventListener("change", endScrub);
        playbackSlider.addEventListener("pointerdown", beginScrub);
        playbackSlider.addEventListener("pointerup", endScrub);
        playbackSlider.addEventListener("mousedown", beginScrub);
        playbackSlider.addEventListener("mouseup", endScrub);
        playbackSlider.addEventListener("touchstart", beginScrub, { passive: true });
        playbackSlider.addEventListener("touchend", endScrub, { passive: true });
        playbackSlider.addEventListener("blur", () => {
          if (playbackState.isScrubbing) {
            endScrub();
          }
        });
        playbackSlider.dataset.enhanced = "true";
      }

      function renderMeta(data) {
        metaList.innerHTML = "";
        if (chunkSummary) {
          chunkSummary.textContent = "";
        }
        const entries = [];
        if (data.started_at) {
          entries.push(`Started: ${new Date(data.started_at).toLocaleString()}`);
        }
        if (data.ended_at) {
          entries.push(`Finished: ${new Date(data.ended_at).toLocaleString()}`);
        }
        if (typeof data.duration_seconds === "number") {
          entries.push(`Duration: ${data.duration_seconds.toFixed(1)}s`);
        }
        if (typeof data.frame_count === "number") {
          entries.push(`Frames: ${data.frame_count}`);
        }
        if (typeof data.fps === "number") {
          entries.push(`Recorded at ${data.fps} fps`);
        }
        if (typeof data.size_bytes === "number") {
          const sizeLabel = formatBytes(data.size_bytes);
          if (sizeLabel) {
            entries.push(`Size: ${sizeLabel}`);
          }
        }
        if (!entries.length) {
          metaList.textContent = "No metadata available.";
          return;
        }
        entries.forEach((text) => {
          const span = document.createElement("span");
          span.textContent = text;
          metaList.appendChild(span);
        });
        if (Array.isArray(data.chunks) && data.chunks.length && chunkSummary) {
          const details = data.chunks
            .map((chunk, idx) => {
              if (!chunk || typeof chunk !== "object") {
                return null;
              }
              const label = idx + 1;
              const sizeLabel = formatBytes(chunk.size_bytes);
              return sizeLabel ? `Chunk ${label} — ${sizeLabel}` : null;
            })
            .filter(Boolean);
          if (details.length) {
            chunkSummary.textContent = details.join(" • ");
          }
        }
      }

      function playFrames(frames, fps) {
        if (!playbackFrame) {
          return;
        }
        if (!Array.isArray(frames) || frames.length === 0) {
          setStatus("Recording does not contain any frames.", "error");
          playbackFrame.hidden = true;
          return;
        }
        const playable = frames
          .map((frame) => ({
            jpeg: frame && typeof frame.jpeg === "string" ? frame.jpeg : null,
            timestamp:
              frame && typeof frame.timestamp === "number" && Number.isFinite(frame.timestamp)
                ? Number(frame.timestamp)
                : null,
          }))
          .filter((frame) => typeof frame.jpeg === "string" && frame.jpeg.length > 0);
        if (!playable.length) {
          setStatus("Recording frames are invalid.", "error");
          playbackFrame.hidden = true;
          return;
        }

        const fallbackInterval = fps && fps > 0 ? Math.max(40, Math.round(1000 / fps)) : 200;
        const firstTimestamp = playable.find((frame) => frame.timestamp !== null)?.timestamp ?? null;
        let lastTimestamp = null;
        for (let idx = playable.length - 1; idx >= 0; idx -= 1) {
          const candidate = playable[idx].timestamp;
          if (candidate !== null) {
            lastTimestamp = candidate;
            break;
          }
        }
        let cycleDurationMs = fallbackInterval * playable.length;
        if (
          firstTimestamp !== null &&
          lastTimestamp !== null &&
          lastTimestamp > firstTimestamp &&
          Number.isFinite(lastTimestamp) &&
          Number.isFinite(firstTimestamp)
        ) {
          cycleDurationMs = Math.max(
            40,
            Math.round((lastTimestamp - firstTimestamp) * 1000),
          );
        }
        if (!Number.isFinite(cycleDurationMs) || cycleDurationMs <= 0) {
          cycleDurationMs = fallbackInterval * playable.length;
        }

        const intervals = playable.map((frame, idx) => {
          const nextFrame = playable[(idx + 1) % playable.length];
          const currentTs = frame.timestamp;
          const nextTs = nextFrame.timestamp;
          let delay = fallbackInterval;
          if (
            currentTs !== null &&
            nextTs !== null &&
            Number.isFinite(currentTs) &&
            Number.isFinite(nextTs) &&
            nextTs >= currentTs
          ) {
            delay = Math.max(40, Math.round((nextTs - currentTs) * 1000));
          } else if (
            currentTs !== null &&
            Number.isFinite(currentTs) &&
            firstTimestamp !== null &&
            Number.isFinite(firstTimestamp) &&
            cycleDurationMs > 0
          ) {
            const elapsed = Math.max(0, Math.round((currentTs - firstTimestamp) * 1000));
            const remaining = cycleDurationMs - elapsed;
            if (remaining > 0 && Number.isFinite(remaining)) {
              delay = Math.max(40, remaining);
            }
          }
          if (!Number.isFinite(delay) || delay <= 0) {
            delay = fallbackInterval;
          }
          return delay;
        });

        const frameTimes = [];
        for (let idx = 0; idx < playable.length; idx += 1) {
          if (idx === 0) {
            frameTimes.push(0);
            continue;
          }
          const currentTs = playable[idx].timestamp;
          if (
            currentTs !== null &&
            Number.isFinite(currentTs) &&
            firstTimestamp !== null &&
            Number.isFinite(firstTimestamp)
          ) {
            frameTimes.push(Math.max(0, currentTs - firstTimestamp));
            continue;
          }
          const priorTime = frameTimes[idx - 1] ?? 0;
          const interval = intervals[idx - 1] ?? fallbackInterval;
          frameTimes.push(priorTime + interval / 1000);
        }

        playbackFrame.hidden = false;
        setupSliderEvents();
        prepareControls(playable, frameTimes, intervals, fallbackInterval, cycleDurationMs);
        showFrame(0);
        scheduleNextFrame();
      }

      async function loadRecording() {
        if (!recordingName) {
          setStatus("Missing recording identifier.", "error");
          return;
        }
        title.textContent = recordingName;
        try {
          const response = await fetch(
            `/api/surveillance/recordings/${encodeURIComponent(recordingName)}`,
            { cache: "no-store" },
          );
          if (!response.ok) {
            throw new Error(`Request failed with ${response.status}`);
          }
          const payload = await response.json();
          if (!payload || typeof payload !== "object") {
            throw new Error("Invalid recording payload");
          }
          renderMeta(payload);
          setStatus("Playing recording…");
          playFrames(payload.frames, payload.fps);
        } catch (error) {
          console.error("Failed to load recording", error);
          setStatus("Unable to load recording", "error");
        }
      }

      window.addEventListener("beforeunload", () => {
        stopPlaybackTimer();
      });

      loadRecording();
    </script>
  </body>
</html>
