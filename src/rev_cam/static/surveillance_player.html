<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Surveillance Recording Playback</title>
    <link rel="icon" type="image/svg+xml" href="images/favicon.svg" />
    <style>
      :root {
        color-scheme: dark;
        --font-family: "Inter", "Manrope", "Segoe UI", system-ui, -apple-system,
          BlinkMacSystemFont, sans-serif;
        --surface-0: rgba(14, 16, 22, 0.9);
        --surface-1: rgba(26, 28, 36, 0.85);
        --border-subtle: rgba(255, 255, 255, 0.12);
        --text-primary: #f5f7fb;
        --text-muted: rgba(245, 247, 250, 0.7);
        --accent: #0a84ff;
        --danger: #ff453a;
        --radius-lg: 1.2rem;
        --space-md: 1rem;
        --space-lg: 1.6rem;
        --page-gradient: radial-gradient(120% 140% at top, #1b1e26 0%, #0b0d13 60%, #050609 100%);
      }
      body {
        margin: 0;
        background: var(--page-gradient);
        font-family: var(--font-family);
        color: var(--text-primary);
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: var(--space-lg);
      }
      .player-card {
        width: min(960px, 100%);
        background: var(--surface-1);
        border-radius: var(--radius-lg);
        border: 1px solid var(--border-subtle);
        box-shadow: 0 24px 48px rgba(0, 0, 0, 0.45);
        padding: var(--space-lg);
        display: flex;
        flex-direction: column;
        gap: var(--space-md);
      }
      .player-card header {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }
      .muted {
        color: var(--text-muted);
      }
      .playback-frame {
        width: 100%;
        border-radius: 0.9rem;
        border: 1px solid var(--border-subtle);
        background: #000;
        min-height: 260px;
      }
      .meta-list {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        color: var(--text-muted);
        font-size: 0.95rem;
      }
      .chunk-summary {
        font-size: 0.85rem;
        color: var(--text-muted);
      }
      .error {
        color: var(--danger);
        font-weight: 600;
      }
      a.link {
        color: var(--accent);
        text-decoration: none;
      }
      a.link:hover,
      a.link:focus-visible {
        text-decoration: underline;
      }
    </style>
  </head>
  <body>
    <div class="player-card" role="document">
      <header>
        <h1 id="recording-title">Loading recording…</h1>
        <div class="meta-list" id="recording-meta"></div>
        <div class="chunk-summary" id="chunk-summary"></div>
        <p class="muted" id="status-text">Preparing playback…</p>
      </header>
      <img id="playback-frame" class="playback-frame" alt="Recording playback" hidden />
      <p class="muted">
        <a class="link" href="/surveillance">Back to surveillance</a>
      </p>
    </div>
    <script>
      const params = new URLSearchParams(window.location.search);
      const recordingName = params.get("name");
      const title = document.getElementById("recording-title");
      const metaList = document.getElementById("recording-meta");
      const chunkSummary = document.getElementById("chunk-summary");
      const statusText = document.getElementById("status-text");
      const playbackFrame = document.getElementById("playback-frame");
      let playbackTimer = null;

      function setStatus(message, tone = "info") {
        if (tone === "error") {
          statusText.classList.add("error");
        } else {
          statusText.classList.remove("error");
        }
        statusText.textContent = message;
      }

      function formatBytes(bytes) {
        if (typeof bytes !== "number" || !Number.isFinite(bytes) || bytes < 0) {
          return null;
        }
        const units = ["B", "KB", "MB", "GB", "TB"];
        let value = bytes;
        let index = 0;
        while (value >= 1024 && index < units.length - 1) {
          value /= 1024;
          index += 1;
        }
        const display = value >= 10 || index === 0 ? value.toFixed(0) : value.toFixed(1);
        return `${display.replace(/\.0$/, "")} ${units[index]}`;
      }

      function renderMeta(data) {
        metaList.innerHTML = "";
        if (chunkSummary) {
          chunkSummary.textContent = "";
        }
        const entries = [];
        if (data.started_at) {
          entries.push(`Started: ${new Date(data.started_at).toLocaleString()}`);
        }
        if (data.ended_at) {
          entries.push(`Finished: ${new Date(data.ended_at).toLocaleString()}`);
        }
        if (typeof data.duration_seconds === "number") {
          entries.push(`Duration: ${data.duration_seconds.toFixed(1)}s`);
        }
        if (typeof data.frame_count === "number") {
          entries.push(`Frames: ${data.frame_count}`);
        }
        if (typeof data.fps === "number") {
          entries.push(`Recorded at ${data.fps} fps`);
        }
        if (typeof data.size_bytes === "number") {
          const sizeLabel = formatBytes(data.size_bytes);
          if (sizeLabel) {
            entries.push(`Size: ${sizeLabel}`);
          }
        }
        if (!entries.length) {
          metaList.textContent = "No metadata available.";
          return;
        }
        entries.forEach((text) => {
          const span = document.createElement("span");
          span.textContent = text;
          metaList.appendChild(span);
        });
        if (Array.isArray(data.chunks) && data.chunks.length && chunkSummary) {
          const details = data.chunks
            .map((chunk, idx) => {
              if (!chunk || typeof chunk !== "object") {
                return null;
              }
              const label = idx + 1;
              const sizeLabel = formatBytes(chunk.size_bytes);
              return sizeLabel ? `Chunk ${label} — ${sizeLabel}` : null;
            })
            .filter(Boolean);
          if (details.length) {
            chunkSummary.textContent = details.join(" • ");
          }
        }
      }

      function playFrames(frames, fps) {
        if (!playbackFrame) {
          return;
        }
        if (!Array.isArray(frames) || frames.length === 0) {
          setStatus("Recording does not contain any frames.", "error");
          playbackFrame.hidden = true;
          return;
        }
        const playable = frames
          .map((frame) => ({
            jpeg: frame && typeof frame.jpeg === "string" ? frame.jpeg : null,
            timestamp:
              frame && typeof frame.timestamp === "number" && Number.isFinite(frame.timestamp)
                ? Number(frame.timestamp)
                : null,
          }))
          .filter((frame) => typeof frame.jpeg === "string" && frame.jpeg.length > 0);
        if (!playable.length) {
          setStatus("Recording frames are invalid.", "error");
          playbackFrame.hidden = true;
          return;
        }

        const fallbackInterval = fps && fps > 0 ? Math.max(40, Math.round(1000 / fps)) : 200;
        const firstTimestamp = playable.find((frame) => frame.timestamp !== null)?.timestamp ?? null;
        let lastTimestamp = null;
        for (let idx = playable.length - 1; idx >= 0; idx -= 1) {
          const candidate = playable[idx].timestamp;
          if (candidate !== null) {
            lastTimestamp = candidate;
            break;
          }
        }
        let cycleDurationMs = fallbackInterval * playable.length;
        if (
          firstTimestamp !== null &&
          lastTimestamp !== null &&
          lastTimestamp > firstTimestamp &&
          Number.isFinite(lastTimestamp) &&
          Number.isFinite(firstTimestamp)
        ) {
          cycleDurationMs = Math.max(
            40,
            Math.round((lastTimestamp - firstTimestamp) * 1000),
          );
        }
        if (!Number.isFinite(cycleDurationMs) || cycleDurationMs <= 0) {
          cycleDurationMs = fallbackInterval * playable.length;
        }

        const intervals = playable.map((frame, idx) => {
          const nextFrame = playable[(idx + 1) % playable.length];
          const currentTs = frame.timestamp;
          const nextTs = nextFrame.timestamp;
          let delay = fallbackInterval;
          if (
            currentTs !== null &&
            nextTs !== null &&
            Number.isFinite(currentTs) &&
            Number.isFinite(nextTs) &&
            nextTs >= currentTs
          ) {
            delay = Math.max(40, Math.round((nextTs - currentTs) * 1000));
          } else if (
            currentTs !== null &&
            Number.isFinite(currentTs) &&
            firstTimestamp !== null &&
            Number.isFinite(firstTimestamp) &&
            cycleDurationMs > 0
          ) {
            const elapsed = Math.max(0, Math.round((currentTs - firstTimestamp) * 1000));
            const remaining = cycleDurationMs - elapsed;
            if (remaining > 0 && Number.isFinite(remaining)) {
              delay = Math.max(40, remaining);
            }
          }
          if (!Number.isFinite(delay) || delay <= 0) {
            delay = fallbackInterval;
          }
          return delay;
        });

        let index = 0;
        playbackFrame.hidden = false;

        const advance = () => {
          const frame = playable[index];
          playbackFrame.src = `data:image/jpeg;base64,${frame.jpeg}`;
          const delay = intervals[index] ?? fallbackInterval;
          index = (index + 1) % playable.length;
          playbackTimer = window.setTimeout(advance, delay);
        };

        advance();
      }

      async function loadRecording() {
        if (!recordingName) {
          setStatus("Missing recording identifier.", "error");
          return;
        }
        title.textContent = recordingName;
        try {
          const response = await fetch(
            `/api/surveillance/recordings/${encodeURIComponent(recordingName)}`,
            { cache: "no-store" },
          );
          if (!response.ok) {
            throw new Error(`Request failed with ${response.status}`);
          }
          const payload = await response.json();
          if (!payload || typeof payload !== "object") {
            throw new Error("Invalid recording payload");
          }
          renderMeta(payload);
          setStatus("Playing recording…");
          playFrames(payload.frames, payload.fps);
        } catch (error) {
          console.error("Failed to load recording", error);
          setStatus("Unable to load recording", "error");
        }
      }

      window.addEventListener("beforeunload", () => {
        if (playbackTimer) {
          window.clearTimeout(playbackTimer);
        }
      });

      loadRecording();
    </script>
  </body>
</html>
