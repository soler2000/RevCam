<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Surveillance Recording Playback</title>
    <link rel="icon" type="image/svg+xml" href="images/favicon.svg" />
    <style>
      :root {
        color-scheme: dark;
        --font-family: "Inter", "Manrope", "Segoe UI", system-ui, -apple-system,
          BlinkMacSystemFont, sans-serif;
        --surface-0: rgba(14, 16, 22, 0.9);
        --surface-1: rgba(26, 28, 36, 0.85);
        --border-subtle: rgba(255, 255, 255, 0.12);
        --text-primary: #f5f7fb;
        --text-muted: rgba(245, 247, 250, 0.7);
        --accent: #0a84ff;
        --accent-soft: rgba(10, 132, 255, 0.18);
        --danger: #ff453a;
        --radius-lg: 1.2rem;
        --radius-sm: 0.75rem;
        --space-md: 1rem;
        --space-lg: 1.6rem;
        --page-gradient: radial-gradient(
          120% 140% at top,
          #1b1e26 0%,
          #0b0d13 60%,
          #050609 100%
        );
      }
      body {
        margin: 0;
        background: var(--page-gradient);
        font-family: var(--font-family);
        color: var(--text-primary);
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: var(--space-lg);
      }
      .player-card {
        width: min(960px, 100%);
        background: var(--surface-1);
        border-radius: var(--radius-lg);
        border: 1px solid var(--border-subtle);
        box-shadow: 0 24px 48px rgba(0, 0, 0, 0.45);
        padding: var(--space-lg);
        display: flex;
        flex-direction: column;
        gap: var(--space-md);
      }
      header {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }
      .muted {
        color: var(--text-muted);
      }
      .playback-frame {
        width: 100%;
        aspect-ratio: 16 / 9;
        border-radius: 0.9rem;
        border: 1px solid var(--border-subtle);
        background: #000;
      }
      .meta-list {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        color: var(--text-muted);
        font-size: 0.95rem;
      }
      .meta-pill {
        padding: 0.35rem 0.7rem;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid var(--border-subtle);
      }
      .status {
        min-height: 1.25rem;
      }
      .status.error {
        color: var(--danger);
        font-weight: 600;
      }
      .video-actions {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }
      .chunk-navigation {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
      }
      .chunk-indicator {
        flex: 1;
        text-align: center;
        color: var(--text-muted);
      }
      button,
      a.link {
        font: inherit;
        border: 1px solid var(--border-subtle);
        background: rgba(255, 255, 255, 0.04);
        color: var(--text-primary);
        padding: 0.45rem 0.85rem;
        border-radius: 999px;
        cursor: pointer;
        transition: background 0.15s ease, border-color 0.15s ease;
        text-decoration: none;
      }
      button:hover,
      button:focus-visible,
      a.link:hover,
      a.link:focus-visible {
        background: var(--accent-soft);
        border-color: rgba(10, 132, 255, 0.55);
        outline: none;
      }
      button:disabled {
        cursor: not-allowed;
        opacity: 0.55;
      }
      .chunk-list {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }
      .chunk-pill {
        padding: 0.35rem 0.6rem;
        border-radius: var(--radius-sm);
        border: 1px solid var(--border-subtle);
        background: rgba(255, 255, 255, 0.04);
        font-size: 0.85rem;
        color: var(--text-muted);
        cursor: pointer;
        transition: background 0.15s ease, border-color 0.15s ease, color 0.15s ease;
      }
      .chunk-pill:hover,
      .chunk-pill:focus-visible {
        background: var(--accent-soft);
        border-color: rgba(10, 132, 255, 0.55);
        color: var(--text-primary);
        outline: none;
      }
      .chunk-pill.active {
        background: rgba(10, 132, 255, 0.25);
        border-color: rgba(10, 132, 255, 0.8);
        color: var(--text-primary);
      }
      .footer-links {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
        align-items: center;
      }
    </style>
  </head>
  <body>
    <div class="player-card" role="document">
      <header>
        <h1 id="recording-title">Loading recording…</h1>
        <div class="meta-list" id="recording-meta"></div>
        <p id="status-text" class="status muted">Preparing playback…</p>
      </header>
      <video
        id="playback-video"
        class="playback-frame"
        controls
        preload="metadata"
        hidden
      >
        <source id="playback-source" />
        <p>Your browser does not support HTML5 video playback.</p>
      </video>
      <img
        id="playback-image"
        class="playback-frame"
        alt="Surveillance recording chunk"
        hidden
      />
      <div class="video-actions" id="video-actions" hidden>
        <div class="chunk-navigation">
          <button type="button" id="prev-chunk" aria-label="Previous chunk">⏮</button>
          <div id="chunk-indicator" class="chunk-indicator">Chunk 0 of 0</div>
          <button type="button" id="next-chunk" aria-label="Next chunk">⏭</button>
        </div>
        <div class="chunk-list" id="chunk-list" aria-live="polite"></div>
      </div>
      <div class="footer-links muted">
        <a class="link" id="download-link" href="#" download>Download recording</a>
        <span aria-hidden="true">·</span>
        <a class="link" href="/surveillance">Back to surveillance</a>
      </div>
    </div>
    <script>
      const params = new URLSearchParams(window.location.search);
      const recordingName = params.get("name");
      const title = document.getElementById("recording-title");
      const metaList = document.getElementById("recording-meta");
      const statusText = document.getElementById("status-text");
      const video = document.getElementById("playback-video");
      const source = document.getElementById("playback-source");
      const image = document.getElementById("playback-image");
      const actions = document.getElementById("video-actions");
      const prevChunkButton = document.getElementById("prev-chunk");
      const nextChunkButton = document.getElementById("next-chunk");
      const chunkIndicator = document.getElementById("chunk-indicator");
      const chunkList = document.getElementById("chunk-list");
      const downloadLink = document.getElementById("download-link");

      let chunks = [];
      let currentChunkIndex = 0;
      let recordingMetadata = null;
      let currentObjectUrl = null;
      let activeChunkRequest = 0;
      let lastChunkUrl = null;
      let lastChunkAutoplay = false;
      let lastChunkMediaType = "video/mp4";

      function revokeObjectUrl() {
        if (currentObjectUrl) {
          URL.revokeObjectURL(currentObjectUrl);
          currentObjectUrl = null;
        }
      }

      function setStatus(message, tone = "info") {
        statusText.textContent = message;
        if (tone === "error") {
          statusText.classList.add("error");
        } else {
          statusText.classList.remove("error");
        }
      }

      function formatBytes(bytes) {
        if (typeof bytes !== "number" || !Number.isFinite(bytes) || bytes <= 0) {
          return null;
        }
        const units = ["B", "KB", "MB", "GB", "TB"];
        let value = bytes;
        let unit = 0;
        while (value >= 1024 && unit < units.length - 1) {
          value /= 1024;
          unit += 1;
        }
        const display = value >= 10 || unit === 0 ? value.toFixed(0) : value.toFixed(1);
        return `${display.replace(/\.0$/, "")} ${units[unit]}`;
      }

      function formatDuration(seconds) {
        if (typeof seconds !== "number" || !Number.isFinite(seconds) || seconds < 0) {
          return "0:00";
        }
        const totalSeconds = Math.round(seconds);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const secs = totalSeconds % 60;
        const pad = (value) => value.toString().padStart(2, "0");
        if (hours > 0) {
          return `${hours}:${pad(minutes)}:${pad(secs)}`;
        }
        return `${minutes}:${pad(secs)}`;
      }

      function updateMetaDisplay(recording) {
        const items = [];
        if (recording.duration_seconds) {
          items.push(`Duration ${formatDuration(recording.duration_seconds)}`);
        }
        if (recording.fps) {
          items.push(`${recording.fps} fps`);
        }
        if (recording.frame_count) {
          items.push(`${recording.frame_count} frames`);
        }
        if (recording.chunk_count) {
          items.push(`${recording.chunk_count} chunk${recording.chunk_count === 1 ? "" : "s"}`);
        }
        if (recording.size_bytes) {
          const display = formatBytes(recording.size_bytes);
          if (display) {
            items.push(`Size ${display}`);
          }
        }
        if (recording.started_at) {
          items.push(new Date(recording.started_at).toLocaleString());
        }
        metaList.innerHTML = items
          .map((text) => `<span class="meta-pill">${text}</span>`)
          .join("");
      }

      function updateChunkUI() {
        if (!chunks.length) {
          actions.hidden = true;
          return;
        }
        const total = chunks.length;
        const current = currentChunkIndex + 1;
        chunkIndicator.textContent = `Chunk ${current} of ${total}`;
        prevChunkButton.disabled = currentChunkIndex === 0;
        nextChunkButton.disabled = currentChunkIndex >= total - 1;
        chunkList.innerHTML = "";
        chunks.forEach((chunk, index) => {
          const button = document.createElement("button");
          button.type = "button";
          button.className = "chunk-pill";
          if (index === currentChunkIndex) {
            button.classList.add("active");
          }
          const duration = formatDuration(chunk.duration_seconds ?? 0);
          const sizeDisplay = formatBytes(chunk.size_bytes);
          const offset =
            typeof chunk.start_offset_seconds === "number"
              ? formatDuration(chunk.start_offset_seconds)
              : null;
          const parts = [`#${index + 1}`, duration];
          if (offset) {
            parts.push(`@${offset}`);
          }
          if (sizeDisplay) {
            parts.push(sizeDisplay);
          }
          if (chunk.codec) {
            parts.push(String(chunk.codec).toUpperCase());
          }
          button.textContent = parts.join(" · ");
          button.addEventListener("click", () => loadChunk(index, true));
          chunkList.appendChild(button);
        });
        actions.hidden = false;
      }

      function buildChunkUrl(index) {
        const chunkNumber = index + 1;
        const encodedName = encodeURIComponent(recordingName);
        return `/api/surveillance/recordings/${encodedName}/chunks/${chunkNumber}`;
      }

      function resetMediaElements() {
        if (video) {
          video.pause();
          video.hidden = true;
          video.removeAttribute("src");
          if (source) {
            source.src = "";
            source.type = "";
          }
          delete video.dataset.loadStrategy;
          video.dataset.mediaType = "";
          video.dataset.chunkIndex = "";
        }
        if (image) {
          image.hidden = true;
          image.src = "";
        }
        revokeObjectUrl();
      }

      function useVideoSource(url, mediaType, autoplay, strategy) {
        if (!video) {
          return;
        }
        if (strategy === "direct") {
          revokeObjectUrl();
          currentObjectUrl = null;
        }
        if (source) {
          source.src = url;
          source.type = mediaType;
        }
        video.src = url;
        video.hidden = false;
        video.dataset.mediaType = mediaType;
        video.dataset.chunkIndex = String(currentChunkIndex + 1);
        video.dataset.loadStrategy = strategy;
        video.load();
        if (autoplay) {
          const playPromise = video.play();
          if (playPromise && typeof playPromise.catch === "function") {
            playPromise.catch(() => {
              /* autoplay prevented */
            });
          }
        }
      }

      function attemptDirectFallback(index, url, mediaType, autoplay) {
        if (!url) {
          return false;
        }
        useVideoSource(url, mediaType, autoplay, "direct");
        setStatus(`Retrying chunk ${index + 1} via direct stream…`);
        return true;
      }

      async function loadChunk(index, autoplay = false) {
        if (index < 0 || index >= chunks.length) {
          return;
        }
        currentChunkIndex = index;
        updateChunkUI();
        const chunk = chunks[index] ?? {};
        const chunkUrl = buildChunkUrl(index);
        const mediaType =
          typeof chunk.media_type === "string" && chunk.media_type.trim()
            ? chunk.media_type
            : "video/mp4";
        resetMediaElements();
        const requestId = ++activeChunkRequest;
        const cacheBustedUrl = `${chunkUrl}?v=${Date.now()}`;
        lastChunkUrl = cacheBustedUrl;
        lastChunkAutoplay = Boolean(autoplay);
        lastChunkMediaType = mediaType;
        setStatus(`Loading chunk ${index + 1} of ${chunks.length}…`);
        const isMultipart = mediaType
          .toLowerCase()
          .startsWith("multipart/x-mixed-replace");
        if (isMultipart && image) {
          image.src = cacheBustedUrl;
          image.hidden = false;
          video.dataset.mediaType = mediaType;
          video.dataset.chunkIndex = String(index + 1);
          if (requestId === activeChunkRequest) {
            setStatus(`Streaming MJPEG chunk ${index + 1}`);
          }
          return;
        } else {
          try {
            const response = await fetch(cacheBustedUrl, { cache: "no-store" });
            if (requestId !== activeChunkRequest) {
              return;
            }
            if (!response.ok) {
              throw new Error(
                `Failed to fetch chunk ${index + 1}: ${response.status}`
              );
            }
            const blob = await response.blob();
            if (requestId !== activeChunkRequest) {
              return;
            }
            if (!blob || blob.size === 0) {
              throw new Error("Chunk payload is empty");
            }
            revokeObjectUrl();
            currentObjectUrl = URL.createObjectURL(blob);
            useVideoSource(currentObjectUrl, mediaType, autoplay, "blob");
            setStatus(`Ready: chunk ${index + 1} of ${chunks.length}`);
          } catch (error) {
            console.error(error);
            if (requestId === activeChunkRequest) {
              const retried = attemptDirectFallback(
                index,
                cacheBustedUrl,
                mediaType,
                autoplay
              );
              if (!retried) {
                setStatus("Unable to load video chunk", "error");
              }
            }
          }
        }
      }

      async function initialise() {
        if (!recordingName) {
          setStatus("Recording name missing", "error");
          return;
        }
        try {
          const encodedName = encodeURIComponent(recordingName);
          const response = await fetch(
            `/api/surveillance/recordings/${encodedName}?include_frames=false`
          );
          if (!response.ok) {
            throw new Error(`Request failed with status ${response.status}`);
          }
          const payload = await response.json();
          const recording = payload.recording ?? payload;
          if (!recording || typeof recording !== "object") {
            throw new Error("Invalid recording payload");
          }
          recordingMetadata = recording;
          title.textContent = recording.name || recordingName;
          updateMetaDisplay(recording);
          const chunkArray = Array.isArray(recording.chunks) ? recording.chunks : [];
          chunks = chunkArray.filter((chunk) => chunk && typeof chunk === "object");
          downloadLink.href = `/api/surveillance/recordings/${encodeURIComponent(
            recordingName
          )}/download`;
          if (recording.thumbnail) {
            video.poster = `data:image/jpeg;base64,${recording.thumbnail}`;
          }
          if (!chunks.length) {
            setStatus("This recording does not contain any video chunks", "error");
            video.hidden = true;
            actions.hidden = true;
            return;
          }
          setStatus(`Loaded ${chunks.length} chunk${chunks.length === 1 ? "" : "s"}.`);
          if (!chunks.some((chunk) => {
              return (
                typeof chunk.media_type === "string" &&
                chunk.media_type.toLowerCase().startsWith("multipart/x-mixed-replace")
              );
            })) {
            video.hidden = false;
          }
          loadChunk(0, false);
        } catch (error) {
          console.error(error);
          setStatus("Unable to load recording", "error");
          video.hidden = true;
          actions.hidden = true;
        }
      }

      prevChunkButton.addEventListener("click", () => {
        if (currentChunkIndex > 0) {
          loadChunk(currentChunkIndex - 1, true);
        }
      });
      nextChunkButton.addEventListener("click", () => {
        if (currentChunkIndex < chunks.length - 1) {
          loadChunk(currentChunkIndex + 1, true);
        }
      });
      video.addEventListener("loadeddata", () => {
        const datasetIndex = Number(video.dataset.chunkIndex || "0");
        if (datasetIndex === currentChunkIndex + 1 && chunks.length) {
          setStatus(`Ready: chunk ${datasetIndex} of ${chunks.length}`);
        }
      });
      video.addEventListener("error", () => {
        const datasetIndex = Number(video.dataset.chunkIndex || "0");
        const strategy = video.dataset.loadStrategy || "";
        if (datasetIndex === currentChunkIndex + 1) {
          if (
            strategy === "blob" &&
            lastChunkUrl &&
            attemptDirectFallback(
              currentChunkIndex,
              lastChunkUrl,
              lastChunkMediaType,
              lastChunkAutoplay
            )
          ) {
            return;
          }
          setStatus("Unable to load video chunk", "error");
        }
      });
      video.addEventListener("ended", () => {
        if (currentChunkIndex < chunks.length - 1) {
          loadChunk(currentChunkIndex + 1, true);
        }
      });
      window.addEventListener("beforeunload", revokeObjectUrl);

      initialise();
    </script>
  </body>
</html>
