<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Surveillance settings · RevCam</title>
    <style>
      :root {
        color-scheme: dark light;
        --background: #0f111a;
        --foreground: #f5f7ff;
        --muted: #9aa4c4;
        --accent: #4aa8ff;
        --accent-strong: #1d7ef0;
        --card-bg: rgba(18, 22, 33, 0.9);
        --card-border: rgba(255, 255, 255, 0.08);
        --danger: #ff4d61;
        --success: #38d996;
        --font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      }

      body {
        margin: 0;
        background: radial-gradient(circle at 10% 10%, rgba(74, 168, 255, 0.18), transparent 60%),
          radial-gradient(circle at 80% 0%, rgba(56, 217, 150, 0.12), transparent 65%),
          var(--background);
        color: var(--foreground);
        font-family: var(--font-family);
        min-height: 100vh;
      }

      a {
        color: var(--accent);
      }

      header {
        padding: 1.5rem clamp(1rem, 3vw, 2.5rem);
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        backdrop-filter: blur(12px);
        background: rgba(12, 16, 25, 0.82);
        position: sticky;
        top: 0;
        z-index: 10;
      }

      header h1 {
        margin: 0;
        font-size: clamp(1.9rem, 3vw, 2.6rem);
        letter-spacing: -0.03em;
      }

      .layout {
        max-width: 980px;
        margin: 2.5rem auto 4rem;
        padding: 0 clamp(1rem, 3vw, 2.5rem);
        display: grid;
        gap: 1.75rem;
      }

      .card {
        background: var(--card-bg);
        border: 1px solid var(--card-border);
        border-radius: 20px;
        padding: clamp(1.4rem, 3vw, 2rem);
        box-shadow: 0 24px 55px rgba(0, 0, 0, 0.38);
      }

      .card h2 {
        margin-top: 0;
        margin-bottom: 0.75rem;
        letter-spacing: -0.01em;
      }

      .intro {
        font-size: 1rem;
        color: var(--muted);
        margin-bottom: 1rem;
      }

      form {
        display: grid;
        gap: 1.75rem;
      }

      fieldset {
        border: 0;
        padding: 0;
        margin: 0;
        display: grid;
        gap: 0.9rem;
      }

      legend {
        font-size: 1.1rem;
        font-weight: 600;
        color: var(--foreground);
      }

      .radio-group {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 0.75rem;
      }

      .radio-tile {
        border-radius: 16px;
        padding: 1rem;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(255, 255, 255, 0.04);
        display: grid;
        gap: 0.35rem;
        cursor: pointer;
        transition: border 0.2s ease, background 0.2s ease;
      }

      .radio-tile:hover {
        border-color: rgba(255, 255, 255, 0.22);
      }

      .radio-tile input {
        appearance: none;
        width: 1.1rem;
        height: 1.1rem;
        border-radius: 50%;
        border: 2px solid rgba(255, 255, 255, 0.4);
        display: inline-block;
        margin-right: 0.5rem;
        vertical-align: middle;
        transition: border 0.2s ease, background 0.2s ease;
      }

      .radio-tile input:checked {
        border-color: transparent;
        background: radial-gradient(circle at center, var(--accent) 0%, var(--accent-strong) 70%);
      }

      .radio-tile span {
        font-weight: 600;
      }

      .radio-description {
        color: var(--muted);
        font-size: 0.9rem;
        margin: 0;
      }

      .input-grid {
        display: grid;
        gap: 1.25rem;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      }

      label {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        font-size: 0.95rem;
      }

      label span {
        font-weight: 600;
      }

      input[type="number"],
      select {
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.14);
        border-radius: 12px;
        padding: 0.65rem 0.75rem;
        color: var(--foreground);
        font: inherit;
        min-height: 2.6rem;
      }

      input[type="number"]:focus,
      select:focus {
        outline: 2px solid rgba(74, 168, 255, 0.6);
        outline-offset: 2px;
      }

      .checkbox-row {
        display: flex;
        align-items: center;
        gap: 0.6rem;
      }

      .checkbox-row input {
        width: 1.1rem;
        height: 1.1rem;
        accent-color: var(--accent);
      }

      .hint {
        color: var(--muted);
        font-size: 0.85rem;
        margin: 0;
      }

      .summary {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 14px;
        padding: 1rem 1.25rem;
        display: grid;
        gap: 0.5rem;
        font-size: 0.95rem;
      }

      .actions {
        display: flex;
        gap: 1rem;
        flex-wrap: wrap;
        align-items: center;
      }

      button[type="submit"] {
        background: linear-gradient(135deg, var(--accent) 0%, var(--accent-strong) 100%);
        border: 0;
        border-radius: 14px;
        padding: 0.85rem 1.8rem;
        font: inherit;
        color: #fff;
        cursor: pointer;
        box-shadow: 0 16px 40px rgba(29, 126, 240, 0.35);
        transition: transform 0.2s ease;
      }

      button[type="submit"]:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
      }

      button[type="submit"]:hover:not(:disabled) {
        transform: translateY(-1px);
      }

      .status-text {
        font-size: 0.9rem;
        color: var(--muted);
      }

      .status-text.is-error {
        color: var(--danger);
      }

      footer {
        margin: 2.5rem auto 3rem;
        max-width: 980px;
        padding: 0 clamp(1rem, 3vw, 2.5rem);
        display: flex;
        justify-content: space-between;
        font-size: 0.85rem;
        color: var(--muted);
      }

      @media (max-width: 720px) {
        .input-grid {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Surveillance settings</h1>
      <p class="intro">
        Configure how RevCam captures surveillance clips, manages motion detection,
        and protects available storage. Fine-tuned defaults help keep file sizes in
        check while remaining easy to override when you need more detail.
      </p>
    </header>
    <main class="layout">
      <form id="surveillance-settings-form" novalidate>
        <section class="card">
          <h2>Capture profile</h2>
          <fieldset>
            <legend>Select a capture style</legend>
            <div class="radio-group">
              <label class="radio-tile">
                <input type="radio" name="profile" value="standard" checked />
                <span>Standard presets</span>
                <p class="radio-description">
                  Balanced combinations of frame rate and JPEG quality designed to keep
                  recording sizes modest.
                </p>
                <div>
                  <select id="preset-select">
                    <option value="balanced">Balanced coverage</option>
                    <option value="detail">High detail</option>
                    <option value="endurance">Extended endurance</option>
                  </select>
                </div>
              </label>
              <label class="radio-tile">
                <input type="radio" name="profile" value="expert" />
                <span>Expert tuning</span>
                <p class="radio-description">
                  Directly control frame rate and JPEG quality when you require a
                  bespoke capture workflow.
                </p>
                <div class="input-grid" id="expert-inputs" hidden>
                  <label>
                    <span>Frame rate (fps)</span>
                    <input type="number" id="expert-fps" min="1" max="30" step="1" value="6" />
                    <p class="hint">Lower frame rates dramatically reduce file sizes.</p>
                  </label>
                  <label>
                    <span>JPEG quality</span>
                    <input type="number" id="expert-quality" min="30" max="100" step="1" value="65" />
                    <p class="hint">Values between 55 and 75 keep clips lightweight.</p>
                  </label>
                </div>
              </label>
            </div>
          </fieldset>
        </section>

        <section class="card">
          <h2>Clip management</h2>
          <div class="input-grid">
            <label>
              <span>Clip length (seconds)</span>
              <input type="number" id="chunk-duration" min="0" step="1" />
              <p class="hint">Use 0 to allow uninterrupted recording.</p>
            </label>
            <label>
              <span>Maximum clip size (MB)</span>
              <input type="number" id="max-clip" min="0" step="1" />
              <p class="hint">Recordings rotate when they reach this size. Use 0 for no limit.</p>
            </label>
          </div>
          <div class="summary" id="clip-summary"></div>
        </section>

        <section class="card">
          <h2>Motion detection</h2>
          <div class="checkbox-row">
            <input type="checkbox" id="motion-enabled" />
            <label for="motion-enabled">Enable motion-triggered recording</label>
          </div>
          <div class="input-grid">
            <label>
              <span>Motion sensitivity</span>
              <input type="number" id="motion-sensitivity" min="1" max="100" step="1" />
              <p class="hint">Higher values trigger recording more easily.</p>
            </label>
            <label>
              <span>Frame decimation</span>
              <input type="number" id="motion-decimation" min="1" max="30" step="1" />
              <p class="hint">Process every Nth frame to reduce CPU usage.</p>
            </label>
            <label>
              <span>Post-event duration (seconds)</span>
              <input type="number" id="motion-post" min="0" max="60" step="0.5" />
              <p class="hint">Continue recording after motion stops.</p>
            </label>
          </div>
        </section>

        <section class="card">
          <h2>Overlays & automation</h2>
          <div class="checkbox-row">
            <input type="checkbox" id="overlays-enabled" />
            <label for="overlays-enabled">Include camera overlays in surveillance clips</label>
          </div>
          <div class="checkbox-row">
            <input type="checkbox" id="remember-recording" />
            <label for="remember-recording">Resume recording automatically when returning to surveillance mode</label>
          </div>
          <div class="input-grid">
            <label>
              <span>Auto purge after (days)</span>
              <input type="number" id="auto-purge" min="0" step="1" />
              <p class="hint">Set to 0 to keep clips until storage fills up.</p>
            </label>
            <label>
              <span>Storage threshold (%)</span>
              <input type="number" id="storage-threshold" min="1" max="90" step="0.5" />
              <p class="hint">Recording pauses when free space drops below this value.</p>
            </label>
          </div>
        </section>

        <section class="card">
          <h2>Save changes</h2>
          <p class="status-text" id="status-text">Loading settings…</p>
          <div class="actions">
            <button type="submit">Save surveillance settings</button>
            <a href="/surveillance" class="status-text">Back to surveillance dashboard</a>
          </div>
        </section>
      </form>
    </main>
    <footer>
      <span>Need a quick view? Visit the <a href="/surveillance">surveillance dashboard</a>.</span>
      <span id="summary-details"></span>
    </footer>

    <script>
      const form = document.getElementById("surveillance-settings-form");
      const presetSelect = document.getElementById("preset-select");
      const profileField = form.elements.namedItem("profile");
      const profileRadios =
        profileField && typeof profileField.length === "number"
          ? Array.from(profileField)
          : [profileField].filter(Boolean);
      const expertInputs = document.getElementById("expert-inputs");
      const expertFps = document.getElementById("expert-fps");
      const expertQuality = document.getElementById("expert-quality");
      const chunkDuration = document.getElementById("chunk-duration");
      const maxClip = document.getElementById("max-clip");
      const clipSummary = document.getElementById("clip-summary");
      const motionEnabled = document.getElementById("motion-enabled");
      const motionSensitivity = document.getElementById("motion-sensitivity");
      const motionDecimation = document.getElementById("motion-decimation");
      const motionPost = document.getElementById("motion-post");
      const overlaysEnabled = document.getElementById("overlays-enabled");
      const rememberRecording = document.getElementById("remember-recording");
      const autoPurge = document.getElementById("auto-purge");
      const storageThreshold = document.getElementById("storage-threshold");
      const statusText = document.getElementById("status-text");
      const summaryDetails = document.getElementById("summary-details");

      let presets = {
        balanced: { label: "Balanced coverage", fps: 5, jpeg_quality: 65 },
        detail: { label: "High detail", fps: 8, jpeg_quality: 80 },
        endurance: { label: "Extended endurance", fps: 3, jpeg_quality: 55 },
      };

      function currentProfile() {
        const active = profileRadios.find((radio) => radio.checked);
        return active ? active.value : "standard";
      }

      function formatBytes(bytes) {
        if (!Number.isFinite(bytes) || bytes <= 0) {
          return "unlimited";
        }
        const units = ["B", "KB", "MB", "GB"];
        const exponent = Math.min(units.length - 1, Math.floor(Math.log(bytes) / Math.log(1024)));
        const value = bytes / Math.pow(1024, exponent);
        return `${value.toFixed(value >= 10 ? 0 : 1)} ${units[exponent]}`;
      }

      function updateExpertVisibility() {
        const isExpert = currentProfile() === "expert";
        expertInputs.hidden = !isExpert;
      }

      function updateSummary(settings) {
        const profile = currentProfile();
        let fps;
        let quality;
        if (profile === "expert") {
          fps = Number.parseInt(expertFps.value, 10) || settings?.expert_fps || 6;
          quality = Number.parseInt(expertQuality.value, 10) || settings?.expert_jpeg_quality || 65;
        } else {
          const preset = presets[presetSelect.value] || presets.balanced;
          fps = preset.fps;
          quality = preset.jpeg_quality;
        }
        const durationSeconds = Number.parseInt(chunkDuration.value, 10) || 0;
        const clipLimitMB = Number.parseInt(maxClip.value, 10) || 0;
        const clipBytes = clipLimitMB > 0 ? clipLimitMB * 1024 * 1024 : NaN;
        const durationLabel = durationSeconds > 0 ? `${durationSeconds}s` : "unlimited";
        clipSummary.textContent = `Effective profile: ${fps} fps, JPEG ${quality}. Clips run for ${durationLabel} with a maximum size of ${formatBytes(clipBytes)}.`;
        summaryDetails.textContent = `Profile ${profile} • ${fps} fps • JPEG ${quality}`;
      }

      profileRadios.forEach((radio) => {
        radio.addEventListener("change", () => {
          updateExpertVisibility();
          updateSummary();
        });
      });
      presetSelect.addEventListener("change", () => updateSummary());
      [expertFps, expertQuality, chunkDuration, maxClip].forEach((input) => {
        input.addEventListener("input", () => updateSummary());
      });

      async function loadSettings() {
        try {
          statusText.textContent = "Loading settings…";
          const response = await fetch("/api/surveillance/settings", { cache: "no-store" });
          if (!response.ok) {
            throw new Error(`Request failed (${response.status})`);
          }
          const payload = await response.json();
          if (payload?.presets) {
            presets = {};
            presetSelect.innerHTML = "";
            payload.presets.forEach((preset) => {
              if (!preset?.name) {
                return;
              }
              presets[preset.name] = {
                label: preset.name,
                fps: preset.fps,
                jpeg_quality: preset.jpeg_quality,
              };
              const option = document.createElement("option");
              option.value = preset.name;
              option.textContent = preset.name.replace(/\b\w/g, (char) => char.toUpperCase());
              presetSelect.appendChild(option);
            });
          }
          applySettings(payload.settings);
          statusText.textContent = "Settings loaded";
        } catch (error) {
          console.error("Failed to load surveillance settings", error);
          statusText.textContent = error.message || "Unable to load surveillance settings.";
          statusText.classList.add("is-error");
        }
      }

      function applySettings(settings) {
        if (!settings || typeof settings !== "object") {
          return;
        }
        const profile = settings.profile === "expert" ? "expert" : "standard";
        profileRadios.forEach((radio) => {
          radio.checked = radio.value === profile;
        });
        presetSelect.value = settings.preset || "balanced";
        expertFps.value = settings.expert_fps ?? settings.fps ?? 6;
        expertQuality.value = settings.expert_jpeg_quality ?? settings.jpeg_quality ?? 65;
        chunkDuration.value = settings.chunk_duration_seconds ?? "";
        const clipMegabytes = settings.max_clip_megabytes ?? 0;
        maxClip.value = clipMegabytes || "";
        motionEnabled.checked = Boolean(settings.motion_detection_enabled);
        motionSensitivity.value = settings.motion_sensitivity ?? 50;
        motionDecimation.value = settings.motion_frame_decimation ?? 1;
        motionPost.value = settings.motion_post_event_seconds ?? 2;
        overlaysEnabled.checked = Boolean(settings.overlays_enabled);
        rememberRecording.checked = Boolean(settings.remember_recording_state);
        autoPurge.value = settings.auto_purge_days ?? "";
        storageThreshold.value = settings.storage_threshold_percent ?? 10;
        updateExpertVisibility();
        updateSummary(settings);
      }

      function normaliseInt(input, { min, max, fallback = null }) {
        const value = Number.parseInt(input.value, 10);
        if (!Number.isFinite(value)) {
          return fallback;
        }
        const clamped = Math.min(max, Math.max(min, value));
        return clamped;
      }

      form.addEventListener("submit", async (event) => {
        event.preventDefault();
        const profile = currentProfile();
        const payload = { profile };
        if (profile === "standard") {
          payload.preset = presetSelect.value || "balanced";
        } else {
          const fpsValue = normaliseInt(expertFps, { min: 1, max: 30, fallback: 6 });
          const qualityValue = normaliseInt(expertQuality, { min: 30, max: 100, fallback: 65 });
          payload.expert_fps = fpsValue;
          payload.expert_jpeg_quality = qualityValue;
        }
        const chunkSeconds = Number.parseInt(chunkDuration.value, 10);
        payload.chunk_duration_seconds = Number.isFinite(chunkSeconds) && chunkSeconds > 0 ? chunkSeconds : 0;
        const clipMegabytes = Number.parseInt(maxClip.value, 10);
        payload.max_clip_megabytes = Number.isFinite(clipMegabytes) && clipMegabytes > 0 ? clipMegabytes : 0;
        payload.overlays_enabled = overlaysEnabled.checked;
        payload.remember_recording_state = rememberRecording.checked;
        payload.motion_detection_enabled = motionEnabled.checked;
        payload.motion_sensitivity = normaliseInt(motionSensitivity, { min: 1, max: 100, fallback: 50 });
        payload.motion_frame_decimation = normaliseInt(motionDecimation, { min: 1, max: 30, fallback: 1 });
        const postSeconds = Number.parseFloat(motionPost.value);
        payload.motion_post_event_seconds = Number.isFinite(postSeconds) && postSeconds >= 0 && postSeconds <= 60 ? postSeconds : 0;
        const thresholdValue = Number.parseFloat(storageThreshold.value);
        if (!Number.isFinite(thresholdValue) || thresholdValue < 1 || thresholdValue > 90) {
          statusText.textContent = "Storage threshold must be between 1 and 90%.";
          statusText.classList.add("is-error");
          storageThreshold.focus();
          return;
        }
        payload.storage_threshold_percent = thresholdValue;
        const purgeValue = Number.parseInt(autoPurge.value, 10);
        payload.auto_purge_days = Number.isFinite(purgeValue) && purgeValue > 0 ? purgeValue : 0;

        statusText.textContent = "Saving settings…";
        statusText.classList.remove("is-error");
        form.querySelector("button[type='submit']").disabled = true;
        try {
          const response = await fetch("/api/surveillance/settings", {
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          if (!response.ok) {
            let detail = "Unable to save settings.";
            try {
              const body = await response.json();
              if (body?.detail) {
                detail = body.detail;
              }
            } catch (error) {
              /* ignore */
            }
            throw new Error(detail);
          }
          const result = await response.json();
          applySettings(result.settings);
          statusText.textContent = "Surveillance settings saved.";
        } catch (error) {
          console.error("Failed to save surveillance settings", error);
          statusText.textContent = error.message || "Unable to save surveillance settings.";
          statusText.classList.add("is-error");
        } finally {
          form.querySelector("button[type='submit']").disabled = false;
        }
      });

      loadSettings();
    </script>
  </body>
</html>
