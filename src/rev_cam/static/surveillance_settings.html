<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Surveillance settings</title>
    <link rel="icon" type="image/svg+xml" href="images/favicon.svg" />
    <style>
      :root {
        color-scheme: dark;
        --font-family: "Inter", "Manrope", "Segoe UI", system-ui, -apple-system,
          BlinkMacSystemFont, sans-serif;
        --surface-0: rgba(14, 16, 22, 0.92);
        --surface-1: rgba(24, 26, 34, 0.88);
        --surface-2: rgba(36, 38, 48, 0.82);
        --border-subtle: rgba(255, 255, 255, 0.14);
        --border-strong: rgba(255, 255, 255, 0.26);
        --text-primary: #f5f7fb;
        --text-muted: rgba(245, 247, 250, 0.72);
        --text-accent: #0a84ff;
        --danger: #ff453a;
        --success: #32d74b;
        --radius-lg: 1.2rem;
        --radius-md: 0.9rem;
        --radius-sm: 0.6rem;
        --space-xs: 0.4rem;
        --space-sm: 0.6rem;
        --space-md: 1rem;
        --space-lg: 1.6rem;
        --space-xl: 2.4rem;
        --line-height: 1.55;
        --shadow-lg: 0 32px 60px rgba(0, 0, 0, 0.5);
        --shadow-md: 0 20px 40px rgba(0, 0, 0, 0.35);
        --page-gradient: radial-gradient(120% 160% at top, #1b1e26 0%, #090b12 60%, #050609 100%);
      }
      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: var(--font-family);
        line-height: var(--line-height);
        background: var(--page-gradient);
        color: var(--text-primary);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }
      header,
      footer {
        padding: var(--space-md) var(--space-xl);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: var(--space-lg);
        background: var(--surface-0);
        border-bottom: 1px solid var(--border-subtle);
        backdrop-filter: blur(18px) saturate(130%);
        -webkit-backdrop-filter: blur(18px) saturate(130%);
        box-shadow: var(--shadow-md);
      }
      footer {
        border-top: 1px solid var(--border-subtle);
        border-bottom: none;
        justify-content: center;
        margin-top: auto;
      }
      main {
        padding: var(--space-xl);
        display: flex;
        justify-content: center;
      }
      .brand-area {
        display: flex;
        align-items: center;
        gap: var(--space-lg);
        flex-wrap: wrap;
      }
      .brand {
        font-size: 1.4rem;
        font-weight: 700;
      }
      .settings-card {
        width: min(960px, 100%);
        background: var(--surface-1);
        border-radius: var(--radius-lg);
        border: 1px solid var(--border-subtle);
        padding: var(--space-xl);
        box-shadow: var(--shadow-lg);
        display: flex;
        flex-direction: column;
        gap: var(--space-lg);
      }
      .tablist {
        display: flex;
        gap: var(--space-sm);
        margin-bottom: var(--space-lg);
        flex-wrap: wrap;
      }
      .tab-button {
        border: 1px solid var(--border-subtle);
        background: var(--surface-soft);
        color: var(--text-primary);
        padding: 0.45rem 1.1rem;
        border-radius: var(--radius-pill);
        cursor: pointer;
        font-weight: 600;
        transition: border-color var(--transition), color var(--transition), background var(--transition);
      }
      .tab-button[aria-selected="true"] {
        background: linear-gradient(135deg, #0a84ff, #54d1ff);
        color: #041026;
        border-color: transparent;
        box-shadow: 0 12px 24px rgba(10, 132, 255, 0.25);
      }
      .tab-button:not([aria-selected="true"]):hover,
      .tab-button:not([aria-selected="true"]):focus-visible {
        border-color: var(--accent);
        color: var(--accent);
        outline: none;
      }
      [data-tab-panel][hidden] {
        display: none !important;
      }
      .settings-card h1 {
        margin: 0;
      }
      .muted {
        color: var(--text-muted);
      }
      .visually-hidden {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        border: 0;
      }
      form {
        display: flex;
        flex-direction: column;
        gap: var(--space-lg);
      }
      fieldset {
        border: 1px solid var(--border-subtle);
        border-radius: var(--radius-md);
        padding: var(--space-md);
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: var(--space-sm);
      }
      legend {
        padding: 0 var(--space-xs);
        font-weight: 600;
      }
      label.option {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: var(--space-sm);
        align-items: center;
        padding: var(--space-sm);
        border-radius: var(--radius-sm);
        transition: background 140ms ease;
      }
      label.option:hover,
      label.option:focus-within {
        background: var(--surface-2);
      }
      label.option strong {
        display: block;
        font-weight: 600;
      }
      label.option span.helper {
        font-size: 0.85rem;
        color: var(--text-muted);
      }
      .option.inline-option {
        grid-template-columns: auto 1fr;
        align-items: center;
        padding: var(--space-sm);
      }
      .option.inline-option > div {
        margin-left: 0;
      }
      .preset-grid {
        display: grid;
        gap: var(--space-sm);
      }
      .preset-label {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: var(--space-sm);
        align-items: start;
        padding: var(--space-sm);
        border-radius: var(--radius-sm);
        border: 1px solid transparent;
        transition: border-color 160ms ease, background 160ms ease;
      }
      .preset-label:hover,
      .preset-label:focus-within {
        background: rgba(255, 255, 255, 0.05);
        border-color: var(--border-subtle);
      }
      .preset-label strong {
        display: block;
        font-weight: 600;
      }
      .preset-label span.meta {
        display: block;
        font-size: 0.85rem;
        color: var(--text-muted);
      }
      .expert-grid {
        display: grid;
        gap: var(--space-md);
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      }
      .expert-control {
        display: flex;
        flex-direction: column;
        gap: var(--space-xs);
        padding: var(--space-sm);
        border-radius: var(--radius-sm);
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      .expert-control label {
        font-weight: 600;
      }
      .expert-control input[type="number"] {
        padding: var(--space-sm);
        border-radius: var(--radius-sm);
        border: 1px solid var(--border-subtle);
        background: rgba(0, 0, 0, 0.25);
        color: var(--text-primary);
        font-size: 1rem;
      }
      .summary {
        padding: var(--space-md);
        border-radius: var(--radius-md);
        background: rgba(10, 132, 255, 0.16);
        border: 1px solid rgba(10, 132, 255, 0.4);
        font-weight: 600;
      }
      .motion-control {
        margin-top: var(--space-md);
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }
      .storage-grid {
        display: grid;
        gap: var(--space-md);
        margin-top: var(--space-md);
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      }
      .storage-grid input {
        width: 100%;
      }
      button[type="submit"] {
        align-self: flex-start;
        padding: 0.75rem 1.8rem;
        border-radius: 999px;
        border: none;
        background: linear-gradient(135deg, #0a84ff, #54d1ff);
        color: #041026;
        font-weight: 700;
        font-size: 1rem;
        cursor: pointer;
        box-shadow: 0 18px 36px rgba(10, 132, 255, 0.35);
        transition: transform 160ms ease, box-shadow 160ms ease;
      }
      button[type="submit"]:hover,
      button[type="submit"]:focus-visible {
        transform: translateY(-1px);
        box-shadow: 0 22px 40px rgba(10, 132, 255, 0.45);
      }
      button[type="submit"]:disabled {
        opacity: 0.6;
        cursor: wait;
      }
      .status {
        min-height: 1.4rem;
      }
      a.link {
        color: var(--text-accent);
        text-decoration: none;
        font-weight: 600;
      }
      a.link:hover,
      a.link:focus-visible {
        text-decoration: underline;
      }
      @media (max-width: 720px) {
        header,
        footer {
          flex-direction: column;
          align-items: stretch;
          text-align: center;
        }
        main {
          padding: var(--space-lg);
        }
        .settings-card {
          padding: var(--space-lg);
        }
      }
    </style>
  </head>
  <body>
    <header>
      <div class="brand-area">
        <strong class="brand">RevCam</strong>
        <span class="muted">Surveillance mode</span>
      </div>
      <a class="link" href="/surveillance">Back to surveillance</a>
    </header>
    <main>
      <section class="settings-card">
        <header>
          <h1>Surveillance settings</h1>
          <p class="muted">
            Configure recording behaviour for standard deployments or switch to expert
            mode for full control over frame rate and compression.
          </p>
        </header>
        <form id="surveillance-settings-form">
          <div class="tablist" role="tablist" aria-label="Surveillance settings sections">
            <button class="tab-button" type="button" data-tab="recording" aria-selected="true">
              Recording
            </button>
            <button class="tab-button" type="button" data-tab="motion" aria-selected="false">
              Motion detection
            </button>
            <button class="tab-button" type="button" data-tab="storage" aria-selected="false">
              Storage &amp; maintenance
            </button>
          </div>
          <section class="tab-panel" data-tab-panel="recording">
            <fieldset>
              <legend>Configuration mode</legend>
              <label class="option">
                <input type="radio" name="profile" value="standard" />
                <div>
                  <strong>Standard presets</strong>
                  <span class="helper">Pick from tuned combinations for common setups.</span>
                </div>
              </label>
              <label class="option">
                <input type="radio" name="profile" value="expert" />
                <div>
                  <strong>Expert controls</strong>
                  <span class="helper">Manually set capture frame rate and JPEG quality.</span>
                </div>
              </label>
            </fieldset>
            <fieldset>
              <legend>Recording resolution</legend>
              <p class="muted">
                Choose the capture resolution used for surveillance recordings and live
                previews. Higher resolutions increase detail at the cost of storage size
                and bandwidth.
              </p>
              <label class="visually-hidden" for="recording-resolution">
                Recording resolution
              </label>
              <select id="recording-resolution"></select>
              <p class="muted" id="active-resolution-label">Active resolution: —</p>
              <p class="muted status" id="resolution-status" aria-live="polite"></p>
            </fieldset>
            <section id="standard-section" aria-live="polite">
              <h2>Standard presets</h2>
              <p class="muted">
                Choose the preset that best reflects your surveillance needs. Presets adjust
                both the capture frame rate and recording compression.
              </p>
              <div class="preset-grid">
                <label class="preset-label">
                  <input type="radio" name="preset" value="balanced" />
                  <div>
                    <strong>Balanced coverage</strong>
                    <span class="meta">6 fps • JPEG quality 70 — ideal all-round coverage.</span>
                  </div>
                </label>
                <label class="preset-label">
                  <input type="radio" name="preset" value="detail" />
                  <div>
                    <strong>High detail</strong>
                    <span class="meta">9 fps • JPEG quality 85 — more motion clarity indoors.</span>
                  </div>
                </label>
                <label class="preset-label">
                  <input type="radio" name="preset" value="endurance" />
                  <div>
                    <strong>Extended endurance</strong>
                    <span class="meta">4 fps • JPEG quality 60 — longer recordings, smaller files.</span>
                  </div>
                </label>
              </div>
            </section>
            <section id="expert-section" hidden>
              <h2>Expert controls</h2>
              <p class="muted">
                Tune capture parameters precisely. Higher frame rates and JPEG quality increase
                detail at the cost of storage and bandwidth.
              </p>
              <div class="expert-grid">
                <div class="expert-control">
                  <label for="expert-fps">Frame rate</label>
                  <input id="expert-fps" type="number" min="1" max="30" step="1" />
                  <span class="muted">Frames captured per second.</span>
                </div>
                <div class="expert-control">
                  <label for="expert-quality">JPEG quality</label>
                  <input id="expert-quality" type="number" min="30" max="100" step="1" />
                  <span class="muted">Higher values increase detail while using more space.</span>
                </div>
              </div>
            </section>
            <label class="option inline-option">
              <input type="checkbox" id="recording-overlays" />
              <div>
                <strong>Include overlays in recordings</strong>
                <span class="helper">Uncheck to capture a clean video feed without UI overlays.</span>
              </div>
            </label>
            <label class="option inline-option">
              <input type="checkbox" id="remember-recording" />
              <div>
                <strong>Resume recording after restart</strong>
                <span class="helper">Return to surveillance mode and continue recording automatically.</span>
              </div>
            </label>
          </section>
          <section class="tab-panel" data-tab-panel="motion" hidden>
            <h2>Motion detection</h2>
            <p class="muted">
              Enable motion detection to reduce storage usage and focus recordings on activity.
            </p>
            <label class="option inline-option">
              <input type="checkbox" id="motion-enabled" />
              <div>
                <strong>Enable motion detection</strong>
                <span class="helper">Pause recording when no movement is detected and resume on motion.</span>
              </div>
            </label>
            <div class="motion-control">
              <label for="motion-sensitivity">Sensitivity</label>
              <input id="motion-sensitivity" type="range" min="0" max="100" step="1" />
              <span class="muted">Current sensitivity: <span id="motion-sensitivity-value">50</span>%</span>
            </div>
            <div class="motion-control">
              <label for="motion-decimation">Record every Nth frame</label>
              <input id="motion-decimation" type="number" min="1" max="30" step="1" />
              <span class="muted">
                Effective motion capture: <span id="motion-effective-fps">—</span> fps.
                Aim for 8 fps or below to balance performance and detail.
              </span>
            </div>
            <div class="motion-control">
              <label for="motion-post-seconds">Continue recording after motion (seconds)</label>
              <input id="motion-post-seconds" type="number" min="0" max="60" step="0.5" />
              <span class="muted">
                Avoids cutting off clips by holding the recording briefly once motion stops.
              </span>
            </div>
          </section>
          <section class="tab-panel" data-tab-panel="storage" hidden>
            <h2>Storage &amp; maintenance</h2>
            <p class="muted">
              Automatically split recordings, protect storage capacity and remove old clips on a schedule.
            </p>
            <div class="storage-grid">
              <div>
                <label for="chunk-duration">Split recordings every (seconds)</label>
                <input id="chunk-duration" type="number" min="0" max="86400" step="1" />
                <span class="muted">Set to 0 to keep each recording as a single file.</span>
              </div>
              <div>
                <label for="storage-threshold">Stop recording below free space (%)</label>
                <input id="storage-threshold" type="number" min="1" max="90" step="1" />
                <span class="muted">Recording stops automatically when free space drops below this value.</span>
              </div>
              <div>
                <label for="auto-purge-days">Auto purge recordings after (days)</label>
                <input id="auto-purge-days" type="number" min="0" max="3650" step="1" />
                <span class="muted">Set to 0 to keep recordings indefinitely.</span>
              </div>
            </div>
          </section>
          <div class="summary" id="settings-summary" role="status" aria-live="polite">
            Effective capture: —
          </div>
          <p class="muted" id="system-temperature" aria-live="polite">
            CPU temperature: —
          </p>
          <button type="submit">Save surveillance settings</button>
          <p class="muted status" id="settings-status"></p>
        </form>
      </section>
    </main>
    <footer>
      <a class="link" href="/surveillance">Back to surveillance</a>
      <a class="link" href="/">Back to live view</a>
    </footer>
    <script>
      const STANDARD_PRESETS = {
        balanced: {
          label: "Balanced coverage",
          fps: 6,
          jpeg_quality: 70,
        },
        detail: {
          label: "High detail",
          fps: 9,
          jpeg_quality: 85,
        },
        endurance: {
          label: "Extended endurance",
          fps: 4,
          jpeg_quality: 60,
        },
      };

      const form = document.getElementById("surveillance-settings-form");
      const profileInputs = Array.from(form.querySelectorAll('input[name="profile"]'));
      const presetInputs = Array.from(form.querySelectorAll('input[name="preset"]'));
      const standardSection = document.getElementById("standard-section");
      const expertSection = document.getElementById("expert-section");
      const expertFpsInput = document.getElementById("expert-fps");
      const expertQualityInput = document.getElementById("expert-quality");
      const statusText = document.getElementById("settings-status");
      const resolutionSelect = document.getElementById("recording-resolution");
      const resolutionStatus = document.getElementById("resolution-status");
      const activeResolutionLabel = document.getElementById("active-resolution-label");
      const summary = document.getElementById("settings-summary");
      const systemTemperatureText = document.getElementById("system-temperature");
      const tabButtons = Array.from(document.querySelectorAll(".tab-button"));
      const tabPanels = Array.from(document.querySelectorAll("[data-tab-panel]"));
      const overlayCheckbox = document.getElementById("recording-overlays");
      const rememberCheckbox = document.getElementById("remember-recording");
      const chunkDurationInput = document.getElementById("chunk-duration");
      const storageThresholdInput = document.getElementById("storage-threshold");
      const autoPurgeInput = document.getElementById("auto-purge-days");
      const motionEnabledInput = document.getElementById("motion-enabled");
      const motionSensitivityInput = document.getElementById("motion-sensitivity");
      const motionSensitivityValue = document.getElementById("motion-sensitivity-value");
      const motionDecimationInput = document.getElementById("motion-decimation");
      const motionEffectiveFpsText = document.getElementById("motion-effective-fps");
      const motionPostSecondsInput = document.getElementById("motion-post-seconds");

      let currentSettings = null;
      let cameraConfig = null;
      const resolutionLabels = new Map();

      function setActiveTab(tab) {
        const target = typeof tab === "string" && tab ? tab : "recording";
        tabButtons.forEach((button) => {
          const isActive = button.dataset.tab === target;
          button.setAttribute("aria-selected", String(isActive));
        });
        tabPanels.forEach((panel) => {
          const isActive = panel.dataset.tabPanel === target;
          if (isActive) {
            panel.removeAttribute("hidden");
          } else {
            panel.setAttribute("hidden", "hidden");
          }
        });
      }

      function updateMotionSensitivityLabel(value) {
        if (!motionSensitivityValue) {
          return;
        }
        const numeric = Number.isFinite(value)
          ? value
          : Number.parseInt(motionSensitivityInput?.value ?? "50", 10) || 50;
        motionSensitivityValue.textContent = String(Math.round(numeric));
      }

      function getMotionDecimation() {
        if (!motionDecimationInput) {
          return 1;
        }
        const numeric = Number.parseInt(motionDecimationInput.value, 10);
        if (!Number.isFinite(numeric) || numeric < 1) {
          return 1;
        }
        if (numeric > 30) {
          return 30;
        }
        return numeric;
      }

      function formatFpsLabel(value) {
        if (!Number.isFinite(value) || value <= 0) {
          return "—";
        }
        if (value >= 10) {
          return value.toFixed(0);
        }
        if (value >= 1) {
          return value.toFixed(1).replace(/\.0$/, "");
        }
        return value.toFixed(2);
      }

      function formatDurationSeconds(seconds) {
        if (!Number.isFinite(seconds) || seconds <= 0) {
          return null;
        }
        const rounded = Math.round(seconds);
        if (rounded < 60) {
          return `${rounded}s`;
        }
        if (rounded % 3600 === 0) {
          const hours = Math.round(rounded / 3600);
          return `${hours} hr${hours === 1 ? "" : "s"}`;
        }
        if (rounded % 60 === 0) {
          const minutes = Math.round(rounded / 60);
          return `${minutes} min`;
        }
        const minutes = Math.floor(rounded / 60);
        const remainder = rounded % 60;
        if (minutes >= 60) {
          const hours = Math.floor(minutes / 60);
          const remainingMinutes = minutes % 60;
          const parts = [];
          if (hours > 0) {
            parts.push(`${hours} hr${hours === 1 ? "" : "s"}`);
          }
          if (remainingMinutes > 0) {
            parts.push(`${remainingMinutes} min`);
          }
          if (remainder > 0) {
            parts.push(`${remainder}s`);
          }
          return parts.join(" ");
        }
        return `${minutes} min ${remainder}s`;
      }

      function formatTemperatureCelsius(value) {
        if (typeof value !== "number" || !Number.isFinite(value)) {
          return "";
        }
        const rounded = Math.round(value * 10) / 10;
        let text = rounded.toFixed(1);
        if (text.endsWith(".0")) {
          text = text.slice(0, -2);
        }
        return `${text}°C`;
      }

      function normaliseResolutionLabel(value) {
        if (!value) {
          return null;
        }
        if (resolutionLabels.has(value)) {
          return resolutionLabels.get(value);
        }
        return String(value).replace(/x/gi, "×");
      }

      function updateActiveResolutionDisplay(value) {
        if (!activeResolutionLabel) {
          return;
        }
        const label = normaliseResolutionLabel(value);
        activeResolutionLabel.textContent = label
          ? `Active resolution: ${label}`
          : "Active resolution: —";
      }

      function populateResolutionOptions(camera) {
        if (!resolutionSelect) {
          return;
        }
        resolutionLabels.clear();
        resolutionSelect.innerHTML = "";
        const resolutionInfo =
          camera && typeof camera === "object" && camera.resolution
            ? camera.resolution
            : null;
        const options =
          resolutionInfo && Array.isArray(resolutionInfo.options)
            ? resolutionInfo.options
            : [];
        if (!options.length) {
          const option = document.createElement("option");
          option.value = "";
          option.textContent = "No resolutions available";
          resolutionSelect.appendChild(option);
          resolutionSelect.disabled = true;
        } else {
          for (const option of options) {
            if (!option || typeof option !== "object") {
              continue;
            }
            const value =
              typeof option.value === "string" && option.value.trim()
                ? option.value.trim()
                : null;
            const label =
              typeof option.label === "string" && option.label.trim()
                ? option.label.trim()
                : null;
            if (!value || !label) {
              continue;
            }
            const opt = document.createElement("option");
            opt.value = value;
            opt.textContent = label;
            resolutionLabels.set(value, label);
            resolutionSelect.appendChild(opt);
          }
          resolutionSelect.disabled = false;
          const selected =
            resolutionInfo && typeof resolutionInfo.selected === "string"
              ? resolutionInfo.selected
              : null;
          if (selected && resolutionLabels.has(selected)) {
            resolutionSelect.value = selected;
          } else if (resolutionSelect.options.length > 0) {
            resolutionSelect.selectedIndex = 0;
          }
        }
        const active =
          resolutionInfo && typeof resolutionInfo.active === "string"
            ? resolutionInfo.active
            : null;
        updateActiveResolutionDisplay(active);
        if (resolutionStatus) {
          resolutionStatus.textContent = "";
        }
      }

      async function loadCameraConfig() {
        if (!resolutionSelect) {
          return;
        }
        resolutionSelect.disabled = true;
        if (resolutionStatus) {
          resolutionStatus.textContent = "Loading resolution options…";
        }
        try {
          const response = await fetch("/api/camera", { cache: "no-store" });
          if (!response.ok) {
            throw new Error(`Request failed with ${response.status}`);
          }
          const payload = await response.json();
          if (!payload || typeof payload !== "object") {
            throw new Error("Invalid camera response");
          }
          cameraConfig = payload;
          populateResolutionOptions(payload);
        } catch (error) {
          console.error("Failed to load camera configuration", error);
          cameraConfig = null;
          populateResolutionOptions(null);
          if (resolutionStatus) {
            resolutionStatus.textContent = "Unable to load resolution options.";
          }
        }
      }

      async function applyCameraResolution(value) {
        if (!resolutionSelect || !value || !cameraConfig) {
          return;
        }
        const selectedSource =
          typeof cameraConfig.selected === "string" && cameraConfig.selected
            ? cameraConfig.selected
            : "auto";
        resolutionSelect.disabled = true;
        if (resolutionStatus) {
          const label = normaliseResolutionLabel(value);
          resolutionStatus.textContent = label
            ? `Applying ${label}…`
            : "Applying resolution…";
        }
        try {
          const response = await fetch("/api/camera", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ source: selectedSource, resolution: value }),
          });
          if (!response.ok) {
            let message = `Unable to apply resolution (${response.status})`;
            try {
              const detail = await response.json();
              if (detail && detail.detail) {
                message = detail.detail;
              }
            } catch (parseError) {
              console.error(parseError);
            }
            throw new Error(message);
          }
          await loadCameraConfig();
          if (resolutionStatus) {
            const label = normaliseResolutionLabel(value);
            resolutionStatus.textContent = label
              ? `${label} applied.`
              : "Resolution updated.";
          }
        } catch (error) {
          console.error("Failed to apply camera resolution", error);
          if (resolutionStatus) {
            resolutionStatus.textContent =
              error instanceof Error ? error.message : "Unable to update resolution.";
          }
        } finally {
          if (resolutionSelect) {
            const firstOption = resolutionSelect.options[0];
            const hasChoice =
              resolutionSelect.options.length > 0 && firstOption && firstOption.value;
            resolutionSelect.disabled = !hasChoice;
          }
        }
      }

      function setSystemTemperatureLabel(text) {
        if (!systemTemperatureText) {
          return;
        }
        const suffix = text && text.length > 0 ? text : "—";
        systemTemperatureText.textContent = `CPU temperature: ${suffix}`;
      }

      async function refreshSystemTemperature() {
        if (!systemTemperatureText) {
          return;
        }
        setSystemTemperatureLabel("Loading…");
        try {
          const response = await fetch("/api/diagnostics", { cache: "no-store" });
          if (!response.ok) {
            throw new Error(`Diagnostics request failed with ${response.status}`);
          }
          const payload = await response.json();
          const system = payload && typeof payload.system === "object" ? payload.system : null;
          const cpu = system && typeof system.cpu === "object" ? system.cpu : null;
          const temperature =
            cpu && typeof cpu.temperature_celsius === "number" && Number.isFinite(cpu.temperature_celsius)
              ? cpu.temperature_celsius
              : null;
          if (temperature === null) {
            setSystemTemperatureLabel("Unavailable");
            return;
          }
          const formatted = formatTemperatureCelsius(temperature);
          setSystemTemperatureLabel(formatted || "Unavailable");
        } catch (error) {
          console.error("Failed to load system diagnostics", error);
          setSystemTemperatureLabel("Unable to load");
        }
      }

      function updateMotionGuidance() {
        if (!motionEffectiveFpsText) {
          return;
        }
        const decimation = getMotionDecimation();
        const effective = resolveEffectiveSettings();
        const baseFps = Number.isFinite(effective.fps) ? effective.fps : null;
        const motionFps = baseFps ? baseFps / Math.max(1, decimation) : null;
        motionEffectiveFpsText.textContent = formatFpsLabel(motionFps ?? 0);
      }

      tabButtons.forEach((button) => {
        button.addEventListener("click", () => {
          setActiveTab(button.dataset.tab || "recording");
        });
      });
      setActiveTab("recording");

      if (resolutionSelect) {
        resolutionSelect.addEventListener("change", () => {
          const value = resolutionSelect.value;
          if (!value) {
            return;
          }
          applyCameraResolution(value);
        });
      }

      if (motionSensitivityInput) {
        motionSensitivityInput.addEventListener("input", () => {
          updateMotionSensitivityLabel(Number(motionSensitivityInput.value));
          updateSummary();
        });
      }

      if (motionDecimationInput) {
        motionDecimationInput.addEventListener("input", () => {
          updateMotionGuidance();
          updateSummary();
        });
      }

      if (motionPostSecondsInput) {
        motionPostSecondsInput.addEventListener("input", updateSummary);
      }

      if (motionEnabledInput) {
        motionEnabledInput.addEventListener("change", updateSummary);
      }

      if (chunkDurationInput) {
        chunkDurationInput.addEventListener("input", updateSummary);
      }

      function getSelectedProfile() {
        const selected = profileInputs.find((input) => input.checked);
        return selected ? selected.value : "standard";
      }

      function getSelectedPreset() {
        const selected = presetInputs.find((input) => input.checked);
        return selected ? selected.value : "balanced";
      }

      function setProfile(profile) {
        profileInputs.forEach((input) => {
          input.checked = input.value === profile;
        });
        updateModeVisibility();
      }

      function setPreset(preset) {
        let matched = false;
        presetInputs.forEach((input) => {
          const checked = input.value === preset;
          input.checked = checked;
          if (checked) {
            matched = true;
          }
        });
        if (!matched && presetInputs.length) {
          presetInputs[0].checked = true;
        }
      }

      function updateModeVisibility() {
        const profile = getSelectedProfile();
        const standard = profile === "standard";
        standardSection.hidden = !standard;
        expertSection.hidden = standard;
        summary.dataset.profile = profile;
        updateSummary();
      }

      function resolveEffectiveSettings() {
        const profile = getSelectedProfile();
        if (profile === "standard") {
          const preset = getSelectedPreset();
          const config = STANDARD_PRESETS[preset] || STANDARD_PRESETS.balanced;
          return {
            profile,
            preset,
            fps: config.fps,
            jpeg_quality: config.jpeg_quality,
          };
        }
        const fpsValue = parseInt(expertFpsInput.value, 10);
        const qualityValue = parseInt(expertQualityInput.value, 10);
        return {
          profile,
          preset: getSelectedPreset(),
          fps: Number.isFinite(fpsValue) ? fpsValue : null,
          jpeg_quality: Number.isFinite(qualityValue) ? qualityValue : null,
        };
      }

      function updateSummary() {
        const effective = resolveEffectiveSettings();
        let text = "Effective capture: ";
        if (effective.fps && effective.jpeg_quality) {
          const prefix =
            effective.profile === "standard"
              ? `${STANDARD_PRESETS[effective.preset]?.label || "Preset"}: `
              : "Expert configuration: ";
          text += `${prefix}${effective.fps} fps, JPEG quality ${effective.jpeg_quality}`;
        } else {
          text += "—";
        }
        if (chunkDurationInput) {
          const seconds = parseInt(chunkDurationInput.value, 10);
          const durationLabel = formatDurationSeconds(Number.isFinite(seconds) ? seconds : 0);
          if (durationLabel) {
            text += ` • Split every ${durationLabel}`;
          }
        }
        if (motionEnabledInput && motionEnabledInput.checked && effective.fps) {
          const decimation = getMotionDecimation();
          const motionFps = effective.fps / Math.max(1, decimation);
          const motionLabel = formatFpsLabel(motionFps);
          if (decimation > 1) {
            text += ` • Motion capture ~${motionLabel} fps`;
          } else {
            text += ` • Motion capture ${motionLabel} fps`;
          }
          text += " (recommended ≤ 8 fps)";
          if (motionPostSecondsInput) {
            const lingerRaw = Number(motionPostSecondsInput.value);
            if (Number.isFinite(lingerRaw) && lingerRaw > 0) {
              const display = lingerRaw % 1 === 0 ? lingerRaw.toFixed(0) : lingerRaw.toFixed(1);
              text += ` • Hold ${display}s post-motion`;
            }
          }
        }
        summary.textContent = text;
        updateMotionGuidance();
      }

      function applySettings(settings) {
        if (!settings || typeof settings !== "object") {
          return;
        }
        currentSettings = settings;
        const profile = settings.profile === "expert" ? "expert" : "standard";
        setProfile(profile);
        setPreset(settings.preset || "balanced");
        expertFpsInput.value = settings.expert_fps ?? settings.fps ?? 6;
        expertQualityInput.value = settings.expert_jpeg_quality ?? settings.jpeg_quality ?? 75;
        updateModeVisibility();
        if (overlayCheckbox) {
          overlayCheckbox.checked = settings.overlays_enabled !== false;
        }
        if (rememberCheckbox) {
          rememberCheckbox.checked = Boolean(settings.remember_recording_state);
        }
        if (chunkDurationInput) {
          const seconds = Number(settings.chunk_duration_seconds ?? 0);
          const normalised = Number.isFinite(seconds) && seconds > 0 ? Math.round(seconds) : 0;
          chunkDurationInput.value = normalised;
        }
        if (storageThresholdInput) {
          const threshold = Number(settings.storage_threshold_percent ?? 10);
          storageThresholdInput.value = Number.isFinite(threshold) ? threshold : 10;
        }
        if (autoPurgeInput) {
          const days = Number(settings.auto_purge_days ?? 0);
          autoPurgeInput.value = Number.isFinite(days) && days > 0 ? Math.round(days) : 0;
        }
        if (motionEnabledInput) {
          motionEnabledInput.checked = Boolean(settings.motion_detection_enabled);
        }
        if (motionSensitivityInput) {
          const value = Number(settings.motion_sensitivity ?? 50);
          motionSensitivityInput.value = Number.isFinite(value) ? value : 50;
          updateMotionSensitivityLabel(Number(motionSensitivityInput.value));
        }
        if (motionDecimationInput) {
          const decimation = Number(settings.motion_frame_decimation ?? 1);
          const normalised =
            Number.isFinite(decimation) && decimation > 0
              ? Math.min(30, Math.max(1, Math.round(decimation)))
              : 1;
          motionDecimationInput.value = normalised;
        }
        if (motionPostSecondsInput) {
          const linger = Number(settings.motion_post_event_seconds ?? 0);
          const normalised =
            Number.isFinite(linger) && linger >= 0
              ? Math.min(60, Math.max(0, Math.round(linger * 2) / 2))
              : 0;
          motionPostSecondsInput.value = normalised;
        }
        updateSummary();
      }

      async function loadSettings() {
        statusText.textContent = "Loading settings…";
        try {
          const response = await fetch("/api/surveillance/settings", { cache: "no-store" });
          if (!response.ok) {
            throw new Error(`Request failed with ${response.status}`);
          }
          const payload = await response.json();
          if (!payload || typeof payload !== "object") {
            throw new Error("Invalid response payload");
          }
          applySettings(payload.settings);
          statusText.textContent = "";
        } catch (error) {
          console.error("Failed to load surveillance settings", error);
          statusText.textContent = "Unable to load surveillance settings.";
        }
      }

      profileInputs.forEach((input) => {
        input.addEventListener("change", () => {
          updateModeVisibility();
        });
      });
      presetInputs.forEach((input) => {
        input.addEventListener("change", () => {
          updateSummary();
        });
      });
      expertFpsInput.addEventListener("input", updateSummary);
      expertQualityInput.addEventListener("input", updateSummary);

      form.addEventListener("submit", async (event) => {
        event.preventDefault();
        const profile = getSelectedProfile();
        const payload = { profile };
        if (profile === "standard") {
          payload.preset = getSelectedPreset();
        } else {
          const fpsValue = parseInt(expertFpsInput.value, 10);
          const qualityValue = parseInt(expertQualityInput.value, 10);
          if (!Number.isFinite(fpsValue) || fpsValue < 1 || fpsValue > 30) {
            statusText.textContent = "Enter a frame rate between 1 and 30 fps.";
            expertFpsInput.focus();
            return;
          }
          if (!Number.isFinite(qualityValue) || qualityValue < 30 || qualityValue > 100) {
            statusText.textContent = "JPEG quality must be between 30 and 100.";
            expertQualityInput.focus();
            return;
          }
          payload.expert_fps = fpsValue;
          payload.expert_jpeg_quality = qualityValue;
        }
        payload.overlays_enabled = overlayCheckbox ? overlayCheckbox.checked : true;
        payload.remember_recording_state = rememberCheckbox ? rememberCheckbox.checked : false;
        if (motionEnabledInput) {
          payload.motion_detection_enabled = motionEnabledInput.checked;
        }
        if (motionSensitivityInput) {
          const motionValue = parseInt(motionSensitivityInput.value, 10);
          payload.motion_sensitivity = Number.isFinite(motionValue) ? motionValue : 50;
        }
        if (motionDecimationInput) {
          const decimationValue = parseInt(motionDecimationInput.value, 10);
          const normalised =
            Number.isFinite(decimationValue) && decimationValue > 0
              ? Math.min(30, Math.max(1, decimationValue))
              : 1;
          payload.motion_frame_decimation = normalised;
        }
        if (motionPostSecondsInput) {
          const lingerValue = parseFloat(motionPostSecondsInput.value);
          if (
            Number.isFinite(lingerValue) &&
            lingerValue >= 0 &&
            lingerValue <= 60
          ) {
            payload.motion_post_event_seconds = lingerValue;
          } else if (motionPostSecondsInput.value !== "") {
            statusText.textContent = "Post-motion recording must be between 0 and 60 seconds.";
            motionPostSecondsInput.focus();
            return;
          } else {
            payload.motion_post_event_seconds = 0;
          }
        }
        if (chunkDurationInput) {
          const chunkSeconds = parseInt(chunkDurationInput.value, 10);
          if (Number.isFinite(chunkSeconds) && chunkSeconds > 0) {
            if (chunkSeconds > 86400) {
              statusText.textContent = "Chunk duration must be 86400 seconds or less.";
              chunkDurationInput.focus();
              return;
            }
            payload.chunk_duration_seconds = chunkSeconds;
          } else {
            payload.chunk_duration_seconds = 0;
          }
        }
        if (storageThresholdInput) {
          const thresholdValue = parseFloat(storageThresholdInput.value);
          if (!Number.isFinite(thresholdValue) || thresholdValue < 1 || thresholdValue > 90) {
            statusText.textContent = "Storage threshold must be between 1 and 90%.";
            storageThresholdInput.focus();
            return;
          }
          payload.storage_threshold_percent = thresholdValue;
        }
        if (autoPurgeInput) {
          const purgeValue = parseInt(autoPurgeInput.value, 10);
          payload.auto_purge_days = Number.isFinite(purgeValue) && purgeValue > 0 ? purgeValue : 0;
        }
        statusText.textContent = "Saving settings…";
        form.querySelector("button[type='submit']").disabled = true;
        try {
          const response = await fetch("/api/surveillance/settings", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          if (!response.ok) {
            const detail = await response.json().catch(() => null);
            const message = detail && detail.detail ? detail.detail : "Unable to save settings.";
            throw new Error(message);
          }
          const result = await response.json();
          applySettings(result.settings);
          statusText.textContent = "Surveillance settings saved.";
          updateSummary();
        } catch (error) {
          console.error("Failed to save surveillance settings", error);
          statusText.textContent =
            error instanceof Error ? error.message : "Unable to save surveillance settings.";
        } finally {
          form.querySelector("button[type='submit']").disabled = false;
        }
      });

      loadCameraConfig();
      loadSettings();
      refreshSystemTemperature();
    </script>
  </body>
</html>
